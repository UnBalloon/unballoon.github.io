<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iniciante on UnBalloon</title><link>https://unballoon.github.io/tags/iniciante/</link><description>Recent content in iniciante on UnBalloon</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><atom:link href="https://unballoon.github.io/tags/iniciante/index.xml" rel="self" type="application/rss+xml"/><item><title>Complexidade</title><link>https://unballoon.github.io/materiais/fundamentos/complexidade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/complexidade/</guid><description>O que é Complexidade? Em linhas gerais, a complexidade de tempo de um algoritmo é o quanto as variáveis de entrada impactam no seu tempo de execução.
Para se referir a complexidade de um algoritmo, se usa a notação Big O, denotada por O(N). A notação Big O tem o seguinte significado: No pior caso da execução deste algoritmo, o número de operações realizado será proporcional a N, e por simplicidade, eliminamos constantes e fatores não dominantes.</description></item><item><title>Linear</title><link>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/</guid><description>Subpáginas Pilha Fila Fila de Prioridade</description></item><item><title>Entrada/Saída</title><link>https://unballoon.github.io/materiais/fundamentos/input-output/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/input-output/</guid><description>Entrada O objeto &amp;ldquo;cin&amp;rdquo; representa o stream de entrada no C++. Ele realiza a leitura de um sequência de dados, sem espaços e sem tabulações, vindas do teclado. Para coletar estes dados armazenados, usa-se o &amp;ldquo;operador de extração&amp;rdquo; que &amp;ldquo;extrai&amp;rdquo; dados do stream.
Lendo um Input A primeira linha terá N que é a quantidade de números a serem lidos.
A segunda linha será os N números.
input: 4 1 5 2 3 #include &amp;lt;bits/stdc++.</description></item><item><title>Não Linear</title><link>https://unballoon.github.io/materiais/fundamentos/eds/ed_n_linear/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/ed_n_linear/</guid><description>Subpáginas Map Set</description></item><item><title>Strings</title><link>https://unballoon.github.io/materiais/fundamentos/declaracoes/string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/declaracoes/string/</guid><description>No C++ representa uma sequência de caracteres
Podemos declarar uma string como:
string nomevar; string nomevar = constante; string nomevar = char ∗ variavel; string nomevar(char ∗ variavel); string nomevar(tamanho, constante char); Concatenação Podemos usar o operador &amp;ldquo;+&amp;rdquo; para concatenar duas strings
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ string a = &amp;#34;abc&amp;#34;; string b = &amp;#34;def&amp;#34;; string c = a + b; cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl; // abcdef return 0; } Transformando um inteiro em string Podemos transformar um inteiro em uma string usando a função &amp;ldquo;to_string()&amp;rdquo;</description></item><item><title>Estrutura de Dados</title><link>https://unballoon.github.io/materiais/fundamentos/eds/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/</guid><description>Subpáginas Linear Não Linear</description></item><item><title>Vector</title><link>https://unballoon.github.io/materiais/fundamentos/declaracoes/vector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/declaracoes/vector/</guid><description>Vector pode ser entendido como uma estruturas de dados similar a um array de tamanho expansível.
A diferença principal entre vector e array é a alocação: no array adota-se alocação estática, enquanto que no vector a alocaçãao é dinâmica.
Inicializar #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ // inicializando vetores vazios vector&amp;lt;double&amp;gt; vd; vector&amp;lt;pair&amp;lt;int,double&amp;gt;&amp;gt; vid; vector&amp;lt;string&amp;gt; vs; vector&amp;lt;int&amp;gt; v; // vector&amp;lt;int&amp;gt; v(tamanho, valor) vector&amp;lt;int&amp;gt; v(4, 0); // {0, 0, 0, 0} vetor de 4 posições com valor 0 vector&amp;lt;int&amp;gt; v(4); // {0, 0, 0, 0} por default, inicializa como 0 v.</description></item><item><title>Pairs</title><link>https://unballoon.github.io/materiais/fundamentos/declaracoes/pair/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/declaracoes/pair/</guid><description>O pair é muito importante quando precisamos guardar duas informações juntas.
Um &amp;ldquo;pair&amp;rdquo; é um contêiner que consiste de dois tipos de dados ou objetos.
Declaramos um pair como:
pair&amp;lt;tipodado1, tipodado2&amp;gt; variavel; Podemos inicializá-lo usando o make_pair ou diretamente:
variavel = make_pair(dado1, dado2); variavel = {dado1, dado2}; O primeiro elemento é acessado usando o &amp;ldquo;first&amp;rdquo; e o segundo usando &amp;ldquo;second&amp;rdquo; variavel.first; variavel.second; Exemplo 1: Um Pair que armazena 2 inteiros #include &amp;lt;bits/stdc++.</description></item><item><title>Iterators</title><link>https://unballoon.github.io/materiais/fundamentos/declaracoes/iterators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/declaracoes/iterators/</guid><description>Iterators são tipos específicos de ponteiros que referenciam endereçoos de memória de objetos e contêiners STL.
Exemplo 1 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4, 5}; vector&amp;lt;int&amp;gt;::iterator ptr; cout&amp;lt;&amp;lt;&amp;#34;Elementos do Vetor&amp;#34;&amp;lt;&amp;lt;endl; for(ptr = v.begin(); ptr != v.end(); ptr++){ cout&amp;lt;&amp;lt;(*ptr)&amp;lt;&amp;lt;endl; } return 0; } Dica Você pode usar o auto no lugar de vector&amp;lt;int&amp;gt;::iterator, para facilitar
Exemplo 2 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main(){ vector&amp;lt;int&amp;gt; ar = { 1, 2, 3, 4, 5 }; // Declaring iterators to a vector vector&amp;lt;int&amp;gt;::iterator ptr = ar.</description></item><item><title>Pilha</title><link>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/pilha/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/pilha/</guid><description>A pilha é uma estrutura que, como o nome sugere, permite inserção e remoção apenas do &amp;ldquo;topo&amp;rdquo;. Isto significa que, ao remover um elemento da pilha, o elemento a ser removido é o último que foi inserido. Também é conhecido como LIFO (last-in first-out).
Métodos: push - Insere um elemento na pilha. pop - Remove o elemento do topo da pilha. top - Retorna o elemento do topo da pilha. size - Retorna o tamanho da pilha.</description></item><item><title>Fila</title><link>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/fila/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/fila/</guid><description>A fila segue o padrão de FIFO (first-in first-out), ao contrário da pilha, o primeiro elemento inserido será o primeiro a ser removido. Ela é muito útil para problemas que precisamos manter os elementos na ordem em que lhes foram dados.
Métodos push - Adiciona um elemento no fim da fila. front - Retorna o elemento do início da fila. back - Retorna o elemento do final da fila. pop - Remove o elemento do início da fila.</description></item><item><title>Fila de Prioridade</title><link>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/fila_prioridade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/ed_linear/fila_prioridade/</guid><description>Uma fila de prioridade tem como principal característica a ordenação, ela mantém o elemento do topo como sempre sendo o maior (ou o menor) elemento sempre.
Caso esteja fixado para o elemento do topo ser o maior, a fila de prioridade estará em ordem descrescente do topo para baixo. Caso contrário, a ordem será crescente.
Por padrão, ela estará fixado para o elemento do topo ser o maior, logo, estará em ordem decrescente os elementos na fila de prioridade.</description></item><item><title>Map</title><link>https://unballoon.github.io/materiais/fundamentos/eds/ed_n_linear/map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/ed_n_linear/map/</guid><description>O map é uma estrutura interessante pois permite &amp;ldquo;mapear&amp;rdquo; chaves à valores, e dado uma chave encontrar o seu valor rapidamente (complexidade depende da implementação). Por exemplo, podemos fazer um map com strings de chave e int de valor, sendo possível recuperar o valor inteiro associado a aquela string rapidamente.
Deve-se ter cuidado com o uso de map pois ele é implementado em c++ como um set de pairs, isto é, vai ter complexidade O(log n) para inserir e modificar dados.</description></item><item><title>Set</title><link>https://unballoon.github.io/materiais/fundamentos/eds/ed_n_linear/set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/fundamentos/eds/ed_n_linear/set/</guid><description>A estrutura set é bem parecida com o que conhecemos de conjuntos da matemática; não existem elementos repetidos e a ordem não importa.
A implementação do set, porém, é feita com uma árvore binária de busca, sendo assim permitido inserir, remover e acessar um elemento em O(log n).
A vantagem do set em relação ao vector é que, caso queira inserir um elemento em um vector ordenado e preservar a ordenação, você terá que procurar o lugar que ele deve ser inserido, fazer a inserção e modificar a posição dos elementos à direita dele.</description></item></channel></rss>