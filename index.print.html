<!doctype html><html lang=pt dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.111.3"><meta name=generator content="Relearn 5.4.0+tip"><meta name=description content="Repositorio do UnBalloon"><meta name=author content="Bruno Vargas"><title>UnBalloon</title><link href=/ rel=canonical type=text/html title=UnBalloon><link href=/index.xml rel=alternate type=application/rss+xml title=UnBalloon><link href=/images/favicon.png?1682184136 rel=icon type=image/png><link href=/css/fontawesome-all.min.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css?1682184136 rel=stylesheet></noscript><link href=/css/featherlight.min.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/featherlight.min.css?1682184136 rel=stylesheet></noscript><link href=/css/auto-complete.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/auto-complete.css?1682184136 rel=stylesheet></noscript><link href=/css/perfect-scrollbar.min.css?1682184136 rel=stylesheet><link href=/css/nucleus.css?1682184136 rel=stylesheet><link href=/css/fonts.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css?1682184136 rel=stylesheet></noscript><link href=/css/theme.css?1682184136 rel=stylesheet><link href=/css/theme-neon.css?1682184136 rel=stylesheet id=variant-style><link href=/css/ie.css?1682184136 rel=stylesheet><link href=/css/variant.css?1682184136 rel=stylesheet><link href=/css/print.css?1682184136 rel=stylesheet media=print><link href=/css/format-print.css?1682184136 rel=stylesheet><script src=/js/variant.js?1682184136></script>
<script>window.index_js_url="/index.search.js";var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copiar para a √°rea de transfer√™ncia",window.T_Copied_to_clipboard="Copiado para a √°rea de transfer√™ncia!",window.T_Copy_link_to_clipboard="Link de c√≥pia para a √°rea de transfer√™ncia",window.T_Link_copied_to_clipboard="Link copiado para a √°rea de transfer√™ncia!",baseUriFull="https://unballoon.github.io/",window.variants&&variants.init(["neon","relearn-dark","relearn-light","learn","blue","green","red"])</script><script src=/js/jquery.min.js?1682184136 defer></script></head><body class="mobile-support print" data-url=/><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div class=navigation><a class="nav nav-next" href=/sobre/ title="Sobre (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a></div><div class=navigation><span class="nav nav-prev"><i class="fa fa-chevron-left fa-fw"></i></span></div><div id=top-print-link><a class=print-link title='Imprimir cap√≠tulo inteiro (CTRL+ALT+p)' href=/index.print.html><i class="fas fa-print fa-fw"></i></a></div><div id=top-github-link><a class=github-link title='Editar (CTRL+ALT+w)' href=https://github.com/UnBalloon/unballoon.github.io/edit/main/content//_index.md target=blank><i class="fas fa-pen fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span>
<span id=toc-menu title='√çndice (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>UnBalloon</span><meta itemprop=position content="1"></li></ol></div><div class="default-animation progress"><div class=toc-wrapper dir=ltr><nav id=TableOfContents><ul><li><a href=#subp√°ginas>Subp√°ginas</a></li></ul></nav></div></div></div></nav><main id=body-inner class="highlightable home" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class="home deprecated" dir=ltr><h1 id=o-grupo-de-programa√ß√£o-competitiva-mais-top-do-centro-oeste>O Grupo de programa√ß√£o competitiva mais top do Centro-Oeste</h1><p><img src=/images/foto-geral.JPG alt="Foto UnBalloon"></p><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/sobre/>Sobre</a></li><li><a href=/materiais/>Materiais</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de UnBalloon</h1><article class=default dir=ltr><h1>Sobre</h1><h2 id=o-que-√©-programa√ß√£o-competitiva>O que √© Programa√ß√£o Competitiva</h2><p>S√£o competi√ß√µes em que basicamente voc√™ recebe desafios de programa√ß√£o para resolver em um determinado tempo. Em geral ganha quem conseguir resolver mais problemas em um menor tempo. Existem v√°rios formatos de competi√ß√£o, dentre eles √© comum:</p><ul><li>Competi√ß√µes em grupo (ex: 3 pessoas e 1 computador)</li><li>Competi√ß√µes individuais</li></ul><p><strong>OBS</strong>: A programa√ß√£o competitiva tem uma grande similaridade com olimp√≠adas cient√≠ficas. Al√©m de ter diretamente as olimp√≠adas de programa√ß√£o (ex: <strong>OBI</strong>), a estrutura das competi√ß√µes s√£o feitas em etapas que muitas vezes giram em torno de <strong>regional</strong> ‚Üí <strong>nacional</strong> ‚Üí <strong>mundial</strong>.</p><h2 id=como-isso-pode-me-ajudar>Como isso pode me ajudar?</h2><ul><li><p><strong>Benef√≠cio pessoal üß†</strong>¬† - A programa√ß√£o competitiva possibilita um desenvolvimento muito grande do seu racioc√≠nio l√≥gico, portanto, al√©m de aumentar muito suas habilidades na programa√ß√£o (pensamentos r√°pidos, habilidade de lidar bem com algoritmos e estrutura de dados), contribui consideravelmente com o seu desenvolvimento de uma forma geral (ex: racioc√≠nio l√≥gico r√°pido para atividades do dia-a-dia ou do seu trabalho, desenvolvimento do pensamento matem√°tico, melhora na capacidade anal√≠tica etc)</p></li><li><p><strong>Benef√≠cio Profissional üî≠</strong>¬† - A programa√ß√£o competitiva √© uma porta de entrada para o mercado de trabalho, principalmente quando se trata de empresas grandes, sejam <em>Big Techs</em> como <strong>Google</strong>, <strong>Facebook</strong> ou Grandes empresas Nacionais como <strong>VTEX</strong>, <strong>Quinto Andar</strong> etc. Mas como me ajuda exatamente?</p><ul><li><p><strong>Entrevistas t√©cnicas facilitadas</strong> - Muitas empresas fazem um processo seletivo com algum teste de racioc√≠nio/c√≥digo para testar suas habilidades. Uma pessoa com boas habilidades na programa√ß√£o competitiva basicamente &ldquo;tira de letra&rdquo; esses testes.</p></li><li><p><strong>Oportunidades de emprego</strong> - Muitas empresas enxergam o valor de bons programadores competitivos e &ldquo;correm atr√°s&rdquo; para contratar esse p√∫blico. Portanto, os eventos de programa√ß√£o s√£o uma grande porta para os &ldquo;olheiros&rdquo; fazerem propostas de emprego. (Algo comum na final brasileira da maratona SBC de programa√ß√£o, que tem encontro com patrocinadores e din√¢micas desse tipo).</p></li></ul></li><li><p><strong>Networking ü§ù</strong>¬† - A programa√ß√£o competitiva √© um polo de pessoas inteligentes que tem muito a agregar com informa√ß√µes e expertises. Portanto esse mundo √© um √≥timo meio para se relacionar com pessoas com prop√≥sitos legais.</p></li></ul><h2 id=ver-mais>Ver mais</h2><ul class="children children-li children-sort-"><li><a href=/sobre/dicas/>Dicas para Iniciantes</a></li><li><a href=/sobre/unb/>UnB na Competitiva</a></li><li><a href=/sobre/eventos/>Eventos Anteriores</a></li><li><a href=/sobre/competicoes/>Competi√ß√µes</a></li><li><a href=/sobre/referencias/>Refer√™ncias</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Sobre</h1><article class=default dir=ltr><h1>Dicas para Iniciantes</h1><p>Para come√ßar na programa√ß√£o competitiva voc√™ deve ter o dom√≠nio b√°sico de programa√ß√£o em alguma linguagem de programa√ß√£o.</p><p>Na competitiva a principal linguagem √© o <strong>C++</strong>, devido a sua velocidade de execu√ß√£o e flexibilidade/potencial para escrever os mais diferentes algoritmos.</p><div class="box notices cstyle default"><div class=box-label><i class="fa fa-question"></i> D√∫vida muito comum</div><div class=box-content><p>Devo come√ßar na linguagem que tenho mais afinidade (ex: Python) ou j√° come√ßo em C++?</p></div></div><p>Essa d√∫vida pode ter diferentes caminhos/opini√µes, mas aqui vai uma sugest√£o:</p><ul><li>Se voc√™ quer um caminho mais eficiente para ter resultados mais r√°pidos na programa√ß√£o competitiva, recomendo come√ßar em C++ com o curso do Neps. Acredito que a curva de aprendizado para entender o C++ (que √© um pouco mais chato que Python por exemplo) √© relativamente r√°pida e assim voc√™ j√° est√° com a ferramenta mais assertiva para a competitiva.</li></ul><p><a href=https://neps.academy/br/course/programacao-basica-(codcad)><img src=/images/neps.png alt=NEPS></a></p><ul><li>Se voc√™ quer apenas experimentar um pouco a competitiva a fim de ver como funciona, participar casualmente de algumas competi√ß√µes, talvez continuar com sua linguagem de programa√ß√£o pode ser um caminho, e caso tenha mais interesse pode migrar para a sintaxe do C++.</li></ul><p>Ap√≥s ter esse contato introdut√≥rio com a Linguagem, √© importante que seja feito um ciclo de estudo e pr√°tica de novos conte√∫dos.</p><p><strong>Pr√°tica:</strong></p><ul><li>A plataforma mais famosa de competitiva √© o <a href=https://codeforces.com>https://codeforces.com</a>, com diversos problemas e competi√ß√µes semanais.</li><li>Tem outros sites como <a href=https://atcoder.jp>https://atcoder.jp</a> (esse especificamente √© bom para iniciantes pois tem problemas partindo de um n√≠vel mais b√°sico al√©m de ter quest√µes mais ‚Äúeducativas" - com conte√∫dos mais estruturados, algoritmos cl√°ssicos etc)</li><li>O <a href=https://www.beecrowd.com.br/judge/pt/login(antigo>https://www.beecrowd.com.br/judge/pt/login(antigo</a> URI) √© uma bom meio para praticar tamb√©m, √© a maior plataforma nacional dessa √°rea com muitos problemas interessantes.</li></ul><p><strong>Conte√∫do</strong>:</p><ul><li><span class="btn cstyle orange"><a href=/tags/iniciante>UnBalloon : Iniciante</a></span></li><li><p>Neps Academy - Al√©m da parte introdut√≥ria voc√™ vai encontrar diversos outros cursos com temas para programa√ß√£o competitiva:</p><ul><li>Estrutura de dados - <a href=https://neps.academy/br/course/estruturas-de-dados-(codcad)>https://neps.academy/br/course/estruturas-de-dados-(codcad)</a></li><li>Grafos - <a href=https://neps.academy/br/course/algoritmos-em-grafos-(codcad)>https://neps.academy/br/course/algoritmos-em-grafos-(codcad)</a></li><li>Matem√°tica - <a href=https://neps.academy/br/course/matematica-computacional-(codcad)>https://neps.academy/br/course/matematica-computacional-(codcad)</a></li><li>T√©cnicas de programa√ß√£o - <a href=https://neps.academy/br/course/tecnicas-de-programacao-(codcad)>https://neps.academy/br/course/tecnicas-de-programacao-(codcad)</a></li></ul><p>Possibilidade de ordem: ED, T√©cnicas de programa√ß√£o, Matem√°tica e Grafos</p></li><li><p>Projeto de extens√£o da UnB - <a href=https://unb-cic.github.io/Maratona-Extensao/>https://unb-cic.github.io/Maratona-Extensao/</a></p></li></ul><footer class=footline></footer></article><article class=default dir=ltr><h1>UnB na Competitiva</h1><p><a href=https://noticias.unb.br/112-extensao-e-comunidade/5339-equipe-da-unb-se-destaca-em-torneio-mundial-de-programacao><img src=/images/rocklee.jpg alt=RockLee></a></p><blockquote><p><img src=https://noticias.unb.br/112-extensao-e-comunidade/5339-equipe-da-unb-se-destaca-em-torneio-mundial-de-programacao alt="Equipe da UnB destaca-se em torneio mundial de programa√ß√£o"></p></blockquote><h2 id=a-unb-tem-tido-um-√≥timo-destaque-nacional-na-programa√ß√£o-competitiva-nos-√∫ltimos-anos>A UnB tem tido um √≥timo destaque nacional na programa√ß√£o competitiva nos √∫ltimos anos</h2><ul><li>2 anos consecutivos na final Mundial</li><li>Melhor resultado Brasileiro na Mundial em 2021</li><li>13¬∫ Lugar na Nacional de 2022</li><li>9¬∫ e 11¬∫ Lugar na Regional de 2023</li><li>6¬∫ e 9¬∫ Lugar na Nacional de 2023</li><li>Time classificado pro Mundial no Egito em 2023</li></ul><h2 id=m√≠dia-social-unballoon>M√≠dia Social UnBalloon</h2><ul><li>O principal √© o grupo UnBalloon üéà (Grupo da UnB envolvido na competitiva)</li></ul><p>Discord: <a href=https://discord.gg/ug677zwZsn>https://discord.gg/ug677zwZsn</a></p><p>Telegram: <a href=https://t.me/unballoon>https://t.me/unballoon</a> (geral) / <a href=https://t.me/avisosunballoon>https://t.me/avisosunballoon</a> (avisos)</p><h2 id=mat√©rias-de-programa√ß√£o-competitiva>Mat√©rias de Programa√ß√£o Competitiva</h2><ul><li>Programa√ß√£o Competitiva &#187; Darcy</li><li>T√≥picos Especiais em Programa√ß√£o Competitiva &#187; Darcy</li><li>T√≥picos Especiais em Programa√ß√£o &#187; Gama</li></ul><h2 id=projetos-de-extens√£o>Projetos de Extens√£o</h2><ul><li>Em alguns semestres s√£o realizados projetos de extens√£o para competitiva</li><li>O √∫ltimo ocorreu em 2020.2: <a href=https://unb-cic.github.io/Maratona-Extensao/>https://unb-cic.github.io/Maratona-Extensao/</a></li></ul><footer class=footline></footer></article><article class=default dir=ltr><h1>Eventos Anteriores</h1><h2 id=iii-maratona-unballoon>III Maratona UnBalloon</h2><p>Foi a primeira maratona UnBalloon realizada presencialmente. Houve a participa√ß√£o de 14 times presencialmente e muitos bal√µes foram entregues!</p><p><img src=/images/3maratona.jpg alt=3maratona></p><h3 id=arquivos>Arquivos:</h3><span class="btn cstyle default"><a href=https://drive.google.com/drive/folders/1lNyTgfaEfc5508HrJhrPkZach2-ZaWx3 target=_blank rel=noopener>Fotos</a></span>
<span class="btn cstyle default"><a href=https://codeforces.com/group/nituVTsHQX/contest/385543 target=_blank rel=noopener>Problemas (mirror no Codeforces)</a></span>
<span class="btn cstyle default"><a href=https://i.imgur.com/Jx2FsEG.jpg target=_blank rel=noopener>Placar</a></span><h2 id=ii-olimp√≠ada-unballoon-de-inform√°tica>II Olimp√≠ada UnBalloon de Inform√°tica</h2><p>Maratona feita com o formato da OBI para treinar quem iria participar.</p><p><img src=/images/olimpiadaunballoon.JPG alt=olimpiadaunballoon></p><h3 id=arquivos-1>Arquivos:</h3><span class="btn cstyle default"><a href=https://drive.google.com/drive/folders/1Veowe2l3RWyQ_VvYG12g3UDiszNivnF2 target=_blank rel=noopener>Fotos</a></span>
<span class="btn cstyle default"><a href=https://codeforces.com/group/nituVTsHQX/contest/394596 target=_blank rel=noopener>Problemas (mirror no Codeforces)</a></span>
<span class="btn cstyle default"><a href=https://codeforces.com/group/nituVTsHQX/contest/394596/standings target=_blank rel=noopener>Placar</a></span><h2 id=x-maratona-unb>X Maratona UnB</h2><p>Foi a Maratona que selecionou os times da UnB e do IFB para a primeira fase da ICPC. Houve a participa√ß√£o de 30 times presencialmente.</p><p><img src=/images/xmaratona.jpg alt=xmaratona></p><h3 id=arquivos-2>Arquivos:</h3><span class="btn cstyle default"><a href=https://drive.google.com/drive/folders/1c8UY49nprZ3CHuEu1A5GqYvcQpwAl59P target=_blank rel=noopener>Fotos</a></span>
<span class="btn cstyle default"><a href=https://codeforces.com/group/btcK4I5D5f/contest/396683 target=_blank rel=noopener>Problemas (mirror no Codeforces)</a></span>
<span class="btn cstyle default"><a href=https://drive.google.com/file/d/1LNFqJzvBqt0UW5wj2qgQvHeJbxJFrhxl/view target=_blank rel=noopener>Placar</a></span>
<span class="btn cstyle default"><a href=https://drive.google.com/file/d/1YTYNHQd99EeOO3HCbd2CPEYWxUgM5WxT/view target=_blank rel=noopener>Estat√≠sticas</a></span><h2 id=vii-maratona-do-ifb>VII Maratona do IFB</h2><p>Maratona realizada no IFB com parceria da UnB</p><p><img src=/images/maratonaifb.JPG alt=maratonaifb></p><h3 id=arquivos-3>Arquivos:</h3><span class="btn cstyle default"><a href=https://drive.google.com/drive/folders/10rOljVLfeAeFlz0AEYZc_KlXiGU6xc8b target=_blank rel=noopener>Fotos</a></span>
<span class="btn cstyle default"><a href=https://codeforces.com/group/btcK4I5D5f/contest/411199 target=_blank rel=noopener>Problemas (mirror no Codeforces)</a></span>
<span class="btn cstyle default"><a href=https://danielsaad.com/maratona/blog/2022/11/19/7-mdp-ifb-resultados.html target=_blank rel=noopener>Informa√ß√µes</a></span><h2 id=ii-maratona-de-apc>II Maratona de APC</h2><p>Maratona voltada para os calouros que est√£o cursando a disciplina APC</p><p><img src=/images/maratonaapc.JPG alt=maratonaapc></p><h3 id=arquivos-4>Arquivos:</h3><span class="btn cstyle default"><a href=https://drive.google.com/drive/folders/1LhkbIQh2avvD00VlQB_wWDRyNiUy82xS target=_blank rel=noopener>Fotos</a></span><footer class=footline></footer></article><article class=default dir=ltr><h1>Competi√ß√µes</h1><h2 id=obi---olimp√≠ada-brasileira-de-inform√°tica>OBI - Olimp√≠ada Brasileira de inform√°tica</h2><p><a href=https://olimpiada.ic.unicamp.br/><img src=/images/obi.jpeg alt=OBI></a></p><ul><li>Voltado para estudantes do Ensino M√©dio e alunos do 1¬∫ ano da gradua√ß√£o (cursando a primeira faculdade)</li><li>Competi√ß√£o individual</li></ul><h2 id=maratona-sbc--icpc>Maratona SBC / ICPC</h2><p><a href=http://maratona.sbc.org.br/><img src="/images/sbc.png?classes=center" alt=SBC></a>
<a href=https://icpc.global/><img src="/images/icpc.png?classes=center" alt=ICPC></a></p><ul><li>Principal competi√ß√£o universit√°ria</li><li>Competi√ß√£o em equipe (3 pessoas)</li><li>Estrutura: Local (Seletiva da universidade) ‚Üí 1¬™ Fase Maratona SBC ‚Üí Final Brasileira Maratona SBC ‚Üí Final Mundial ICPC</li></ul><h3 id=quem-pode-participar>Quem pode participar?</h3><ul><li>se o competidor j√° participou de duas finais mundiais, ele <strong>n√£o √© eleg√≠vel</strong>;</li><li>se o competidor j√° participou de cinco regionais, ele <strong>n√£o √© eleg√≠vel</strong>;</li><li>se o competidor iniciou seus estudos universit√°rios no ano 2017 ou antes <strong>E</strong> nasceu em 1998 ou antes, ele <strong>n√£o √© eleg√≠vel</strong>;</li><li>aso contr√°rio, o competidor <strong>√© eleg√≠vel</strong>.</li></ul><h3 id=onde-ocorrem-as-provas>Onde ocorrem as provas?</h3><ul><li>Ao decorrer de 2023, a sede do DF ser√° divulgada.</li></ul><h3 id=quando-s√£o-as-provas>Quando s√£o as provas?</h3><ul><li>O calend√°rio tamb√©m √© flutuante, com provas aos s√°bados. Tradicionalmente a etapa Regional ocorre no segundo s√°bado de setembro, a Nacional no segundo s√°bado de novembro e a Mundial em maio do ano seguinte.</li></ul><h2 id=maratonas-regionais>Maratonas regionais</h2><ul><li>Maratona UnB - Todo ano acontece a maratona da UnB</li><li>Maratona UnBalloon</li><li>Maratona de APC</li><li>Maratona do IESB</li><li>Maratona do IFB</li></ul><footer class=footline></footer></article><article class=default dir=ltr><h1>Refer√™ncias</h1><h2 id=plataformas-de-programa√ß√£o-competitiva>Plataformas de Programa√ß√£o Competitiva:</h2><ul><li><a href=https://codeforces.com>https://codeforces.com</a></li><li><a href=https://atcoder.jp>https://atcoder.jp</a></li><li><a href=https://beecrowd.com.br>https://beecrowd.com.br</a> (Antigo URI)</li></ul><h2 id=livrossites-que-a-galera-usa-para-estudar>Livros/sites que a galera usa para estudar:</h2><ul><li>Competitive Programming 3 - Stevem Halim</li><li>CP handbook: <a href=https://cses.fi/book/book.pdf>https://cses.fi/book/book.pdf</a></li><li>CodCad: <a href=https://neps.academy/br/codcad>https://neps.academy/br/codcad</a> (Bom para come√ßar)</li><li>Algoritmos: <a href=https://cp-algorithms.com/>https://cp-algorithms.com/</a></li></ul><h2 id=iniciativas-da-unb>Iniciativas da UnB</h2><ul><li><p><a href=https://unb-cic.github.io/Maratona-Extensao/>https://unb-cic.github.io/Maratona-Extensao/</a> (Aulas do projeto de extens√£o)</p></li><li><p><a href=https://github.com/UnBalloon>https://github.com/UnBalloon</a> (Reposit√≥rio de algoritmos)</p></li><li><p>Telegram: <a href=https://t.me/unballoon>https://t.me/unballoon</a></p></li><li><p>Discord: <a href=https://discord.gg/uc4htcV7fD>https://discord.gg/uc4htcV7fD</a></p></li><li><p>Mat√©rias: Programa√ß√£o competitiva, T√≥picos Especiais em Programa√ß√£o ‚Ä¢ Gama, T√≥picos Especiais em Programa√ß√£o Competitiva ‚Ä¢ Darcy</p></li></ul><h2 id=competi√ß√µes-que-rolam>Competi√ß√µes que rolam</h2><ul><li>OBI <a href=https://olimpiada.ic.unicamp.br/>https://olimpiada.ic.unicamp.br/</a> (Voltada para ensino m√©dio + 1¬∫ ano da faculdade)</li><li>Facebook Hacker Cup <a href=https://web.facebook.com/codingcompetitions/hacker-cup>https://web.facebook.com/codingcompetitions/hacker-cup</a></li><li>Google Code Jam <a href=https://codingcompetitions.withgoogle.com/codejam>https://codingcompetitions.withgoogle.com/codejam</a></li><li>Maratona SBC <a href=http://maratona.sbc.org.br/>http://maratona.sbc.org.br/</a> (√â no mesmo esquema de olimp√≠ada cient√≠fica, tem Regional - Nacional - Mundial)</li><li>Competi√ß√µes DF <a href=https://codeforces.com/group/btcK4I5D5f/blog>https://codeforces.com/group/btcK4I5D5f/blog</a></li></ul><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Materiais</h1><h2 id=conte√∫dos-de-programa√ß√£o-competitiva>Conte√∫dos de Programa√ß√£o Competitiva</h2><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/>Fundamentos do C++</a></li><li><a href=/materiais/ed/>Estruturas de Dados</a></li><li><a href=/materiais/algoritmos/>Algoritmos</a></li><li><a href=/materiais/grafos/>Grafos</a></li><li><a href=/materiais/bitwise/>Bitwise</a></li><li><a href=/materiais/matematica/>Matematica</a></li><li><a href=/materiais/avancados/>T√≥picos Avan√ßados</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Materiais</h1><article class=default dir=ltr><h1>Fundamentos do C++</h1><h2 id=tudo-o-que-voc√™-precisa-saber-sobre-c>Tudo o que voc√™ precisa saber sobre C++</h2><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/complexidade/>Complexidade</a></li><li><a href=/materiais/fundamentos/input-output/>Entrada/Sa√≠da</a></li><li><a href=/materiais/fundamentos/declaracoes/>Declara√ß√µes</a></li><li><a href=/materiais/fundamentos/eds/>Estrutura de Dados</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Fundamentos do C++</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 1</div><h1>Complexidade</h1><h2 id=o-que-√©-complexidade>O que √© Complexidade?</h2><hr><p>Em linhas gerais, a complexidade de tempo de um algoritmo √© o quanto as vari√°veis de entrada impactam no seu tempo de execu√ß√£o.</p><p>Para se referir a complexidade de um algoritmo, se usa a nota√ß√£o Big O, denotada por <code>O(N)</code>. A nota√ß√£o Big O tem o seguinte significado: No pior caso da execu√ß√£o deste algoritmo, o n√∫mero de opera√ß√µes realizado ser√° proporcional a <code>N</code>, e por simplicidade, eliminamos constantes e fatores n√£o dominantes. A quantidade de opera√ß√µes que os computadores atuais executam em um segundo √© por volta de 10^8, portanto podemos estimar o tempo de execu√ß√£o de um programa usando an√°lise de complexidade. Basta fazer o c√°lculo de complexidade e dividir por 10^8, e a resposta ser√° aproximadamente o tempo de execu√ß√£o em segundos. Esse mesmo conceito se extende a mem√≥ria utilizada por um programa, podemos fazer o c√°lculo de complexidade e dividir o resultado por 10^6, e saberemos quantos MegaBytes ser√£o utilizados pelo programa no pior caso.</p><p>Exemplos:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Hello World</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><p>Esse c√≥digo tem complexidade <code>O(1)</code> (tamb√©m chamado de complexidade constante), porque nenhuma vari√°vel de entrada impacta no seu tempo de execu√ß√£o. A complexidade de mem√≥ria tamb√©m √© <code>O(1)</code>.</p><h1 id=loops>Loops</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Esse c√≥digo tem complexidade <code>O(n)</code>, pois o seu tempo tempo de execu√ß√£o cresce linearmente dependendo da vari√°vel <code>n</code>. A mem√≥ria necess√°ria n√£o depende de nenhuma vari√°vel de entrada ent√£o √© <code>O(1)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span><span style=color:#f92672>*</span>n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Esse c√≥digo tamb√©m tem complexidade <code>O(n)</code>, porque eliminamos os fatores constantes para manter a simplicidade. Complexidade de mem√≥ria <code>O(1)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n,m;
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>,<span style=color:#f92672>&amp;</span>n,<span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Muitas vezes, a complexidade depende de mais de uma vari√°vel de entrada. Como n√£o temos nenhuma informa√ß√£o sobre o significado das vari√°veis, a complexidade √© <code>O(n+m)</code>. Se soub√©ssemos por exemplo que m fosse sempre muito maior que m, poder√≠amos dizer <code>O(m)</code>. Mais uma vez a mem√≥ria utilizada n√£o depende de nenhuma vari√°vel de entrada.</p><h2 id=multiplica√ß√£o-de-matrizes>Multiplica√ß√£o de matrizes</h2><hr><p>O c√≥digo abaixo computa C = A * B, onde A √© uma matriz n por p e B √© uma matriz p por m.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> m; j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        C[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> p; k<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            C[i][j] <span style=color:#f92672>+=</span> A[i][k] <span style=color:#f92672>*</span> B[k][j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}	
</span></span></code></pre></div><p>Como os fors est√£o aninhados a complexidade do c√≥digo √© a multiplica√ß√£o das complexidades de cada for, sendo ent√£o, <code>O(n*m*p)</code>. A multiplica√ß√£o produz a matriz C como resultado, que tem dimen√ß√µes <code>n</code> por <code>m</code>, Como √© necess√°rio alocar esse espa√ßo, a complexidade de mem√≥ria √© <code>O(n*m)</code>.</p><h2 id=ordena√ß√£o>Ordena√ß√£o</h2><hr><p>Um problema bastante estudado √© o de ordena√ß√£o. Existem v√°rios algoritmos resolvem o problema eficientemente, n√£o ser√° mostrado um desses. O c√≥digo a seguir ordena um vetor <code>v</code> de tamanho <code>n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&lt;</span> n; j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(v[i] <span style=color:#f92672>&gt;</span> v[j]){
</span></span><span style=display:flex><span>            tmp <span style=color:#f92672>=</span> v[i];
</span></span><span style=display:flex><span>            v[i] <span style=color:#f92672>=</span> v[j];
</span></span><span style=display:flex><span>            v[j] <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A quantidade de vezes que o segundo loop executa depende do i, ent√£o √© um pouco mais dif√≠cil de analisar a complexidade.</p><p>Ao longo das itera√ß√µes do primeiro loop, a quantidade de itera√ß√µes do segundo √© <code>n + (n-1) + (n-2) + (n-3) + ... + 1</code>, ou seja, √© soma de <a href=https://educacao.uol.com.br/disciplinas/matematica/progressao-artimetica-pa-formula-da-soma-e-do-termo-geral.htm>PA</a> e podemos resolver para <code>O((n+1)*n/2)</code>. Em an√°lise de complexidade s√≥ nos importamos com quando as vari√°veis s√£o muito grandes(tendem a infinito), de um modo bem bruto infinito e infinito/2 d√° no mesmo, ent√£o podemos escrever a complexidade como <code>O((n+1)*n)</code>. Novamente quando pensamos em n√∫meros bem altos <code>n</code> e <code>n+1</code> se tornam praticamente a mesma coisa e podemos concluir que a complexidade √© <code>O(n^2)</code>.</p><p>Portanto podemos dizer que a complexidade do c√≥digo acima √© <code>O((n+1)*n/2)</code>, <code>O((n+1)*n)</code> ou <code>O(n^2)</code>. Mas geralmente optamos pela forma mais simples que √© <code>O(n^2)</code>.</p><p>A intui√ß√£o sobre a complexidade de mem√≥ria pode acabar te enganando nesse exemplo. O motivo √© o seguinte: o c√≥digo apenas troca os valores de lugar dentro do vetor, n√£o sendo necess√°rio alocar um novo vetor com a resposta(Ao contr√°rio da multiplica√ß√£o de matrizes), ent√£o a complexidade de mem√≥ria √© <code>O(1)</code>.</p><h1 id=recurs√£o>Recurs√£o</h1><p>Tamb√©m √© poss√≠vel analisar a complexidade de fun√ß√µes recursivas.</p><h2 id=exponencia√ß√£o>Exponencia√ß√£o</h2><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>slow_exp</span>(<span style=color:#66d9ef>int</span> base, <span style=color:#66d9ef>int</span> e){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(e <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> base <span style=color:#f92672>*</span> slow_exp(base,e<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nessa fun√ß√£o, em cada chamada, o expoente decresce em um, atingindo o caso base quando se iguala a 0. Ent√£o s√£o feitas <code>O(n)</code> chamadas. Quando avaliamos complexidade de mem√≥ria de fun√ß√µes recursivas, temos que levar em conta a pilha de execu√ß√£o tamb√©m. S√£o empilhadas n chamadas na pilha, ent√£o a complexidade de mem√≥ria √© <code>O(n)</code>.</p><h2 id=exponencia√ß√£o-r√°pida>Exponencia√ß√£o r√°pida</h2><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fast_exp</span>(<span style=color:#66d9ef>int</span> base, <span style=color:#66d9ef>int</span> e){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(e <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(e <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> base <span style=color:#f92672>*</span> fast_exp(base <span style=color:#f92672>*</span> base,e<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> fast_exp(base <span style=color:#f92672>*</span> base, e<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essa √© uma fun√ß√£o que tamb√©m computa uma exponencia√ß√£o. √â um bom exemplo de como problemas abordados de forma diferente ou usando propriedades matem√°ticas podem ser resolvidos de forma mas eficiente. Em cada chamada na recurs√£o, o expoente √© dividido por 2, atingindo o caso base quando se iguala a 0. √â f√°cil ver que o n√∫mero <code>2^k</code> levaria <code>k</code> chamadas para atingir o caso base, isso ocorre porque <code>log2 (2^k) = k</code>, ent√£o a complexidade √© <code>O(log N)</code>. A complexidade de mem√≥ria √© justificada da mesma forma que no caso anterior, a mem√≥ria utilizada ser√° o n√∫mero de chamadas recursivas, ent√£o, <code>O(log n)</code>.</p><h2 id=fibonacci>Fibonacci</h2><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#66d9ef>int</span> n){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fibonacci(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> fibonacci(n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A famosa fun√ß√£o de fibonacci. Essa fun√ß√£o recursiva √© bem bonita de se ver declarada, mas n√£o √© nada eficiente.</p><p>Pense que queremos Calcular Fibonacci(7)</p><p><img src=/images/fib.png alt=Fibonacci></p><p>Essa a √°rvore formada pelas chamadas recursivas, olhe quantas vezes recomputamos as mesmas coisas. A complexidade dessa fun√ß√£o √© <code>O(2^n)</code>, pois para cada chamada de fibonacci recursiva, fazemos outras duas, e acabamos recomputando v√°rias vezes as mesmas coisas. Implemente essa fun√ß√£o em sua m√°quina e fa√ßa uma chamada de fibonacci(40), j√° deve ser poss√≠vel sentir o tempo que o programa leva para processar isso.</p><p>A complexidade de mem√≥ria dessa fun√ß√£o pode ser um pouco mais complicada de analisar vamos por partes. No total, ser√£o feitos <code>O(2^n)</code> chamadas recursivas, e todas elas precisaram de um espa√ßo na pilha de execu√ß√£o, no entanto, as <code>2^n</code> chamadas n√£o coexistir√£o na pilha de execu√ß√£o. Olhando bem atentamente e seguindo o fluxo das chamadas recursivas, √© poss√≠vel ver que no m√°ximo um &lsquo;ramo&rsquo; da √°rvore estar√° na pilha por vez, o ramo mais longo tem comprimento <code>n</code> portanto, complexidade de mem√≥ria <code>O(n)</code>.</p><h2 id=videoaulas-complementares>VideoAulas Complementares</h2><hr><p><a href="https://www.youtube.com/watch?v=YoZPTyGL2IQ">https://www.youtube.com/watch?v=YoZPTyGL2IQ</a> (12 min.)</p><p><a href="https://www.youtube.com/watch?v=moPtwq_cVH8">https://www.youtube.com/watch?v=moPtwq_cVH8</a> (51 min. MIT)</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 2</div><h1>Entrada/Sa√≠da</h1><h2 id=entrada>Entrada</h2><p>O objeto &ldquo;cin&rdquo; representa o stream de entrada no C++. Ele realiza a leitura de um sequ√™ncia de dados, sem espa√ßos e sem tabula√ß√µes, vindas do teclado.
Para coletar estes dados armazenados, usa-se o &ldquo;operador de extra√ß√£o&rdquo; que &ldquo;extrai&rdquo; dados do stream.</p><h3 id=lendo-um-input>Lendo um Input</h3><p>A primeira linha ter√° N que √© a quantidade de n√∫meros a serem lidos.</p><p>A segunda linha ser√° os N n√∫meros.</p><pre tabindex=0><code>input:
4
1 5 2 3
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    cin<span style=color:#f92672>&gt;&gt;</span>n;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numero;
</span></span><span style=display:flex><span>        cin<span style=color:#f92672>&gt;&gt;</span>numero;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=sa√≠da>Sa√≠da</h2><p>O objeto &ldquo;cout&rdquo; representa o stream de sa√≠da no C++. Este stream √© uma esp√©cie de sequ√™ncia (fluxo) de dados a serem impressos na tela.
Para realizar a impress√£o, usa-se o &ldquo;operador de inser√ß√£o&rdquo; que &ldquo;insere&rdquo; dados dentro do stream.</p><p>Printando o famoso &ldquo;Hello World&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Hello World&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informa√ß√£o</div><div class=box-content><p>O &ldquo;endl&rdquo; √© usado para fazer quebra de linha, por√©m, pode ser mais lento que o &ldquo;\n&rdquo;.</p></div></div><h3 id=casas-decimais>Casas Decimais</h3><p>Para printar as casas decimais, precisamos usar o &ldquo;fixed&rdquo; que √© uma fun√ß√£o do C++ usada para formatar a sa√≠da, juntamente com o &ldquo;setprecision&rdquo;, que diz quantas casas ser√° printada.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> pi <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.141592653</span>;
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>fixed;
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>setprecision(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>pi<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3.1415
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=fast-cin>Fast Cin</h2><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informa√ß√£o</div><div class=box-content><p>O <strong>printf</strong> e o <strong>scanf</strong> do C s√£o mais r√°pidos do que o <strong>cin</strong> e o <strong>cout</strong> do C++.</p></div></div><p>Isso ocorre porque o C++ usa a sincroniza√ß√£o do output, ou seja, enquanto ele est√° lendo o input, o programa pode responder ao mesmo tempo.</p><p>A resolu√ß√£o para que o cin e o cout fique mais r√°pido (pr√≥ximo √† velocidade do scanf e do printf), √© desabilitar a sincroniza√ß√£o no C++.</p><p>Segue o exemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ios_base<span style=color:#f92672>::</span>sync_with_stdio(false);
</span></span><span style=display:flex><span>cin.tie(NULL);
</span></span></code></pre></div><h2 id=exemplo>Exemplo</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    ios_base<span style=color:#f92672>::</span>sync_with_stdio(false);
</span></span><span style=display:flex><span>    cin.tie(NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=default dir=ltr><h1>Declara√ß√µes</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/declaracoes/string/>Strings</a></li><li><a href=/materiais/fundamentos/declaracoes/vector/>Vector</a></li><li><a href=/materiais/fundamentos/declaracoes/pair/>Pairs</a></li><li><a href=/materiais/fundamentos/declaracoes/iterators/>Iterators</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Declara√ß√µes</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 3</div><h1>Strings</h1><p>No C++ representa uma sequ√™ncia de caracteres</p><p>Podemos declarar uma string como:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>string nomevar;
</span></span><span style=display:flex><span>string nomevar <span style=color:#f92672>=</span> constante;
</span></span><span style=display:flex><span>string nomevar <span style=color:#f92672>=</span> <span style=color:#66d9ef>char</span> <span style=color:#960050;background-color:#1e0010>‚àó</span> variavel;
</span></span><span style=display:flex><span>string <span style=color:#a6e22e>nomevar</span>(<span style=color:#66d9ef>char</span> <span style=color:#960050;background-color:#1e0010>‚àó</span> variavel);
</span></span><span style=display:flex><span>string <span style=color:#a6e22e>nomevar</span>(tamanho, constante <span style=color:#66d9ef>char</span>);
</span></span></code></pre></div><h2 id=concatena√ß√£o>Concatena√ß√£o</h2><p>Podemos usar o operador &ldquo;+&rdquo; para concatenar duas strings</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    string a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abc&#34;</span>;
</span></span><span style=display:flex><span>    string b <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;def&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    string c <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>c<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// abcdef
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=transformando-um-inteiro-em-string>Transformando um inteiro em string</h2><p>Podemos transformar um inteiro em uma string usando a fun√ß√£o &ldquo;to_string()&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>;
</span></span><span style=display:flex><span>    string s <span style=color:#f92672>=</span> to_string(x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>s<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 4</div><h1>Vector</h1><p><strong>Vector</strong> pode ser entendido como uma estruturas de dados
similar a um <strong>array</strong> de tamanho expans√≠vel.</p><p>A diferen√ßa principal entre vector e array √© a aloca√ß√£o:
no array adota-se aloca√ß√£o est√°tica, enquanto que no
vector a aloca√ß√£ao √© din√¢mica.</p><h2 id=inicializar>Inicializar</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// inicializando vetores vazios
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> vd;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;&gt;</span> vid;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> vs;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// vector&lt;int&gt; v(tamanho, valor)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// {0, 0, 0, 0} vetor de 4 posi√ß√µes com valor 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(<span style=color:#ae81ff>4</span>); <span style=color:#75715e>// {0, 0, 0, 0} por default, inicializa como 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    v.push_back(<span style=color:#ae81ff>5</span>); <span style=color:#75715e>// Adiciona o elemento 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {0, 0, 0, 0, 5}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    v.pop_back();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {0, 0, 0, 0}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=iterar>Iterar</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printa um elemento em cada linha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>v.size(); i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> v[i] <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informa√ß√£o</div><div class=box-content><p>O m√©todo size() retorna a quantidade de elementos
existentes em um vector.
Complexidade: O(1)</p></div></div><h2 id=ordenar>Ordenar</h2><div class="box notices cstyle secondary"><div class=box-label><i class="fa-fw fas fa-stopwatch"></i> Complexidade</div><div class=box-content><p><em>O(N*log(N))</em></p></div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sort(v.begin(), v.end()); <span style=color:#75715e>// ordena o vetor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {1, 2, 3, 4, 5}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=inverter>Inverter</h2><div class="box notices cstyle secondary"><div class=box-label><i class="fa-fw fas fa-stopwatch"></i> Complexidade</div><div class=box-content><p><em>O(N)</em></p></div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    reverse(v.begin(), v.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {5, 4, 3, 2, 1}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=vector-de-pair>Vector de Pair</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> v <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}, {<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}, {<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v[0].first = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// v[0].second = 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 5</div><h1>Pairs</h1><p>O pair √© muito importante quando precisamos guardar duas informa√ß√µes juntas.</p><ul><li><p>Um &ldquo;pair&rdquo; √© um cont√™iner que consiste de dois tipos de dados ou objetos.</p></li><li><p>Declaramos um pair como:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span>tipodado1, tipodado2<span style=color:#f92672>&gt;</span> variavel;
</span></span></code></pre></div><p>Podemos inicializ√°-lo usando o make_pair ou diretamente:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>variavel <span style=color:#f92672>=</span> make_pair(dado1, dado2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>variavel <span style=color:#f92672>=</span> {dado1, dado2};
</span></span></code></pre></div><ul><li>O primeiro elemento √© acessado usando o &ldquo;first&rdquo; e o segundo usando &ldquo;second&rdquo;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>variavel.first;
</span></span><span style=display:flex><span>variavel.second;
</span></span></code></pre></div><h2 id=exemplo-1>Exemplo 1:</h2><ul><li>Um Pair que armazena 2 inteiros</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pii;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pii <span style=color:#f92672>=</span> {<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>10</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> pii.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pii.second<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=exemplo-2>Exemplo 2:</h2><ul><li>Um Pair que armazena 1 inteiro e 1 double</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> pii;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pii <span style=color:#f92672>=</span> {<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1.5365</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> pii.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pii.second<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2 1.5365
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=comparando-vari√°veis>Comparando Vari√°veis:</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1, v2;
</span></span><span style=display:flex><span>    v1 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    v2 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(v1 <span style=color:#f92672>&gt;</span> v2) cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;v1 √© maior que v2&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;v1 √© menor ou igual a v2&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 6</div><h1>Iterators</h1><p>Iterators s√£o tipos espec√≠ficos de ponteiros que referenciam
endere√ßoos de mem√≥ria de objetos e cont√™iners STL.</p><h2 id=exemplo-1>Exemplo 1</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator ptr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Elementos do Vetor&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(ptr <span style=color:#f92672>=</span> v.begin(); ptr <span style=color:#f92672>!=</span> v.end(); ptr<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>(<span style=color:#f92672>*</span>ptr)<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Dica</div><div class=box-content><p>Voc√™ pode usar o <strong>auto</strong> no lugar de <code>vector&lt;int>::iterator</code>, para facilitar</p></div></div><h2 id=exemplo-2>Exemplo 2</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ar <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Declaring iterators to a vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator ptr <span style=color:#f92672>=</span> ar.begin();
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator ftr <span style=color:#f92672>=</span> ar.end();
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Using next() to return new iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// points to 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> next(ptr, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Using prev() to return new iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// points to 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> it1 <span style=color:#f92672>=</span> prev(ftr, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Displaying iterator position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;The position of new iterator using next() is : &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>it <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Displaying iterator position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;The position of new iterator using prev()  is : &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>it1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The position of new iterator using next() is : 4 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// The position of new iterator using prev()  is : 3 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Estrutura de Dados</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/eds/ed_linear/>ED Linear</a></li><li><a href=/materiais/fundamentos/eds/ed_n_linear/>ED N√£o Linear</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Estrutura de Dados</h1><article class=default dir=ltr><h1>ED Linear</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/eds/ed_linear/pilha/>Pilha</a></li><li><a href=/materiais/fundamentos/eds/ed_linear/fila/>Fila</a></li><li><a href=/materiais/fundamentos/eds/ed_linear/fila_prioridade/>Fila de Prioridade</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de ED Linear</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 7</div><h1>Pilha</h1><p>A <strong>pilha</strong> √© uma estrutura que, como o nome sugere, permite inser√ß√£o e remo√ß√£o apenas do &ldquo;topo&rdquo;. Isto significa que, ao remover um elemento da pilha, o elemento a ser removido √© o √∫ltimo que foi inserido. Tamb√©m √© conhecido como <em><strong>LIFO (last-in first-out)</strong></em>.</p><p><img src=/images/pilha.png alt=Pilha></p><h2 id=m√©todos>M√©todos:</h2><ul><li><code>push</code> - Insere um elemento na pilha.</li><li><code>pop</code> - Remove o elemento do topo da pilha.</li><li><code>top</code> - Retorna o elemento do topo da pilha.</li><li><code>size</code> - Retorna o tamanho da pilha.</li><li><code>empty</code> - Retorna true se estiver vazia, se n√£o, retorna falso.</li></ul><h2 id=exemplo>Exemplo</h2><ul><li>Programa simples que vai inserir elementos na pilha e depois conforme for removendo, printa cada elemento</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pilha; <span style=color:#75715e>// construtor, entre &lt;&gt; deve ser inserido o tipo de dado que ser√° armazenado
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pilha.push(<span style=color:#ae81ff>2</span>); <span style=color:#75715e>// o metodo push insere o elemento no topo da pilha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pilha.push(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>    pilha.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    pilha.push(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> pilha.size() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// tamanho da pilha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// enquanto n√£o estiver vazia, remove o elemento do topo e printa ele
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>pilha.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> pilha.top();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pilha.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sa√≠da</p><pre tabindex=0><code>4 8 7 2
</code></pre><h1 id=pilha-de-m√≠nimo>Pilha de M√≠nimo</h1><p>E se quisermos o seguinte problema:</p><ul><li>Dado N n√∫meros em uma pilha, para os √∫ltimos Q n√∫meros na pilha, printe o menor n√∫mero em toda pilha at√© ent√£o.</li></ul><p>Podemos fazer um c√≥digo que para cada Q √∫ltimos n√∫meros na pilha, podemos ir percorrendo toda a pilha restante, salvando os menores, sem alterar a pilha atual.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st_aux;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// para os 4 √∫ltimos n√∫meros, printe o menor n√∫mero de toda a pilha at√© ele
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> q<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; q<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>; q<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// menor = infinito
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> menor <span style=color:#f92672>=</span> LLINF;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// empilha na stack auxiliar
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>st.empty()){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> st.top();
</span></span><span style=display:flex><span>            menor <span style=color:#f92672>=</span> min(x, menor);
</span></span><span style=display:flex><span>            st.pop();
</span></span><span style=display:flex><span>            st_aux.push(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>menor<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// desempilha na stack original
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>st_aux.empty()){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> st_aux.top();
</span></span><span style=display:flex><span>            st_aux.pop();
</span></span><span style=display:flex><span>            st.push(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>st.empty()){
</span></span><span style=display:flex><span>          st.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Por√©m, √© claro, a complexidade do c√≥digo n√£o √© boa. ficaria aproximadamente <em>O(Q*N)</em>, se o Q e o N forem grandes, certamente levar√≠amos TLE (Time Limit Exceeded).</p><p><em><em>A solu√ß√£o para esse problema ent√£o, ser√≠amos usar a pilha de m√≠nimo.</em></em></p><h2 id=como-funciona>Como funciona?</h2><p>A pilha de m√≠nimo usa um valor auxiliar para armazenar o menor elemento at√© a inser√ß√£o atual, podemos usar um <code>stack&lt;pair&lt;int,int>></code> ou duas <code>stack&lt;int></code>.</p><p>O algoritmo ent√£o inicia a inser√ß√£o de N elementos, e para cada inser√ß√£o de elemento, vamos verificar se o elemento da stack auxiliar √© menor ou maior que o da original, e guardaremos o de menor valor na stack auxiliar.</p><p><img src=/images/min-stack.gif alt=Pilha-Min></p><h2 id=implementa√ß√£o>Implementa√ß√£o</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n; cin<span style=color:#f92672>&gt;&gt;</span>n;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// recebemos n n√∫meros
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> num;
</span></span><span style=display:flex><span>      cin<span style=color:#f92672>&gt;&gt;</span>num;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(st.empty()){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// num sera o menor valor da pilha.second
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        st.push({num,num});
</span></span><span style=display:flex><span>      }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        <span style=color:#75715e>// armazenamos o menor valor entre 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// o que esta na pilha.second e o num atual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> menor <span style=color:#f92672>=</span> st.top().second;
</span></span><span style=display:flex><span>        menor <span style=color:#f92672>=</span> min(menor, num);
</span></span><span style=display:flex><span>        st.push({num, menor});
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Para Q consultas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> q; cin<span style=color:#f92672>&gt;&gt;</span>q;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>st.empty()){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pega o menor valor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> st.top().second;
</span></span><span style=display:flex><span>        st.pop();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>val<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>E a complexidade fica somente O(N+Q), pois agora conseguimos responder em O(1) cada query.</p><p>Refer√™ncias:</p><ul><li><p><a href="https://youtu.be/lFghsipaZhc?t=4593">https://youtu.be/lFghsipaZhc?t=4593</a> (Aula muito boa)</p></li><li><p><a href=https://cp-algorithms.com/data_structures/stack_queue_modification.html>https://cp-algorithms.com/data_structures/stack_queue_modification.html</a></p></li></ul><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 8</div><h1>Fila</h1><p>A <strong>fila</strong> segue o padr√£o de <em><strong>FIFO (first-in first-out)</strong></em>, ao contr√°rio da pilha, o primeiro elemento inserido ser√° o primeiro a ser removido. Ela √© muito √∫til para problemas que precisamos manter os elementos na ordem em que lhes foram dados.</p><p><img src=/images/fila.png alt=Fila></p><h2 id=m√©todos>M√©todos</h2><ul><li><code>push</code> - Adiciona um elemento no fim da fila.</li><li><code>front</code> - Retorna o elemento do in√≠cio da fila.</li><li><code>back</code> - Retorna o elemento do final da fila.</li><li><code>pop</code> - Remove o elemento do in√≠cio da fila.</li><li><code>empty</code> - Retorna true se estiver vazia, e false caso contr√°rio.</li><li><code>size</code> - Retorna quantos elementos tem na fila.</li></ul><h2 id=exemplo>Exemplo</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> q.size() <span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sa√≠da</p><pre tabindex=0><code>9 5 6 1 8
</code></pre><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 9</div><h1>Fila de Prioridade</h1><p>Uma <strong>fila de prioridade</strong> tem como principal caracter√≠stica a <em>ordena√ß√£o</em>, ela mant√©m o elemento do topo como sempre sendo o maior (ou o menor) elemento sempre.</p><p>Caso esteja fixado para o elemento do topo ser o maior, a fila de prioridade estar√° em ordem descrescente do topo para baixo. Caso contr√°rio, a ordem ser√° crescente.</p><p>Por padr√£o, ela estar√° fixado para o elemento do topo ser o maior, logo, estar√° em ordem decrescente os elementos na fila de prioridade.</p><p>As filas de prioridades s√£o muito √∫teis quando precisamos que nossos elementos sempre estejam ordenados conforme vamos inserindo elementos.</p><h2 id=m√©todos>M√©todos</h2><ul><li><code>push</code> - Adiciona um elemento na fila de prioridade.</li><li><code>pop</code> - Remove o elemento do topo da fila de prioridade.</li><li><code>top</code> - Retorna o valor do topo</li><li><code>empty</code> - Retorna true se a fila estiver vazia, caso contr√°rio, retorna false</li><li><code>size</code> - Retorna o tamanho da fila de prioridade.</li></ul><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informa√ß√£o</div><div class=box-content><p>A complexidade de inser√ß√£o e remo√ß√£o √© O(log(n)), e a de olhar o topo do heap √© O(1).</p></div></div><h2 id=exemplo>Exemplo</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> q.size() <span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> q.top();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sa√≠da</p><pre tabindex=0><code>9 8 6 5 1
</code></pre><h2 id=ordena√ß√£o-pelo-menor-valor>Ordena√ß√£o pelo menor valor</h2><p>Para ordenar pelo menor valor usamos a seguinte sintaxe na declara√ß√£o:
<code>priority_queue &lt;int, vector&lt;int>, greater&lt;int>> q</code></p><h2 id=exemplo-2>Exemplo 2</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    priority_queue <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> q.size() <span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> q.top();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sa√≠da</p><pre tabindex=0><code>1 5 6 8 9
</code></pre><footer class=footline></footer></article></section><article class=default dir=ltr><h1>ED N√£o Linear</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/eds/ed_n_linear/map/>Map</a></li><li><a href=/materiais/fundamentos/eds/ed_n_linear/set/>Set</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de ED N√£o Linear</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 10</div><h1>Map</h1><p>O <strong>map</strong> √© uma estrutura interessante pois permite <em>&ldquo;mapear&rdquo;</em> chaves √† valores, e dado uma chave encontrar o seu valor rapidamente (complexidade depende da implementa√ß√£o). Por exemplo, podemos fazer um map com strings de chave e int de valor, sendo poss√≠vel recuperar o valor inteiro associado a aquela string rapidamente.</p><p>Deve-se ter cuidado com o uso de map pois ele √© implementado em c++ como um set de pairs, isto √©, vai ter complexidade <em>O(log n)</em> para inserir e modificar dados.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informa√ß√£o</div><div class=box-content><p>Existe tamb√©m o <strong>unordered_map</strong>, que √© uma estrutura que usa hash. No pior caso √© linear, mas em m√©dia tem complexidade constante. O seu funcionamento √© similar ao do map, com a diferen√ßa de que seus elementos n√£o est√£o ordenados.</p></div></div><h2 id=m√©todos>M√©todos</h2><ul><li><code>insert({key, element})</code> - Insere uma chave e um valor no map</li><li><code>erase()</code> - Remove uma key ou um iterator</li><li><code>find(element)</code> - Retorna um iterator da posi√ß√£o do element</li><li><code>count</code> - Retorna a quantidade de elementos de uma chave espec√≠fica</li><li><code>size</code> - Retorna o tamanho do map</li><li><code>clear</code> - Limpa todo o conte√∫do do Map</li><li><code>begin</code> - Retorna um iterator para o in√≠cio do map</li><li><code>end</code> - Retorna um iterator para o final do map</li></ul><h2 id=inicializa√ß√£o>Inicializa√ß√£o</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// map chave, valor de inteiros
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m; <span style=color:#75715e>// Inicializa√ß√£o de map vazio
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}}; <span style=color:#75715e>// Inicializa√ß√£o de map com valor 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    m[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    m[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>++</span>; <span style=color:#75715e>// 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=itera√ß√£o>Itera√ß√£o</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iterando por m√©todos iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Printa a chave e o valor em cada linha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> m.begin(); it <span style=color:#f92672>!=</span> m.end(); it<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> it.first <span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>&lt;&lt;</span> it.second<span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// tambem pode ser escrito como:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it: m){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> it.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>&lt;&lt;</span> it.second<span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sa√≠da</p><pre tabindex=0><code>2 3
4 6
</code></pre><h2 id=apagando-elemento>Apagando elemento</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iterando por m√©todos iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    m.erase(m.find(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    m.erase(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informa√ß√£o</div><div class=box-content><p>Da primeira maneira, ele apaga em tempo constante, pois est√° passando um iterator.
Da segunda maneira, ele apaga em log(N), pois ele faz uma busca no elemento.</p></div></div><h2 id=verificar-um-elemento>Verificar um elemento</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iterando por m√©todos iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>( m.count(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> ){ <span style=color:#75715e>// existe uma chave {2}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Elemento existe&#34;</span>;
</span></span><span style=display:flex><span>    }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Elemento n√£o existe&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sa√≠da</p><pre tabindex=0><code>Elemento existe
</code></pre><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 11</div><h1>Set</h1><p>A estrutura <strong>set</strong> √© bem parecida com o que conhecemos de conjuntos da matem√°tica; n√£o existem elementos repetidos e a ordem n√£o importa.</p><p>A implementa√ß√£o do set, por√©m, √© feita com uma √°rvore bin√°ria de busca, sendo assim permitido inserir, remover e acessar um elemento em <em>O(log n)</em>.</p><p>A vantagem do set em rela√ß√£o ao vector √© que, caso queira inserir um elemento em um vector ordenado e preservar a ordena√ß√£o, voc√™ ter√° que procurar o lugar que ele deve ser inserido, fazer a inser√ß√£o e modificar a posi√ß√£o dos elementos √† direita dele. Modificar todas as posi√ß√µes √† direita tem uma complexidade ruim <em>O(n)</em>, ent√£o este algoritmo ser√° mais eficiente com o set.</p><p>Al√©m da vantagem de efici√™ncia, essas opera√ß√µes com set s√£o feitas com alguns simples m√©todos!</p><h2 id=m√©todos>M√©todos</h2><ul><li><code>insert(element)</code> - Insere um elemento no Set</li><li><code>erase()</code> - Remove uma key ou um iterator</li><li><code>find(element)</code> - Retorna um iterator da posi√ß√£o do element</li><li><code>count</code> - Retorna a quantidade de elementos de uma chave espec√≠fica</li><li><code>size</code> - Retorna o tamanho do set</li><li><code>clear</code> - Limpa todo o conte√∫do do set</li><li><code>begin</code> - Retorna um iterator para o in√≠cio do set</li><li><code>end</code> - Retorna um iterator para o final do set</li><li><code>lower_bound(element)</code> - Retorna um iterator para o primeiro valor >= element</li><li><code>upper_bound(element)</code> - Retorna um iterator para o primeiro valor > element</li></ul><h2 id=exemplo-1>Exemplo 1</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// insere elemento no set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> s.size() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// tamanho do set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// para verificar se um elemento est√° contido no set ou nao podemos utilizar
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// o metodo find; caso nao esteja presente ele retornar√° o iterator para
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// o fim do set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(s.find(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 2 nao esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 2 esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(s.find(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 nao esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    s.erase(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// apaga elemento 3 do set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(s.find(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 nao esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Outro m√©todo extremamente √∫til √© o lower_bound (e o upper_bound). O lower_bound recebe um inteiro x como argumento e retorna o menor inteiro maior ou igual a x. Caso n√£o exista, ele retorna um iterator para o fim do set (set.end()).</p><h2 id=exemplo-2>Exemplo 2</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// insere elemento no set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s.insert(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> iterator1 <span style=color:#f92672>=</span> s.lower_bound(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// se iterator eh igual a s.end() entao nao existe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(iterator1 <span style=color:#f92672>!=</span> s.end()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numero <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>iterator1;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;menor inteiro maior ou igual a 6 eh &#34;</span> <span style=color:#f92672>&lt;&lt;</span> numero <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;nao existe inteiro numero maior ou igual a 6&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> iterator2 <span style=color:#f92672>=</span> s.lower_bound(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// se iterator eh igual a s.end() entao nao existe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(iterator2 <span style=color:#f92672>!=</span> s.end()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numero <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>iterator2;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;menor inteiro maior ou igual a 9 eh &#34;</span> <span style=color:#f92672>&lt;&lt;</span> numero <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;nao existe inteiro numero maior ou igual a 9&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informa√ß√£o</div><div class=box-content><p>Na verdade, voc√™ pode utilizar o lower_bound para qualquer tipo que implemente a opera√ß√£o &ldquo;&lt;&rdquo;, como por exemplo o pair&lt;int, int>.</p></div></div><footer class=footline></footer></article></section></section></section><article class=default dir=ltr><h1>Estruturas de Dados</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Estruturas de Dados</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 12</div><h1>Delta Encoding</h1><h2 id=problemas-de-atualiza√ß√£o-em-intervalos>Problemas de atualiza√ß√£o em intervalos</h2><p>Suponha que voc√™ se depare com um problema do seguinte tipo:</p><p>Voc√™ recebe um vetor <code>v</code> , inicialmente com todos seus n√∫meros zerados, e <code>q</code> queries. cada query vir√° representada por 3 inteiros (l,r,x). Ao receber cada query, a mudan√ßa esperada √©: &ldquo;Para cada n√∫mero no vetor, seja <code>i</code> o seu √≠ndice. Se <code>l &lt;= i &lt;= r</code>, v[i] deve ter x adicionado ao seu valor. Ao final do programa, deve-se imprimir o vetor todo com seus valores atualizados.</p><p>A primeira solu√ß√£o que j√° vem a cabe√ßa √© a seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n,q;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>,<span style=color:#f92672>&amp;</span>n,<span style=color:#f92672>&amp;</span>q);
</span></span><span style=display:flex><span>vi <span style=color:#a6e22e>v</span>(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; <span style=color:#f92672>++</span>i){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l,r,x;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r,<span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> l; j <span style=color:#f92672>&lt;=</span> r; <span style=color:#f92672>++</span>j){
</span></span><span style=display:flex><span>        v[j] <span style=color:#f92672>+=</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nessa solu√ß√£o, para cada uma das <code>q</code> queries, o pior caso seria <code>l = 0</code> e <code>r = n-1</code>, que faz o la√ßo interno iterar <code>n</code> vezes, o que nos d√° uma complexidade <code>O(n*q)</code>. Precisamos ser mais r√°pidos.</p><h2 id=defini√ß√£o>Defini√ß√£o</h2><p>Delta encoding √© uma t√©cnica para resolver problemas desse tipo. Precisamos fazer atualiza√ß√µes em intervalos, mas como o vetor s√≥ precisa ser visualizado no final, o que fazemos √© fazer todas de uma vez s√≥ no final. A ideia por tr√°s dessa solu√ß√£o funciona da seguinte forma: Vamos criar um vetor auxiliar <code>delta</code>, que √© o vetor que vai acumular as atualiza√ß√µes.</p><h2 id=atualiza√ß√£o-do-intervalo-lr>Atualiza√ß√£o do intervalo (l,r)</h2><p>Dessa forma, quando estivermos lendo uma query (l,r,x), faremos o seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> delta(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l,r,x;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r,<span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>    delta[l] <span style=color:#f92672>+=</span> x;
</span></span><span style=display:flex><span>    delta[r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-=</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O trecho de c√≥digo acima √© o delta encoding por si s√≥, o nome √© esse porque estamos codificando a informa√ß√£o de que precisamos atualizar aquele intervalo. A parte interessante, √© que nesse la√ßo, nossa atualiza√ß√£o funciona em <code>O(1)</code>.</p><h2 id=obtendo-os-valores-ap√≥s-v√°rias-atualiza√ß√µes>Obtendo os valores ap√≥s v√°rias atualiza√ß√µes</h2><p>Tendo as informa√ß√µes organizadas dessa forma, isso nos permite percorrer o vetor <code>delta</code> da esquerda pra direita obtendo os valores finais do vetor, em <code>O(n)</code>.</p><p>Isso √© feito criando uma vari√°vel <code>atual</code>, inicializada com 0. Ent√£o, enquanto percorremos o vetor, na i-√©sima itera√ß√£o, sempre somamos a essa vari√°vel <code>delta[i]</code>, ap√≥s isso, a configura√ß√£o final de <code>v[i]</code> ser√° o valor de <code>atual</code>.</p><p>Ent√£o, √© por esse motivo que guardamos a informa√ß√£o daquela forma no vetor. Como vamos percorrer da esquerda pra direita, quando fazemos <code>v[l] += x</code>, estamos dizendo, quando voc√™ passar no √≠ndice <code>l</code>, voc√™ deve adicionar mais <code>x</code> a resposta. E quando fazemos <code>v[r+1] -= x</code>, dizemos: quando seu √≠ndice for maior que <code>r</code>, pare de considerar x no resultado.</p><p>Dessa forma, a vers√£o final:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> delta(n<span style=color:#f92672>+</span><span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l,r,x;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r,<span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>    delta[l] <span style=color:#f92672>+=</span> x;
</span></span><span style=display:flex><span>    delta[r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-=</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> atual <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    atual <span style=color:#f92672>+=</span> delta[i];
</span></span><span style=display:flex><span>    v[i] <span style=color:#f92672>=</span> atual;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d &#34;</span>,v[i]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><h2 id=ressalvas>Ressalvas</h2><p>An√°logo as somas prefixas, mas de forma inversa, essa ED processa atualiza√ß√µes em intervalo muito rapidamente <code>O(1)</code>, por√©m, quando √© necess√°rio saber os valores do vetor, e h√° atualiza√ß√µes pendentes, √© necess√°rio percorrer novamente o vetor todo <code>O(n)</code>, ent√£o essa ED funciona melhor com muitas atualiza√ß√µes e poucas consultas.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 13</div><h1>Soma de Prefixos</h1><h2 id=problemas-de-consulta-em-intervalos>Problemas de consulta em intervalos</h2><p>Suponha que voc√™ se depare com o seguinte problema:</p><p>√â dado um vetor V, com n n√∫meros inteiros, em seguida, um n√∫mero q de consultas que ser√£o feitas nesse vetor. Cada consulta consiste de um par de inteiros (l,r), representando um intervalo, a resposta para cada consulta √© a soma dos inteiros nesse intervalo(inclusivo).</p><p>At√© agora, em qual complexidade sabemos resolver esse problema?</p><p>A solu√ß√£o simples seria:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> q;
</span></span><span style=display:flex><span>cin <span style=color:#f92672>&gt;&gt;</span> n;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(n);
</span></span><span style=display:flex><span><span style=color:#75715e>// leitura dos elementos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,v<span style=color:#f92672>+</span>i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>cin <span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span><span style=color:#75715e>// respondendo as consultas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l, r;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> soma <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> l; j <span style=color:#f92672>&lt;=</span> r; j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        soma <span style=color:#f92672>+=</span> v[j];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> soma <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essa solu√ß√£o teria complexidade <code>O(q*n)</code> aonde <code>q</code> √© o n√∫mero de consultas, e <code>n</code> o tamanho do vetor.</p><h2 id=defini√ß√£o>Defini√ß√£o</h2><p>O vetor de somas prefixas √© uma ED que podemos usar para resolver esse tipo de problema de forma mais eficiente. A ideia √© construir um vetor P tal que <code>P[i]</code> representa a soma do √≠ndice 0 at√© o √≠ndice i.</p><p>Tendo essas informa√ß√µes, para responder uma consulta (l,r) podemos usar a seguinte ideia: sabe-se que em <code>P[r]</code> temos a resposta para a consulta (0,r), com isso, podemos agora subtrair a parte que n√£o nos interessa, (0,l-1) ou <code>P[l-1]</code>.</p><h2 id=constru√ß√£o>Constru√ß√£o</h2><p>A constru√ß√£o do vetor de somas prefixas em <code>v</code> tem complexidade <code>O(n)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> psum(v.size(), v[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> v.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    psum[i] <span style=color:#f92672>=</span> v[i] <span style=color:#f92672>+</span> psum[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=resposta-de-consulta-lr>Resposta de consulta (l,r)</h2><p>A resposta √†s consultas tem complexidade constante, j√° que s√£o s√≥ acessos ao vetor. Apenas tem-se que tomar cuidado quando <code>l = 0</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(l <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> psum[r];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> psum[r] <span style=color:#f92672>-</span> psum[l<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ressalvas>Ressalvas</h2><p>Vale lembrar que essa ED √© mais interessante de ser usada quando n√£o h√° (ou h√° poucas) atualiza√ß√µes nos valores do vetor, caso haja, √© necess√°rio recomputar as somas prefixas do vetor todo em <code>O(n)</code>, o que n√£o √© uma complexidade atrativa.</p><p>Al√©m disso, esse racioc√≠nio n√£o precisa se extender apenas a somas, funciona para opera√ß√µes como xor, por exemplo.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 14</div><h1>Segment Trees</h1><p>Segment tree (Segtree) √© outra estrutura de dados para lidar com problemas de consulta em intervalos. O que tornas as segtrees poderosas √© sua capacidade de fazer atualiza√ß√£o e consulta em intervalos em complexidade <code>O(log n)</code>, al√©m do tipo da consulta ser bem abrangente.</p><p>A ideia √© a seguinte: Criamos uma √°rvore, de forma que cada nodo representa a informa√ß√£o que desejamos saber a respeito de um segmento do vetor, e tem dois filhos, um filho representa a metade esquerda desse intervalo, e o outro, a metade direita. Esse processo recursa at√© que os intervalos atinjam tamanho 1.</p><p>Aqui h√° uma demonsta√ß√£o visual de como funciona: <a href=https://visualgo.net/en/segmenttree>https://visualgo.net/en/segmenttree</a></p><p>√â interessante entender o funcionamento da segtree pois, por mais que tenhamos o c√≥digo pronto, quando mudamos de opera√ß√£o ou precisamos inserir long longs, ser√° necess√°rio mexer na sua estrutura interna.</p><h2 id=representa√ß√£o>Representa√ß√£o</h2><p>Nossa segtree ser√° representada como um vetor. Cada nodo ter√° um id nesse vetor, e o conte√∫do dessa posi√ß√£o representa a informa√ß√£o que aquele nodo guarda. A raiz da segtree ser√° o nodo 0, que guarda a informa√ß√£o sobre o vetor todo. A partir do √≠ndice <code>id</code> de um nodo, podemos obter os filhos sem colis√µes da seguinte forma: √≠ndice dos filhos esquerdo e direito s√£o <code>(id*2 + 1,id*2 +2)</code>, respectivamente.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span></code></pre></div><h2 id=opera√ß√£o>Opera√ß√£o</h2><p>Essa fun√ß√£o define que informa√ß√£o queremos saber a respeito dos elementos do vetor. Nese caso √© uma segtree que computa o m√°ximo de intervalos, mas poderia ser soma, m√≠nimo, produto, xor, gcd, mmc(lcm), or e and l√≥gicos etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(a,b);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=elemento-neutro>Elemento neutro</h2><p>O elemento neutro depende da opera√ß√£o. Como queremos saber os m√°ximos, o elemento neutro dessa opera√ß√£o seria um n√∫mero muito baixo, que nunca ser√° o m√°ximo.</p><p>Caso n√£o saiba a defini√ß√£o de elemento neutro, a defini√ß√£o √© a seguinte: <code>e</code> √© um elemento neutro da opera√ß√£o f se <code>f(e,x) = x</code> para todo <code>x</code>.</p><p>Caso fosse uma soma, nosso elemento neutro seria 0, caso fosse um produto, seria 1, etc..</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>(<span style=color:#ae81ff>1e9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span></code></pre></div><h2 id=consulta>Consulta</h2><p>A fun√ß√£o recursiva abaixo responde √†s consultas na segtree. Cada par√¢metro tem o seguinte significado:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>l</code> : limite inferior do intervalo que queremos fazer a consulta</li><li><code>r</code> : limite superior do intervalo que queremos fazer a consulta</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//O nodo est√° fora do intervalo que estamos interessados, retorne o elemento neutro que n√£o afeta a consulta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl) 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// O nodo est√° completamente inclu√≠do no intervalos que estamos interessados, retorne a informa√ß√£o contida naquele nodo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Se chegarmos aqui, √© porque esse Nodo est√° parcialmente contido no intervalo que estamos interessados. Ent√£o, continuamos procurando nos filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=atualiza√ß√£o>Atualiza√ß√£o</h2><p>Essa fun√ß√£o atualiza um elemento da segtree. Cada par√¢metro tem o seguinte significado:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>i</code> : √≠ndice do <strong>vetor</strong> que queremos atualizar</li><li><code>amm</code>: novo valor daquele √≠ndice no vetor</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Chegamos no √≠ndice que queremos, vamos atualizar o valor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>==</span> i and str <span style=color:#f92672>==</span> i){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// O intervalo que estamos n√£o contem o √≠ndice que queremos atualizar, retorne
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> i or str <span style=color:#f92672>&lt;</span> i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// O intervalo cont√©m o √≠ndice, mas temos que chegar no nodo espec√≠fico, recurse para os filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,i,amm);
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,i,amm);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Ap√≥s os filhos mais em baixo, precisamos atualizar o valor desse nodo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=declara√ß√£o>Declara√ß√£o</h2><p>Essa √© a classe com as funcionalidades implementadas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span>  <span style=color:#a6e22e>SegTree</span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>(<span style=color:#ae81ff>1e9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(a,b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>==</span> i and str <span style=color:#f92672>==</span> i){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>+=</span> amm;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> i or str <span style=color:#f92672>&lt;</span> i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,i,amm);
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,i,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){update(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,i,amm);}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=interface>Interface</h2><p>Os m√©todos que mostramos s√£o todos internos da segtree, na hora de chama-los, n√£o precisamos passar tantos par√¢metros assim.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){update(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,i,amm);}
</span></span></code></pre></div><h3 id=segtree>SegTree</h3><p>Construtor, recebe o tamanho do vetor.</p><h3 id=query>query</h3><p>Executa uma consulta, recebe o intervalo(l,r) da consulta, retorna o resultado.</p><h3 id=update>update</h3><p>Atualiza um √≠ndice no vetor recebe o √≠ndice e o novo valor.</p><h2 id=constru√ß√£o>Constru√ß√£o</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>SegTree <span style=color:#a6e22e>st</span>(v.size());
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span> v.size();i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    st.update(i,v[i]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=atualiza√ß√µes-em-intervalos>Atualiza√ß√µes em intervalos</h2><p>A segtree que temos at√© agora faz atualiza√ß√£o de uma posi√ß√£o no vetor e consulta de qualquer em intervalo, em <code>O(log n)</code>. Mas e se precisarmos atualizar um intervalo, por exemplo: &ldquo;Todos os elementos da posi√ß√£o 1 at√© 10 recebem 2&rdquo;. Assim, a melhor forma que ter√≠amos de fazer isso seria</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SegTree <span style=color:#a6e22e>st</span>(n);
</span></span><span style=display:flex><span><span style=color:#75715e>// preenche segtree
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    st.update(i,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O que tem complexidade <code>O(n * log n)</code>. Precisamos fazer isso mais r√°pido.</p><h1 id=lazy-progapation>Lazy progapation</h1><p>Lazy propagation √© uma altera√ß√£o na segtree que nos permite fazer atualiza√ß√µes em intervalos em <code>O(log n)</code>.</p><h2 id=a-ideia>A ideia</h2><p>Em nossa abordagem anterior, o que tornava a execu√ß√£o lenta √© que procur√°vamos o nodo respons√°vel por cada elemento que precisava ser atualizado.</p><p>Para acelerar esse processo, podemos usar uma ideia parecida com a da consulta, em vez de atualizar individualmente os elementos, podemos atualizar a resposta nos intervalos que os cont√©m, e postergar a atualiza√ß√£o nos filhos.</p><p>Para implementar lazy propagation, cada configura√ß√£o de segtree vai requerer uma implementa√ß√£o um pouco diferente, por isso, ser√° necess√°rio entender o que cada parte do c√≥digo est√° fazendo.</p><p>O exemplo a seguir ser√° de uma segtree de soma, aonde a atualiza√ß√£o de intervalo vai setar todos os elementos para um qualquer.</p><h2 id=vetor-de-lazy>vetor de lazy</h2><p>A ideia √© introduzir um vetor extra com o seguinte significado: Quando eu passar no nodo identificado por id, em uma consulta, ou outra atualiza√ß√£o, preciso atualizar seu valor para <code>lazy[id]</code>. O vetor has indica se h√° uma atualiza√ß√£o para ser feita naquele nodo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lazy;
</span></span><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> has;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> size;
</span></span></code></pre></div><h2 id=a-propaga√ß√£o>A propaga√ß√£o</h2><p>A fun√ß√£o de propaga√ß√£o √© a fun√ß√£o que atualiza o valor de um nodo, e posterga a atualiza√ß√£o para os filhos. Precisamos chamar essa fun√ß√£o toda vez que passamos por algum nodo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>propagate</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str){
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Se h√° algo para atualizar, atualize()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>if</span>(has[sti])
</span></span><span style=display:flex><span>           <span style=color:#75715e>//O valor desse nodo da segtree ser√° (n√∫mero de elementos que esse intervalo representa vezes novo valor de cada elemento do intervalo)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           st[sti] <span style=color:#f92672>=</span> lazy[sti] <span style=color:#f92672>*</span> (str <span style=color:#f92672>-</span> stl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>           <span style=color:#75715e>// Se o n√≥ representa um segmento de tamanho maior que 1, isto √©, n√£o √© terminal, propague a atualiza√ß√£o para os filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>!=</span> str){
</span></span><span style=display:flex><span>               lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>               lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>               has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>               has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>           <span style=color:#75715e>// agora n√£o √© mais necess√°rio atualizar esse nodo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           has[sti] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><h2 id=a-fun√ß√£o-de-atualiza√ß√£o-em-intervalo>A fun√ß√£o de atualiza√ß√£o em intervalo</h2><p>Essa √© a fun√ß√£o que realiza a atualiza√ß√£o de intervalos. O significado dos argumentos √©:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>l</code>: limite inferior do intervalo que queremos atualizar no <strong>vetor</strong></li><li><code>r</code>: limite superior do intervalo que queremos atualizar no <strong>vetor</strong></li><li><code>amm</code>: novo valor dos elementos nesse intervalo</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l,<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r){
</span></span><span style=display:flex><span>            <span style=color:#75715e>// O valor que ser√° atribuido a todo elemento no intervalo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            lazy[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            propagate(sti, stl, str);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> r  or str <span style=color:#f92672>&lt;</span> l)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r,amm);
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=vers√£o-final>Vers√£o final</h2><p>Essa √© a vers√£o final da nossa ED.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span>  <span style=color:#a6e22e>SegTree</span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lazy;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> has;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>propagate</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(has[sti]){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>=</span> lazy[sti] <span style=color:#f92672>*</span> (str <span style=color:#f92672>-</span> stl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>!=</span> str){
</span></span><span style=display:flex><span>                lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>                lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>        propagate(sti, stl, str);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l,<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r){
</span></span><span style=display:flex><span>            lazy[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            propagate(sti, stl, str);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> r  or str <span style=color:#f92672>&lt;</span> l)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r,amm);
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>), lazy(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>),has(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,false){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){update_range(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r,amm);}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=problemas-recomendados>Problemas recomendados</h2><ul><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2531>Compras em FdI</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1301>Produto do Intervalo</a></li><li><a href=https://codeforces.com/contest/1234/problem/D>Distinct Characthers</a></li><li><a href=https://codeforces.com/contest/830/problem/B>Cards Sorting</a></li><li><a href=https://codeforces.com/contest/474/problem/F>Ant Colony</a></li><li><a href=https://codeforces.com/contest/339/problem/D>Xenia and Bit Operations</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1500>Consultas Horr√≠veis</a></li><li><a href=https://codeforces.com/contest/920/problem/F>SUM and REPLACE</a></li><li><a href=https://codeforces.com/contest/380/problem/C>Sereja and Brackets</a></li><li><a href=https://www.spoj.com/problems/KQUERY/>Kquery</a></li><li><a href=https://www.spoj.com/problems/DQUERY/>DQuery</a></li></ul><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 15</div><h1>Sparse Table</h1><p>Nesse tutorial vamos falar sobre uma estrutura de dados chamada Sparse Table, que √© uma estrutura de dados poderosa para resolvermos range queries de algumas opera√ß√µes espec√≠ficas em complexidades superiores as de uma Segment Tree por exemplo.</p><p>Por exemplo, uma Sparse Table conseque resolver range minimum(ou maximum) query em <code>O(1)</code>, enquanto numa segment tree precisar√≠amos de <code>O(log n)</code>. Outro exemplo poderia ser range query de gcd, numa Segment Tree podemos resolver range queries de GCD em <code>O(log^2 n)</code>, j√° na sparse table conseguimos isso em <code>O(log n)</code>. No geral, quando a opera√ß√£o da range query tem uma propriedade chamada idempot√™ncia, podemos tirar um log da complexidade usando a Sparse Table.</p><h2 id=idempot√™ncia>Idempot√™ncia</h2><p>A propriedade que uma opera√ß√£o precisa ter para que possamos ganhar tempo de execu√ß√£o usando a Sparse Table √© a idempot√™ncia. Na defini√ß√£o que estamos levando em considera√ß√£o, uma opera√ß√£o <code>op</code> (bin√°ria) √© idempotente quando para todo <code>x</code> e todo <code>y</code>, <code>op(x,y) = op(x,op(x,y))</code>. Poder√≠amos dar uma defini√ß√£o mais precisa por√©m o que precisamos saber √© que numa opera√ß√£o idempotente, aplicar a opera√ß√£o uma vez √© o mesmo que aplicar 2,3,4,&mldr; qualquer n√∫mero de vezes maior que 0.</p><p>A opera√ß√£o min possui essa propriedade, para qualquer <code>x,y</code>, <code>min(x,y) = min(x,min(x,y))</code>. Outro exemplo √© o pr√≥prio gcd como mencionado acima. para qualquer <code>x,y</code>, <code>gcd(x,y) = gcd(x,gcd(x,y))</code>.</p><p>Mas essa propriedade n√£o √© verdade para a opera√ß√£o de soma, por exemplo, seja <code>sum(x,y) = x + y</code>, <code>sum(3,4) != sum(3,sum(3,4))</code>, aplicar a opera√ß√£o mais de uma vez com os mesmos argumentos a direita(ou a esquerda) resulta num resultado diferente, ent√£o soma n√£o √© idempotente. Na verdade as opera√ß√µes mais comuns v√£o ser GCD e min/max, mas √© importante saber a propriedade para entender porque a ideia que vamos usar funciona e tamb√©m caso haja uma opera√ß√£o meio maluca que seja idempotente saber se consegue montar a Sparse table sobre ela.</p><h2 id=o-pulo-do-gato>O pulo do gato</h2><p>Imagine que tenhamos uma fun√ß√£o <code>m√°gica</code>, chamada <code>dp(n,k)</code>, que retorna a opera√ß√£o aplicada no intervalo [n, n + (2^k) - 1].</p><pre tabindex=0><code>k = 0, [n, n]
k = 1, [n, n + 1]
k = 2, [n, n + 3]
k = 3, [n, n + 7]
.
.
</code></pre><p>Ent√£o se a opera√ß√£o for <code>min</code>, vai ser o m√≠nimo dos elementos nesse intervalo, se for <code>gcd</code> vai ser o gcd entre todos os n√∫mero desse intervalo etc. Certo ent√£o com essa fun√ß√£o, vamos fingir que recebemos uma min query para o intervalo [4, 17] em um vetor.</p><p>Como a opera√ß√£o √© idempotente, podemos fazer o seguinte. A resposta vai ser min(dp(4,3), dp(10,3)),</p><pre tabindex=0><code>[0, 1, 2, 3, (4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)]
[1, 3, 2, 5, (9, 6, 8, 0, 1, 2, 40, 51,  2,  4, 63, 20,  2,  4)]
</code></pre><p>O intervalo que estamos interessados est√° demarcado com um par√™ntese. Bem, dp(4, 3) = 0, e dp(10,3) = 2, e min(0,2) = 0, que realmente √© o m√≠nimo do intervalo. Se a query fosse no intervalo [4,10] poder√≠amos fazer <code>min(dp(4,2), dp(7,2))</code>, e assim por diante.</p><p>Ent√£o o que n√≥s estamos fazendo aqui √© selecionando uma potencia de dois e duas posi√ß√µes aonde duas chamadas a essa fun√ß√£o m√°gica v√£o ser suficientes para cobrir exatamente o intervalo que estamos interessados. E a opera√ß√£o precisa ser idempotente porque como estamos selecionando apenas intervalos que tem tamanhos de pot√™ncias de dois, no caso geral n√£o conseguimos selecionar dois intervalos que n√£o tenham interse√ß√£o, e caso a opera√ß√£o n√£o seja idempotente, isso far√° com que a interse√ß√£o seja contada duas vezes, fazendo ent√£o com que essa ideia n√£o funcione. Voltaremos mais tarde na implementa√ß√£o de como selecionar essas pot√™ncias.</p><p>Ent√£o a complexidade que temos at√© ent√£o para resolver consultas √© a seguinte: <code>O(k + 2*q)</code> aonde <code>k</code> √© o custo da opera√ß√£o, e <code>q</code> √© o custo da nossa fun√ß√£o <code>m√°gica</code>. Veremos que conseguimos com programa√ß√£o din√¢mica precomputar os valores pra essa fun√ß√£o fazendo com que as chamadas a ela tenham tempo constante. Como <code>min()</code> tem tempo constante de <code>gcd()</code> tempo <code>log</code>, √© assim que resultamos nas complexidades mencionadas no come√ßo do texto.</p><h2 id=recorr√™ncia>Recorr√™ncia</h2><p>Esta √© a recorr√™ncia da programa√ß√£o din√¢mica, nessa recorr√™ncia, estamos apenas dizendo o seguinte: O resultado da opera√ß√£o em um intervalo √© o resultado da primeira metade combinado com o resultado da segunda metade.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dp</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> op(dp(i,k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),dp(i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)). k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=vers√£o-recursiva>Vers√£o recursiva</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> memo[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(SIZE);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dp</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>&gt;=</span> SIZE) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(memo[i][k] <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> memo[i][k];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memo[i][k] <span style=color:#f92672>=</span> min(dp(i,k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),dp(i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)), k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=vers√£o-iterativa>Vers√£o iterativa</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> memo[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(SIZE);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    memo[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> v[i];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> k <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&gt;=</span> SIZE) {
</span></span><span style=display:flex><span>            memo[i][k] <span style=color:#f92672>=</span> memo[i][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            memo[i][k] <span style=color:#f92672>=</span> op(memo[i][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], memo[i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Precisamos apenas computar para pot√™ncias at√© log2(SIZE) + 1 porque pot√™ncias maiores que essa com certeza j√° s√£o maiores que o vetor.</p><p>Outro detalhe de implementa√ß√£o √© que temos que tomar cuidado para n√£o acessar fora do vetor, algumas alternativas que temos podem ser por exemplo adicionar um <code>if(i >= SIZE) return 0;</code> na vers√£o recusiva. Na vers√£o iterativa fazemos de maneira an√°loga.</p><p>Estamos preenchendo uma tabela de tamanho <code>O(n log n)</code> aonde <code>n</code> √© o tamanho da √°rvore, para preencher cada c√©lula dessa tabela fazemos opera√ß√µes constantes e uma chamada a <code>op</code>, ent√£o a complexidade de montarmos essa tabela para responder as queries √© <code>O(n log n * K)</code>, aonde K √© a complexidade de <code>op</code>.</p><h2 id=ajustando-a-consulta>Ajustando a consulta</h2><p>Acima demos alguns exemplos de como podemos usar a recorr√™ncia que definimos para computar intervalos espec√≠ficos, por exemplo para <code>[4,17]</code>, escolhemos <code>(4,3) e (10,7)</code>. O intervalo em quest√£o tem tamanho 14, ent√£o a menor pot√™ncia de 2 que podemos usar para cobri-lo √© 8(2^3). Em geral essa menor pot√™ncia pode ser calculada pela express√£o <code>log2(b-a)</code>, aonde log2(x) √© o ch√£o do logaritmo de x na base 2 e assumimos que <code>b > a</code>.</p><pre tabindex=0><code>log2(13) = 3
log2(14) = 3
log2(15) = 3
log2(16) = 4
.
.
.
</code></pre><p>E sobre as posi√ß√µes da query, a primeira sempre ser√° no come√ßo do intervalo, e a segunda temos que ajustar de forma que o √∫ltimo elemento levado em considera√ß√£o seja o √∫ltimo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> lg <span style=color:#f92672>=</span> log2(b<span style=color:#f92672>-</span>a);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> F(tb[a][lg],tb[<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> b<span style=color:#f92672>-</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> lg)][lg])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=conte√∫do-complementar>Conte√∫do complementar</h1><p><a href="https://www.youtube.com/watch?v=EKcQt-74bNw">https://www.youtube.com/watch?v=EKcQt-74bNw</a></p><h1 id=exerc√≠cios-recomendados>Exerc√≠cios recomendados</h1><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Algoritmos</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/algoritmos/busca_binaria/>Busca Bin√°ria</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Algoritmos</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 16</div><h1>Busca Bin√°ria</h1><p>Busca bin√°ria √© um algoritmo de divis√£o e conquista usado em sua maior parte para minimizar o tempo de uma busca linear. Na busca bin√°ria sempre estamos procurando o &ldquo;o maior <code>x</code> valor que satisfaz uma condi√ß√£o <code>c(x)</code>&rdquo; ou &ldquo;o menor <code>x</code> valor que satisfaz uma condi√ß√£o <code>c(x)</code>&rdquo;, retornaremos nesse ponto depois no texto.</p><p>Imagine voc√™ com um livro de 1000 p√°ginas em m√£os no momento em que o professor pede para que o abra no come√ßo do capitulo 6 se√ß√£o 4. Existem v√°rias maneiras de se alcan√ßar a p√°gina certa. Uma delas √© ir de uma em uma at√© que se alcance a p√°gina desejada. Outra maneira √© ir pulando alguns blocos de p√°ginas, se voc√™ est√° numa p√°gina depois do come√ßo do capitulo 6 se√ß√£o 4 pula algumas p√°ginas para tras, se voc√™ est√° numa p√°gina antes, pula algumas p√°ginas para frente.</p><p>Perceba que no exemplo acima uma busca linear (passar de p√°gina em p√°gina) demoraria muito mais do que ir pulando algumas partes do livro. E fazendo da segunda maneira involuntariamente voc√™ acaba aplicando uma vers√£o primitiva do que chamamos de busca bin√°ria.</p><h2 id=o-algortimo>O algortimo</h2><p>Usando a mesma ideia do livro por√©m agora em uma linguagem mais computacional. No lugar de 1000 p√°ginas podemos ter um vetor de 1000 posi√ß√µes onde a i-√©sima tem um pair &lt;capitulo, se√ß√£o> da pagina i, por exemplo, se a p√°gina 125 faz parte do cap√≠tulo 4 se√ß√£o 2 ent√£o <code>v[125] = make_pair(4, 2);</code>. E digamos que o cap√≠tulo 6 se√ß√£o 4 est√° na p√°gina 375(que n√£o sabemos no come√ßo da busca).</p><p>Primeiro podemos, por exemplo, para a p√°gina 400. A partir do pair daquela posi√ß√£o aprendemos que o que procuramos est√° antes de 400, ent√£o agora n√£o precisamos procurar a resposta no intervalo [1, 1000] e sim no intervalo [1, 399]. Podemos fazer um segundo chute na posicao 300, por exemplo pois podemos chutar em qualquer posi√ß√£o do intervalo, e depois de olhar v[300] aprendemos que a resposta est√° no intervalo [301, 399]. Podemos ent√£o chutar na p√°gina 375 e encontrar que esta √© a resposta que procuramos.</p><p>O √∫nico problema do que foi descrito acima √© determinar como chutar o elemento dentro do intervalo j√° que os chutes foram meio aleat√≥rios. O primeiro chute foi no elemento 400 num intervalo [1, 1000], depois de olhar o elemento poder√≠amos passar a ter que olhar o intervalo [1, 399](se o que procuramos est√° antes) ou [401, 1000](se o que procuramos est√° depois), tivemos sorte e caimos no primeiro caso mas no pior caso poder√≠amos cair no intervalo maior. O jeito de garantirmos de no pior caso sempre irmos para um intervalo de menor tamanho possivel √© chutar de uma forma a dividir o intervalo em 2 intervalos de tamanhos (aproximadamente) iguais. Podemos fazer isso s√≥ chutando na metade do intervalo, assim √© melhor fazer o primeiro chuta na posi√ß√£o 500 e nao 400.</p><h2 id=condi√ß√µes-para-aplicar-busca-bin√°ria>Condi√ß√µes para aplicar busca bin√°ria</h2><p>Nem sempre √© poss√≠vel aplicar busca bin√°ria para encontrar uma resposta: um exemplo seria um livro cujos capitulos e se√ßoes nao est√£o em ordem crescente. Nessa situa√ß√£o, n√£o poderiamos mais ter certeza que um capitulo ou se√ß√£o maior estaria a direita.</p><p>Como mencionamos acima, na busca bin√°ria estamos procurando o maior ou menor valor que satisfaz uma propriedade. Ent√£o por exemplo, no exemplo acima, estamos buscando pelo menor √≠ndice(p√°gina) do vetor(livro) que satisfaz a condi√ß√£o &ldquo;estar num (cap√≠tulo, se√ß√£o) maior ou igual a (6,4)&rdquo;, porque a primeira p√°gina que satisfazer essa propriedade ser√° o in√≠cio do cap√≠tulo 6 se√ß√£o 4. Considere agora o outro exemplo de aplicarmos busca binaria no vetor para descobrir se um elemento <code>x</code> esta l√° ou n√£o. Uma maneira de fazer isso seria procurar pelo menor elemento <code>y</code> que seja maior ou igual <code>x</code>, se y for igual a x, ent√£o x est√° no vetor, caso contr√°rio x n√£o est√° no vetor.</p><p>Dizemos que √© poss√≠vel aplicar busca bin√°ria em um problema quando a checagem se um valor satisfaz as condi√ß√µes apresenta <strong>monotonicidade</strong>. Formalmente, monotonicidade pode ser definida da seguinte forma. Seja <code>check(x)</code> uma fun√ß√£o que verifica uma propriedade de <code>x</code> Se para todo <code>x</code>, <code>check(x) = true</code> implica <code>check(x+1) = true</code>, ou para todo x, <code>check(x) = false</code> implica <code>check(x+1) = false</code>, ent√£o a fun√ß√£o <code>check</code> √© mon√≥tona.</p><p>Ent√£o, se <code>x = 11</code> e o vetor <code>v = [1,2,3,5, 8, 11, 12, 14, 16]</code> observe o que acontece com o comportamento de uma fun√ß√£o <code>check</code> que checa se um elemento √© maior ou igual a x.</p><pre tabindex=0><code>bool check(int val) {
    return val &gt;= x;
}

[1,2,3,5,8,11,12,14,16]
[0,0,0,0,0,1,1,1,1,1]
</code></pre><p>Ent√£o se colocarmos graficamente os resultados de uma fun√ß√£o <code>check</code> monotona, veremos exatamente isso, ou um monte de valores <code>0</code>s e a partir de certo ponto todos s√£o <code>1</code>s, ou o contr√°rio, um monte de <code>1</code>s e a partir de certo ponto todos s√£o <code>0</code>s. No exemplo a cima √© a primeira possibilidade.</p><p>Ent√£o a fun√ß√£o check para essa situa√ß√£o √© mon√≥tona, e isso √© relevante porque se um valor do vetor satisfizer a condi√ß√£o, todos os valores a direita tamb√©m v√£o satisfaz√™-la, e de forma an√°loga, todos os valores a esquerda de um √≠ndice que n√£o satisfaz a condi√ß√£o, tamb√©m n√£o v√£o satisfazer, e √© isso que nos permite aplicar busca bin√°ria. E a fun√ß√£o check s√≥ se torna mon√≥tona nesse exemplo quando o vetor est√° ordenado, por isso busca bin√°ria s√≥ √© feita em vetores ordenados : ).</p><p>Ent√£o o que faremos √© chutar intervalo aonde a resposta com certeza estar√° no come√ßo, fazemos ent√£o v√°rias intera√ß√µes checando no meio, e dependendo da resposta, descartamos os elementos a direita ou a esquerda, mas sempre dividimos o tamanho do intervalo por 2, at√© que o intervalo tenha tamanho 1.</p><h2 id=complexidade>Complexidade</h2><p>Tudo muito massa, mas falta a complexidade! Depois de saber isso podemos come√ßar a aplicar esse algoritmo nos problemas por ae :)</p><p>por enquanto nosso algoritmo de maneira abstrata √© o seguinte</p><pre tabindex=0><code>while(tamanho do intervalo que a resposta pode estar != 1) {
    chuta no meio e descarta a metade da direita ou da esquerda(dependendo do resultado), dividindo o intervalo por 2;
}
</code></pre><p>Suponha um vetor ordenado de tamanho N onde vamos aplicar o algoritmo de busca bin√°ria e o valor procurado n√£o est√° presente no vetor (pior caso). Na nossa primeira itera√ß√£o iremos dividir o vetor em 2 partes ou seja teremos N/2 elementos restantes, na segunda itera√ß√£o iremos dividir do que restou e teremos (N/2)/2 ou seja N/4, seguindo essa l√≥gica na K-√©sima itera√ß√£o vamos dividir o tamanho do vetor K vezes por 2, ou seja, N/(2^K) e como estamos calculando complexidade temos que pensar no pior caso, quando chegarmos no ponto onde teremos um espa√ßo de apenas 1 elemento(e verificamos que o elemento n√£o est√° no vetor). O que estamos buscando para saber a complexidade √© K (quantidade de passos) para o pior caso ent√£o temos que N/(2^K) = 1 da√≠ temos que N = 2^K e tirando o log2 dos dois lados temos que K = log2(N). Ent√£o no pior caso nosso algortimo demora <code>O(log2(N))</code> passos, N sendo o tamanho do intervalo inicial. Se a fun√ß√£o de checagem tiver uma complexidade <code>O(f(x))</code>, ent√£o teremos complexidade no total <code>O(log2(N) * f(x))*</code>.</p><h2 id=c√≥digo-base-para-busca-bin√°ria>C√≥digo base para busca bin√°ria</h2><p>H√° v√°rias maneiras de se implementar busca bin√°ria, vamos apresentar v√°rias delas. Vamos usar sempre a fun√ß√£o check em separado, os jeitos de implementar diferente s√£o apenas do corpo da busca bin√°ria.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// nessa fun√ß√£o checamos se uma resposta satisfaz as condi√ß√µes para ser uma resposta v√°lida, e retornamos um booleano dependendo disso.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=tipo-1>Tipo 1</h3><h4 id=valor-m√≠nimo-menor-valor-que-torna-check-verdadeiro>Valor m√≠nimo (Menor valor que torna check verdadeiro)</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;<span style=color:#75715e>// sei que a resposta n√£o √© menos que a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;<span style=color:#75715e>// sei que a resposta n√£o √© mais que b (as vezes esse chute tem que ser bom, para evitar overflow)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(r <span style=color:#f92672>&gt;</span> l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>){<span style=color:#75715e>// repita enquanto o intervalo tiver tamanho &gt; 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(check(mid)){ <span style=color:#75715e>// mid √© v√°lido
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        r <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// como queremos minimizar a resposta, e mid √© uma resposta v√°lida
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>//descartamos tudo a direita de mid (mas n√£o mid)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        l <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Se mid n√£o √© v√°lido, descartamos ele e tudo abaixo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Ao final desse la√ßo, a resposta pode estar em l ou r.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Queremos minimizar a resposta, ent√£o se l for v√°lido, 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ficaremos com l, e caso contr√°rio,  com r
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(check(l)){
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=valor-m√°ximo-maior-valor-que-torna-check-verdadeiro>Valor m√°ximo (Maior valor que torna check verdadeiro)</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(r <span style=color:#f92672>&gt;</span> l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(check(mid)){<span style=color:#75715e>// mid √© v√°lido
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        l <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// como queremos maximizar a resposta, e mid √© uma resposta v√°lida
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>//descartamos tudo a esquerda de mid (mas n√£o mid)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Se mid n√£o √© v√°lido, descartamos ele e tudo acima.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(check(l)){
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=tipo2>Tipo2</h3><h4 id=valor-m√≠nimo>Valor m√≠nimo</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (check(mid)) r <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// a resposta fica em l
</span></span></span></code></pre></div><h4 id=valor-m√°ximo>Valor m√°ximo</h4><p>√â f√°cil alterar o c√≥digo de valor m√≠nimo para encontrar o valor m√°ximo:
Imagine que uma fun√ß√£o de check d√™ o resultado <code>[1,1,1,0,0]</code>. Veja que encontrar o √∫ltimo 1
nesse array √© equivalente a encontrar o primeiro 0 e subtrair 1 da posi√ß√£o! Assim, podemos aplicar
a busca bin√°ria de valor m√≠nimo <strong>no valor contr√°rio</strong> do checker (<code>!check(mid)</code>) e subtrair 1 da resposta ao final.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>check(mid)) r <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// check vira !check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span> l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// a resposta fica em l-1
</span></span></span></code></pre></div><p>Detalhe: como usamos <code>l-1</code> no final, a busca n√£o inclui <code>b</code>, ou seja, buscamos no intervalo <code>[a, b)</code>.</p><h2 id=exemplos-de-aplica√ß√£o>Exemplos de aplica√ß√£o</h2><h3 id=implementa√ß√£o-de-lower_bound>Implementa√ß√£o de lower_bound</h3><p>Consideremos o problema de achar o indice do primeiro elemento maior ou igual um <code>x</code> num vetor <code>v</code> de tamanho <code>n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> v[MAXN], n; <span style=color:#75715e>// vetor global para facilitar o c√≥digo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// funcao que retorna se id √© uma resposta v√°lida pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> id, <span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v[id] <span style=color:#f92672>&gt;=</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// retorna o indice do primeiro elemento &gt;= x, considerando que o vetor v est√° ordenado
</span></span></span><span style=display:flex><span><span style=color:#75715e>// se todos os elementos sao menores que x, retorna -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lower_bound</span>(<span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> L, R, ans;
</span></span><span style=display:flex><span>    L <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// come√ßo do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    R <span style=color:#f92672>=</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// fim do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ans <span style=color:#f92672>=</span> n; <span style=color:#75715e>// come√ßamos a resposta com um valor fora do vetor, inv√°lido para marcar se conseguimos achar alguma resposta ou nao
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(L <span style=color:#f92672>&lt;=</span> R){ <span style=color:#75715e>// enquanto tiver algum n√∫mero no intervalo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (L<span style=color:#f92672>+</span>R)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(check(mid, x)){ <span style=color:#75715e>// se esse mid √© uma resposta apropriada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// achamos uma nova resposta para o problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            R <span style=color:#f92672>=</span> mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se mid √© uma resposta temos que tentar procurar uma resposta menor(nesse problema em especifico)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>{ <span style=color:#75715e>// se mid nao √© uma resposta pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            L <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// precisamos procurar em indices maiores(neste problema)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(ans <span style=color:#f92672>==</span> n) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se ans ainda √© n depois da busca bin√°ria, ent√£o nunca achamos resposta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Perceba que se quisermos achar o indice do √∫ltimo elemento maior ou igual um <code>x</code> num vetor <code>v</code> de tamanho <code>n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> v[MAXN], n; <span style=color:#75715e>// vetor global para facilitar o c√≥digo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// funcao que retorna se id √© uma resposta v√°lida pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> id, <span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v[id] <span style=color:#f92672>&gt;=</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// retorna o indice do primeiro elemento &gt;= x, considerando que o vetor v est√° ordenado
</span></span></span><span style=display:flex><span><span style=color:#75715e>// se todos os elementos sao menores que x, retorna -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lower_bound</span>(<span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> L, R, ans;
</span></span><span style=display:flex><span>    L <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// come√ßo do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    R <span style=color:#f92672>=</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// fim do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ans <span style=color:#f92672>=</span> n; <span style=color:#75715e>// come√ßamos a resposta com um valor fora do vetor, inv√°lido para marcar se conseguimos achar alguma resposta ou nao
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(L <span style=color:#f92672>&lt;=</span> R){ <span style=color:#75715e>// enquanto tiver algum n√∫mero no intervalo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (L<span style=color:#f92672>+</span>R)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(check(mid, x)){ <span style=color:#75715e>// se esse mid √© uma resposta apropriada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans <span style=color:#f92672>=</span> mid;  <span style=color:#75715e>// achamos uma nova resposta para o problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            L <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se mid √© uma resposta temos que tentar procurar uma resposta maior(nesse problema em especifico)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>{ <span style=color:#75715e>// se mid nao √© uma resposta pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            R <span style=color:#f92672>=</span> mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// precisamos procurar em indices menores(neste problema)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(ans <span style=color:#f92672>==</span> n) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se ans ainda √© n depois da busca bin√°ria, ent√£o nunca achamos resposta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Em ambos os exemplos a complexidade de checar se mid √© uma resposta v√°lida para o problema √© <code>O(1)</code>. Portanto a complexidade total √© <code>O(lg n)</code>.</p><p>Muitas pessoas ja viram o exemplo de realizar busca bin√°ria em vetores, mas quando se fala em busca bin√°ria na resposta, ficam confusas. Na verdade, busca bin√°ria em vetores √© busca bin√°ria na resposta, mas a resposta √© um √≠ndice.</p><h1 id=material-complementar>Material complementar</h1><h1 id=exerc√≠cios-recomendados>Exerc√≠cios recomendados</h1><p>Estes exerc√≠cios n√£o est√£o necessariamente em ordem de dificuldade.</p><ul><li><a href=https://codeforces.com/contest/1234/problem/A>https://codeforces.com/contest/1234/problem/A</a> - N√£o √© necess√°rio busca bin√°ria mas √© um exerc√≠cio legal para aprender</li><li><a href=https://codeforces.com/problemset/problem/817/C>https://codeforces.com/problemset/problem/817/C</a> - Bem interessante, (se x √© um numero realmente grande entao x+1 √© realmente grande)</li><li><a href=https://codeforces.com/problemset/problem/760/B>https://codeforces.com/problemset/problem/760/B</a> - Se frodo n√£o consegue ter x de altura ent√£o consegue ter x+1 de altura. Cuidado com overflows!</li><li><a href=https://codeforces.com/gym/102346/problem/M>https://codeforces.com/gym/102346/problem/M</a> - (Tente minimizar o quanto cada competidor come j√° que a resposta √© em fun√ß√£o do competidor que mais come)</li></ul><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Grafos</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/grafos/representacao/>Representa√ß√£o de Grafos</a></li><li><a href=/materiais/grafos/busca_largura/>Busca em Largura</a></li><li><a href=/materiais/grafos/busca_profundidade/>Busca em Profundidade</a></li><li><a href=/materiais/grafos/dijkstra/>Dijkstra</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Grafos</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 17</div><h1>Representa√ß√£o de Grafos</h1><p>Um dos assuntos mais frequentes s√£o problemas relacionados a grafos, ou que podem ser representados como grafos, apesar de n√£o ser √≥bvio √† primeira vista.</p><h2 id=conceitos>Conceitos</h2><p>H√° diversos tipos e atributos de um grafo:</p><h3 id=o-que-√©-um-grafo>O que √© um grafo?</h3><p>Um grafo √© definido simplesmente por um conjunto de v√©rtices, e outro conjunto de arestas. Essas arestas ligam dois v√©rtices, e podem ter pesos atrelados √† elas.</p><h3 id=grafo-simples>Grafo simples</h3><p>Grafo simples √© um grafo que n√£o cujas arestas n√£o tem peso, n√£o possui loops, e nem arestas m√∫ltiplas. Loops s√£o arestas do tipo <code>(u,u)</code>, ou seja, que saem do v√©rtice <code>u</code>, e v√£o para o v√©rtice <code>u</code>. Um grafo com arestas m√∫ltiplas √© um grafo que tem duas aresta iguais.</p><h3 id=grafos-direcionados>Grafos direcionados</h3><p>Existem grafos direcionados e n√£o direcionados. No caso dos direcionados, significa que cada aresta tem uma dire√ß√£o, ou seja, se √© poss√≠vel chegar de a em b, n√£o significa que √© poss√≠vel chegar de b em a.</p><h3 id=ciclos>Ciclos</h3><p>A defini√ß√£o de ciclo √© um pouco diferente dependendo se o grafo √© direcionado ou n√£o.</p><p>Caso o grafo n√£o seja direcionado, e hajam dois caminhos diferentes de um v√©rtice <code>a</code> para um v√©rtice <code>b</code>, ent√£o h√° um ciclo.</p><p>Caso contr√°rio, ou seja, caso o grafo seja direcionado, para que haja um ciclo √© necess√°rio que exista um v√©rtice <code>a</code> tal que seja poss√≠vel voltar a <code>a</code> partindo dele mesmo.</p><h3 id=conexo>Conexo</h3><p>Um grafo conexo √© um grafo tal que para dois v√©rtices quaisquer u e w, sempre existe um caminho de u para w.</p><h3 id=componentes-conexas>Componentes conexas</h3><p>Um grafo que n√£o √© conexo pode ter v√°rias componentes conexas (grafos conexos tem somente uma componente). Essencialmente, uma componente conexa √© um peda√ßo conexo do grafo. Esse conceito √© usado no caso de grafos n√£o-direcionados.</p><h3 id=componentes-fortemente-conexas>Componentes fortemente conexas</h3><p>J√° nos casos do grafos direcionados, o termo usado √© esse, tamb√©m chamados por SCCs(Strongly Connectec Components). A defini√ß√£o mais &lsquo;formal&rsquo; √© a seguinte: dentro de uma componente conexa de um grafo direcionado, para todo v√©rtice <code>a</code> e <code>b</code>, deve ser poss√≠vel de chegar de <code>b</code> partindo de <code>a</code> e em <code>a</code> partindo de <code>b</code>.</p><p>Basicamente o que a defini√ß√£o acima est√° dizendo √©: uma componente fortemente conexa √© um ciclo, mas √© importante lembrar que se dois ciclos se juntam, formam um ciclo maior, logo, uma componente maior.</p><h3 id=√°rvore>√Årvore</h3><p>Uma √°rvore √© um tipo de grafo. Para ser uma √°rvore, o grafo precisa ser conexo, n√£o ter ciclos e ter <code>n-1</code> arestas, aonde n √© o n√∫mero de v√©rtices.</p><h3 id=dag>DAG</h3><p>DAG √© uma sigla para <code>Directed Acyclic Graph</code>, ou seja, um grafo ac√≠clico e direcionado. √â um termo bastante usado.</p><h3 id=grafos-bipartidos>Grafos bipartidos</h3><p>Um grafo bipartido √© um grafo tal que √© poss√≠vel dividir seus v√©rtices em dois grupos, de forma que s√≥ hajam arestas ligando v√©rtices do primeiro ao segundo grupo.</p><h2 id=representa√ß√£o-de-um-grafo>Representa√ß√£o de um grafo</h2><p>Mas como representar um grafo em c√≥digo?</p><p>Na verdade √© bem mais simples do que parece. Para cada v√©rtice, temos que manter apenas uma lista das arestas que saem daquele v√©rtice.</p><p>Nessa representa√ß√£o, a i-√©sima posi√ß√£o no vector de fora <code>vector&lt;int></code>, esse vector representam as arestas que saem daquele v√©rtice. Ent√£o, cada v√©rtice tem um n√∫mero associado a ele.</p><h3 id=exemplo>Exemplo</h3><p><img src=http://danielamaral.wikidot.com/local--files/agmmo/Grafo.png alt=Grafo></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[<span style=color:#ae81ff>7</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>6</span>].push_back(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>5</span>].push_back(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>3</span>].push_back(<span style=color:#ae81ff>4</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>2</span>].push_back(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>3</span>].push_back(<span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>2</span>].push_back(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>5</span>].push_back(<span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>6</span>].push_back(<span style=color:#ae81ff>4</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>2</span>].push_back(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>1</span>].push_back(<span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// lembrando que no caso de grafos n√£o direcionados, quando adicionamos (a,b) precisamos sempre adicionar (b,a) junto.
</span></span></span></code></pre></div><h2 id=representa√ß√£o-da-grafos-impl√≠citos>Representa√ß√£o da grafos impl√≠citos</h2><p>Considere o seguinte problema para guiar a explica√ß√£o: <a href=http://codeforces.com/problemset/problem/520/B>http://codeforces.com/problemset/problem/520/B</a></p><p>A principio, nao parece exatamente muito f√°cil relacionar esse problema com grafos. Onde est√£o os v√©rtices e as arestas? Na verdade nesse problema h√° o que chamamos de grafo impl√≠cito.</p><p>Podemos considerar os v√©rtices como o n√∫mero mostrado pelo display, e as arestas como os v√©rtices que consigo alcan√ßar apertando os bot√µes, a partir do v√©rtice que estou. Mas n√≥s n√£o vamos criar uma estrutura de lista de adjac√™ncias em mem√≥ria igual ao caso anterior, n√£o precisamos. A √∫nica coisa que precisamos √© saber quais v√©rtices podemos atingir a partir de um v√©rtice <code>x</code>, ent√£o quando formos percorrer esse grafo impl√≠cito, como todos os v√©rtices seguem essa regra, n√£o precisamos criar as arestas propriamente ditas. Apenas sabemos que √© poss√≠vel atingir os v√©rtices <code>x-1</code> e <code>2x</code>.</p><p>O mesmo ocorre pra representa√ß√£o de jogos de turno, por exemplo jogo da velha ou damas. Podemos considerar uma configura√ß√£o do tabuleiro como um v√©rtice, e as arestas ligando para todas as configura√ß√µes poss√≠veis de atingir segundo as regras de jogada.</p><h2 id=videoaulas-complementares>VideoAulas complementares</h2><p><a href="https://www.youtube.com/watch?v=zaBhtODEL0w">https://www.youtube.com/watch?v=zaBhtODEL0w</a></p><h2 id=exerc√≠cios-recomendados>Exerc√≠cios recomendados</h2><ul><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1910>https://www.urionlinejudge.com.br/judge/pt/problems/view/1910</a> - Caminho m√≠nimo em grafo impl√≠cito sem pesos.</li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1907>https://www.urionlinejudge.com.br/judge/pt/problems/view/1907</a> - Contagem de componentes conexas em grafo que √© um grid (impl√≠cito).</li><li><a href=https://codeforces.com/gym/102346/problem/A>https://codeforces.com/gym/102346/problem/A</a> - Se considerarmos as paredes e sensores v√©rtices, vendo se alguns v√©rtices est√£o na mesma componente conexa podemos ver se h√° um caminho que bloqueia o ladr√£o.</li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2194>https://www.urionlinejudge.com.br/judge/pt/problems/view/2194</a> - (implementa√ß√£o mais dif√≠cil), resolver o reconhecimento por meio da contagem das componentes conexas de cada hier√≥glifo.</li></ul><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 18</div><h1>Busca em Largura</h1><p>Podemos cham√°-la tamb√©m de <strong>BFS (Breadth-First Search)</strong>.</p><p>Uma das formas de percorrer um grafo √© fazer um percorrimento em largura. Come√ßamos a explorar os v√©rtices do grafo a partir de um certo v√©rtice <code>a</code>. E a ordem que vamos navegando entre os v√©rtices √© de forma que os mais pr√≥ximos a <code>a</code> sempre ser√£o visitados antes. Ent√£o, primeiro <code>a</code> ser√° visitado, depois os v√©rtices que s√£o adjacentes a <code>a</code>(dist√¢ncia 1), depois os v√©rtices que est√£o a duas arestas de dist√¢ncia, e assim por diante. Como os v√©rtices mais pr√≥ximos s√£o sempre visitados antes, esse algoritmo serve para, por exemplo, dizer qual a dist√¢ncia m√≠nima entre dois v√©rtices no grafo.</p><p>Esse comportamento √© implementado usando-se uma fila. Primeiro insere-se na fila o v√©rtice inicial, e come√ßa-se a desenfileirar da fila enquando houver algum nodo. Quando um v√©rtice <code>a</code> √© desenfileirado, enfileram-se todos os v√©rtice adjacentes a <code>a</code> que n√£o foram visitados. Caso n√£o marquemos os visitados, e o grafo tiver ciclos, nosso programa n√£o terminar√°.</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Breadth-First-Search-Algorithm.gif/250px-Breadth-First-Search-Algorithm.gif alt=BFS></p><p>O algoritmo abaixo √© uma BFS que simplesmente percorre o grafo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// globais
</span></span></span><span style=display:flex><span><span style=color:#75715e>// inicializa visited como false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> visited[MAX_SIZE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[MAX_SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(<span style=color:#66d9ef>int</span> start){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    visited[start] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){<span style=color:#75715e>//Enquanto n√£o estiver vazia
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Retire o v√©rtice da frente
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> w: graph[u]){ <span style=color:#75715e>// Para cada v√©rtice adjacente a u
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[w]){
</span></span><span style=display:flex><span>                q.push(w);
</span></span><span style=display:flex><span>                visited[w] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade desse c√≥digo √© <code>O(n+m)</code>, temos no m√°ximo n v√©rtices enfileirados, e no loop interno, cada itera√ß√£o √© considerar uma aresta, como n√£o estamos voltando no grafo, n√£o passaremos por uma aresta mais que duas vezes naquele loop. Ent√£o, em todas as chamadas, aquele loop iterar√° no pior caso m vezes.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 19</div><h1>Busca em Profundidade</h1><p>Outra forma de percorrer um grafo √© fazer percorrimento em profundidade, tamb√©m de chamado de <strong>DFS(Depth-first search)</strong>. O algoritmo se chama assim porque funciona de uma forma que sempre vamos &lsquo;mergulhar&rsquo; no grafo o mais fundo que pudermos. Quando n√£o for mais poss√≠vel ir mais fundo no grafo, voltamos at√© que seja ir mais fundo novamente, sem repetir v√©rtices j√° visitados.</p><p>A implementa√ß√£o da DFS mais comum √© recursiva, por ser mais intuitiva. Assim como o exemplo anterior, esse programa simplesmente percorre o grafo, mas na ordem que um DFS percorre.</p><h2 id=visualiza√ß√£o>Visualiza√ß√£o</h2><p><img src=http://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif alt=DFS></p><h2 id=implementa√ß√£o>Implementa√ß√£o</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[MAX_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> visited[MAX_SIZE];     <span style=color:#75715e>// globais, inicializados na main.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> vertex){ <span style=color:#75715e>// na main chamamos dfs(start), aonde start √© o v√©rtice que come√ßamos o dfs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    visited[vertex] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> w: graph[vertex]){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[w]){
</span></span><span style=display:flex><span>            dfs(w);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade desse c√≥digo √© <code>O(n+m)</code>, temos no m√°ximo <code>n</code> chamadas recursivas, e no loop interno √†s chamadas, assim como no BFS, estaremos considerando uma aresta e n√£o passaremos nela mais de uma vez. Ent√£o no m√°ximo <code>m</code> itera√ß√µes ao longo de todas as chamadas.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 20</div><h1>Dijkstra</h1><div class="box notices cstyle secondary"><div class=box-label><i class="fa-fw fas fa-stopwatch"></i> Complexidade</div><div class=box-content><p>O(E*log(V))</p><p><code>E = Edges</code>
<code>V = Vertex</code></p></div></div><p>O algoritmo de Dijkstra √© um algoritmo muito conhecido para percorrimento de grafos cujas arestas tem pesos, ele nos permite percorrer os v√©rtices na ordem de dist√¢ncia para um v√©rtice fonte. E efetivamente descobrir essas dist√¢ncias.</p><p>Mais especificamente, de uma forma tal que considerando o v√©rtice fonte como <code>s</code>, se o menor caminho de <code>s</code> para um v√©rtice <code>u</code> √© estritamente menor que o menor caminho de <code>s</code> para um outro v√©rtice <code>v</code>, com certeza visitaremos <code>u</code> antes de <code>v</code>.</p><p>A forma como o algoritmo opera √© muito parecida com o BFS, mas em vez de usarmos uma fila, usamos uma fila de prioridades(priorizando menores valores). O motivo de usarmos essa outra estrutura de dados √© que usar uma fila n√£o gera mais o mesmo comportamento que desejamos quando as arestas passam a ter pesos.</p><p>Como as arestas tem pesos, nosso grafo ser√° um <code>vector&lt;pair&lt;int,int>> grafo[n]</code> ao inv√©s de um <code>vector&lt;int> grafo[n]</code>.</p><h3 id=a-ideia>A ideia</h3><p>Assim como no BFS, teremos essa fila que ditar√° a ordem com que os nodos ser√£o desenfileirados (visitados). Mas agora Nossa Fila √© de prioridades abriga pares ao inv√©s de apenas um inteiro.</p><p>Pra qualquer par <code>p</code> na fila, <code>(p.first,p.second)</code> significa: Consigo chegar no v√©rtice <code>p.second</code> por um caminho de custo <code>p.first</code>. Por isso no come√ßo da execu√ß√£o enfileiramos o par <code>(0, s)</code>, dizendo: consigo chegar no v√©rtice fonte pagando 0, afinal j√° estamos nele no come√ßo do percorrimento.</p><p>Quando desinfileiramos um v√©rtice, assim como no BFS, consideramos seguir por todas as arestas que partem dele, agora com pesos.</p><p>Bem, para cada aresta, sabemos seu destino e seu peso, ent√£o, a informa√ß√£o que podemos tirar disso √© que podemos ir para aquele destino com o custo da aresta somado com o custo para chegar no v√©rtice que acabamos de desinfileirar.</p><p>Na implementa√ß√£o do BFS, na hora de verificar se dev√≠amos enfileirar algo, verificavamos apenas se aquele destino j√° tinha sido enfileirado antes, usando um vetor pra armazenar essa informa√ß√£o.</p><p>Na nossa implementa√ß√£o, ao inv√©s de um vetor marcando quais j√° foram enfileirados, usaremos um vetor indicando o melhor custo conhecido para se atingir cada v√©rtice.</p><p>O motivo disso √© que n√£o h√° mais garantia que na primeira vez que enfileiramos um v√©rtice j√° obtivemos o melhor custo para chegar nele. Pode ser que posteriormente enfileiremos um custo menor pra chegar nesse v√©rtice.</p><p>Ent√£o, na hora de enfileirarmos, verificaremos se aquele enfileiramento √© vantajoso, isto √©, se ele melhora o melhor custo que j√° conhec√≠amos para chegar em algum v√©rtice. De come√ßo assumimos o custo infinito para chegar em todos.</p><h3 id=visualiza√ß√£o>Visualiza√ß√£o</h3><p><img src=https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif alt=Dijkstra></p><h3 id=implementa√ß√£o>Implementa√ß√£o</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ll;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>100005</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> ll oo <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e18</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ll d[N]; <span style=color:#75715e>// vetor onde guardamos as distancias
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n; <span style=color:#75715e>// numeros de vertices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// lista de adjacencias guarda
</span></span></span><span style=display:flex><span><span style=color:#75715e>// pair &lt;vertice para onde a aresta vai, peso da aresta&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, ll<span style=color:#f92672>&gt;&gt;</span> g[N];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dijkstra</span>(<span style=color:#66d9ef>int</span> start){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// inicialmente a distancia do vertice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// start para todo os outros √© infinita
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; u <span style=color:#f92672>&lt;=</span> n; u<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>		d[u] <span style=color:#f92672>=</span> oo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// fila de prioridade de pair&lt;ll, int&gt;, mas que o
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// menor pair fica no topo da fila
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// guardamos um pair &lt;distancia ate o vertice, vertice&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// assim o topo da fila sempre √© o vertice com menor distancia
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	priority_queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>ll, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>ll, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>		greater<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>ll, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	d[start] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	pq.emplace(d[start], start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ll dt, w;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> u, v;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>pq.empty()){
</span></span><span style=display:flex><span>		tie(dt, u) <span style=color:#f92672>=</span> pq.top(); pq.pop();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(dt <span style=color:#f92672>&gt;</span> d[u]) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> edge : g[u]){
</span></span><span style=display:flex><span>			tie(v, w) <span style=color:#f92672>=</span> edge;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// se a distancia ate o u somado com o peso
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// da aresta √© menor do que a distancia ate o v que
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// tinhamos antes, melhoramos a distancia ate o v
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span>(d[v] <span style=color:#f92672>&gt;</span> d[u] <span style=color:#f92672>+</span> w){
</span></span><span style=display:flex><span>				d[v] <span style=color:#f92672>=</span> d[u] <span style=color:#f92672>+</span> w;
</span></span><span style=display:flex><span>				pq.emplace(d[v], v);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// l√™ o input, qnt de vertices, arestas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// e vertice inicial(start)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	dijkstra(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; u <span style=color:#f92672>&lt;=</span> n; u<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>		printf(<span style=color:#e6db74>&#34;Distancia de %d para %d: %lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, start, u, d[u]);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Assim como no BFS, podemos facilmente adicionar um vetor indicando os predecessores de cada v√©rtice, dessa forma podemos obter n√£o s√≥ a informa√ß√£o dos custos, mas tamb√©m a sequ√™ncia de v√©rtices que a origina.</p><footer class=footline></footer></article></section><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 21</div><h1>Bitwise</h1><h2 id=representa√ß√£o-bin√°ria>Representa√ß√£o bin√°ria</h2><hr><p>Qualquer tipo de dado, seja um n√∫mero inteiro, n√∫mero racional ou um caracter, pode ser representado por bits.
Exemplos de representa√ß√£o bin√°ria de n√∫meros inteiros (sem sinal):<br><strong>1)</strong> 14 = {1110}2 = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 = 14.<br><strong>2)</strong> 20 = {10100}2 = 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 20.</p><h2 id=operadores-bit-a-bit>Operadores bit-a-bit</h2><hr><p><strong>NOT ( ~ )</strong>: Bitwise NOT √© um operador un√°rio que flipa os bits de um n√∫mero (se o bit √© 0, vira 1 e vice-versa). Bitwise NOT √© apenas o complemento de 1 de um n√∫mero.<br>N = 5 = (101)2<br>~N = ~5 = ~(101)2 = (010)2 = 2</p><p><strong>AND ( & )</strong>: Bitwise AND √© um operador bin√°rio que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posi√ß√£o comparada das palavras forem 1, ent√£o o valor do bit resultante nessa posi√ß√£o na palavra final ser√° 1, qualquer outro caso o bit resultante ser√° 0.
A = 5 = (101)2<br>B = 3 = (011)2<br>A & B = (101)2 & (011)2= (001)2 = 1</p><p><strong>OR ( | )</strong>: Bitwise OR, similarmente ao bitwise AND, √© um operador bin√°rio que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posi√ß√£o comparada forem 0, o valor do bit resultante nessa posi√ß√£o na palavra final ser√° 0, qualquer outro caso o bit resultante ser√° 1.<br>A = 5 = (101)2<br>B = 3 = (011)2<br>A | B = (101)2 | (011)2 = (111)2 = 7</p><p><strong>XOR ( ^ )</strong>: Bitwise XOR tamb√©m √© um operador bin√°rio que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posi√ß√£o comparada forem iguais (0 ou 1), o valor do bit resultante nessa posi√ß√£o na palavra final ser√° 0, se os bits forem diferentes (um 0 e outro 1), o bit resultante ser√° 1.<br>A = 5 = (101)2<br>B = 3 = (011)2<br>A ^ B = (101)2 ^ (011)2 = (110)2 = 6</p><p><strong>Left Shift ( &#171; )</strong>: Existem dois operadores de deslocamento (left shift e righr shift). O left shift operator √© um operador bin√°rio que desloca os bits de uma palavra X vezes para a esquerda e preenche a palavra com X 0s √† direita. <strong>Left shift de X bits em um n√∫mero inteiro √© equivalente a multuplic√°-lo por 2^X.</strong><br>1 &#171; 1 = 2<br>1 &#171; 2 = 4<br>2 &#171; 2 = {00010}2 &#171; 2 = {01000}2 = 8<br>1 &#171; n = 2^n</p><p><strong>Right Shift ( &#187; )</strong>: O right shift operator √© um operador bin√°rio que desloca os bits de uma palavra X vezes para a direita e preenche a palavra com X 0s √† esquerda. <strong>Right shift de X bits em um n√∫mero inteiro √© equivalente a dividi-lo por 2^X.</strong><br>4 &#187; 1 = 2<br>6 &#187; 1 = 3<br>5 &#187; 1 = 2<br>16 &#187; 4 = 1</p><h4 id=tabela-verdade>Tabela-verdade</h4><table><thead><tr><th>X</th><th>Y</th><th>X&amp;Y</th><th>X|Y</th><th>X^Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id=manipulando-bits>Manipulando bits</h2><hr><h4 id=checando-se-um-determinado-bit-est√°-ligado>Checando se um determinado bit est√° ligado</h4><p>Para checarmos de um jeito eficiente se o i-√©simo bit de um n√∫mero N est√° ligado, basta apenas checar se o AND de 2^i e N √© diferente de 0. Como vimos anteriormente, o n√∫mero 2^i √© simplesmente o n√∫mero 1 shiftado de i bits (1 &#171; i).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isSet</span>(<span style=color:#66d9ef>int</span> bitPosition, <span style=color:#66d9ef>int</span> number) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> ((number <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPosition)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=ligando-um-determinado-bit-em-um-n√∫mero>Ligando um determinado bit em um n√∫mero</h4><p>Para ligar o i-√©simo bit de um n√∫mero N, basta apenas fazermos o OR de 2^i com N.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>setBit</span>(<span style=color:#66d9ef>int</span> bitPosition, <span style=color:#66d9ef>int</span> number) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (number <span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPosition) );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=representando-conjunto-com-bits---bitmasks>Representando conjunto com bits - bitmasks</h2><hr><p>Suponha que tenhamos conjunto universo com 8 elementos, U = {a,b,c,d,e,f,g,h}.<br>Vamos associar cada elemento de U a um bit:</p><p>a -> bit 7<br>b -> bit 6<br>c -> bit 5<br>d -> bit 4<br>e -> bit 3<br>f -> bit 2<br>g -> bit 1<br>h -> bit 0</p><p>Com essa associa√ß√£o, podemos representar qualquer subconjunto de U como uma m√°scara de 8 bits. Exemplo:</p><table><thead><tr><th>Conjunto</th><th>Bitmask</th></tr></thead><tbody><tr><td>{b,c,f,h}</td><td>01100101</td></tr><tr><td>{a}</td><td>10000000</td></tr><tr><td>{}</td><td>00000000</td></tr></tbody></table><h4 id=adicionar-um-elemento-ao-conjunto>Adicionar um elemento ao conjunto</h4><p>Para adicionarmos um elemento a um conjunto que est√° representado como uma bitmask √© simples. Basta apenas setarmos o bit correspondente ao elemento na bitmask do conjunto.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>addElement</span>(<span style=color:#66d9ef>int</span> bitmask, <span style=color:#66d9ef>int</span> elementPosition) {
</span></span><span style=display:flex><span>  bitmask <span style=color:#f92672>=</span> bitmsak <span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> elementPosition);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> bitmask;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=checar-se-um-conjunto-contem-um-elemento>Checar se um conjunto contem um elemento</h4><p>Essa opera√ß√£o √© a mesma de checar se um dado bit est√° setado na bitmask.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasElement</span>(<span style=color:#66d9ef>int</span> bitmask, <span style=color:#66d9ef>int</span> elementPosition){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> ((bitmask <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> elementPosition)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=uni√£o-de-2-conjuntos>Uni√£o de 2 conjuntos</h4><p>Um elemento estar√° presente na uni√£o de 2 conjuntos se e somente se pelo menos um dos conjuntos contiver este elemento. Com base nisso e na tabela-verdade, podemos ver que a m√°scara que representa a uni√£o de duas m√°scaras √© o OR delas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>union</span>(<span style=color:#66d9ef>int</span> bitmaskA, <span style=color:#66d9ef>int</span> bitmaskB){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (bitmaskA <span style=color:#f92672>|</span> bitmaskB);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=interse√ß√£o-de-2-conjuntos>Interse√ß√£o de 2 conjuntos</h4><p>Um elemento estar√° presente na interse√ß√£o de 2 conjuntos se e somente se os 2 conjuntos contiverem este elemento. Logo, a m√°scara que representa a interse√ß√£o de duas m√°scaras √© o AND delas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>intersection</span>(<span style=color:#66d9ef>int</span> bitmaskA, <span style=color:#66d9ef>int</span> bitmaskB){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (bitmaskA <span style=color:#f92672>&amp;</span> bitmaskB);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=gerando-todos-os-subconjuntos-de-um-conjunto>Gerando todos os subconjuntos de um conjunto</h4><p>Suponha que voc√™ tenha um conjunto S = {p,q,r}.<br>Para formar um subconjunto de S, podemos escolher ou n√£o o elemento <strong>p</strong> (2 op√ß√µes), escolher ou n√£o o elemento <strong>q</strong> (2 op√ß√µes de novo) e escolher ou n√£o o elemento <strong>r</strong> (2 op√ß√µes novamente). Logo, podemos formar um subconjunto de S de 2*2*2 maneiras diferentes.
Um conjunto de N elementos possui 2^N subconjuntos. S possui 2^3 = 8 subconjuntos.</p><p>Ok, agora vamos representar cada elemento do conjunto S com um bit, como S tem 3 elementos, precisamos de 3 bits para isso:<br><strong>p</strong> = bit 2,<br><strong>q</strong> = bit 1,<br><strong>r</strong> = bit 0</p><p>Com esta associa√ß√£o de elementos e bits, podemos representar todos os subconjuntos de S como uma palavra de 3 bits. Veja:</p><p>0 = (000)2 = {}<br>1 = (001)2 = {r}<br>2 = (010)2 = {q}<br>3 = (011)2 = {q, r}<br>4 = (100)2 = {p}<br>5 = (101)2 = {p, r}<br>6 = (110)2 = {p, q}<br>7 = (111)2 = {p, q, r}</p><p>Como temos 2^N subconjuntos em um conjunto de N elementos, passando por todos os n√∫meros de [0, 2^N - 1] √© poss√≠vel representar todos os subconjuntos de um conjunto.<br>C√≥digo para printar todos os subconjuntos de um conjunto:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>possibleSubsets</span>(<span style=color:#66d9ef>char</span> S[], <span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> N); <span style=color:#f92672>++</span>i) {  <span style=color:#75715e>// i = [0, 2^N - 1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> N;<span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> j))  <span style=color:#75715e>// se o j-√©simo bit de i est√° setado, printamos S[j]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                cout <span style=color:#f92672>&lt;&lt;</span> S[j] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=default dir=ltr><h1>Matematica</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/matematica/modulo/>M√≥dulo</a></li><li><a href=/materiais/matematica/divisores/>Divisores</a></li><li><a href=/materiais/matematica/primos/>N√∫meros Primos</a></li><li><a href=/materiais/matematica/fatoracao/>Fatora√ß√£o</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de Matematica</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 23</div><h1>M√≥dulo</h1><p>Diversos problemas em ju√≠zes online (e competi√ß√µes) costumam pedir a resposta m√≥dulo algum primo alto (bastante comum 10^9 + 7). O motivo disso √© evitar overflow. Por exemplo: finja que voc√™ tem o seguinte problema:</p><p>Imprimir o resultado de 3^<code>x</code> (0 &lt;= <code>x</code> &lt;= 100), por exemplo. Esse resultado claramente excede 2^64 (limite de long long), ent√£o n√£o faz muito sentido pedir o resultado por si s√≥ (na verdade, alguns problemas realmente pedem coisas do tipo, nesses casos, o recomendado √© usar python, que n√£o tem overflow).</p><p>Ent√£o pedem o resultado m√≥dulo 10^9 + 7, ou algum primo muito alto, para que n√£o force as pessoas a usarem uma linguagem ou outra.</p><p>O motivo de ser um n√∫mero alto √© minimizar a chance de seu programa a computar a resposta errada (e por sorte ser igual em m√≥dulo a resposta correta) e o ju√≠z aceit√°-la.</p><p>O motivo de ser um n√∫mero primo √© que adicionam algumas propriedades a mais que podemos usar para calcular a resposta, como o inverso multiplicativo, mas n√£o abordaremos isso aqui.</p><p>As seguintes propriedades valem no c√°lculo do m√≥dulo:</p><p><code>(a + b) % c = ((a % c) + (b % c)) % c</code></p><p><code>(a * b) % c = ((a % c) * (b % c)) % c</code></p><p>O que isso quer dizer √© que se a resposta est√° sendo computada por meio de adi√ß√µes e multiplica√ß√µes, e no final voc√™ precisa tirar o m√≥dulo dela, voc√™ pode tirar m√≥dulo em todas as opera√ß√µes intermedi√°rias que isso n√£o afetar√° a resposta.</p><p>Ent√£o, por exemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>exp</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3ll</span> <span style=color:#f92672>*</span> exp(p<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>  scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, exp(n) <span style=color:#f92672>%</span> mod);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O c√≥digo acima gera overflow, a resposta vai estourar o limite de long long (j√° ter√° se tornado negativa) quando tirarmos o mod. No entanto, conceitualmente, ele est√° correto.</p><p>Ent√£o, usando as propriedades vistas em cima, podemos fazer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>exp</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (<span style=color:#ae81ff>3ll</span> <span style=color:#f92672>*</span> exp(p<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>  scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, exp(n));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>De forma que o c√≥digo acima imprime (3^n) % (1000000007), sem causar overflow.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 24</div><h1>Divisores</h1><p>Um problema recorrente √© o de encontrar divisores de um n√∫mero positivo. A maneira mais simples de resolv√™-lo seria passar por todos os n√∫meros e testar se o resto da divis√£o √© 0, ou seja, se √© divis√≠vel.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      ans.push_back(i);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>√© f√°cil ver que a complexidade do c√≥digo acima √© <code>O(n)</code>, podemos fazer melhor que isso com algumas observa√ß√µes.</p><p>Se <code>a</code> √© um divisor <code>n</code> ent√£o o resto da divis√£o de <code>n</code> por <code>a</code> √© 0 assim <code>b = n/a</code> √© um inteiro. Sabemos ent√£o que <code>a*b = n</code>, ou seja, <code>a = n/b</code> e assim <code>b</code> tamb√©m √© um divisor de <code>n</code>. Se fixarmos que <code>a &lt;= b</code>, qual o valor m√°ximo de <code>a</code>? Como <code>a</code> √© no m√°ximo <code>b</code>, consideremos o caso em que <code>a = b</code> temos que <code>a*a = n</code>, ou seja, <code>a = sqrt(n)</code>.</p><p>Agora √© possivel modificar o c√≥digo passando por todos os valores poss√≠veis de <code>a</code> e computar o respectivo <code>b</code> para encontrar todos os divisores.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// compara√ß√£o que evita o uso de doubles, a &lt;= sqrt(n) √© o mesmo que a*a &lt;= n, ja que a e n sao positivos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> a;
</span></span><span style=display:flex><span>      ans.push_back(a);
</span></span><span style=display:flex><span>      ans.push_back(b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sort(ans.begin(), ans.end()); <span style=color:#75715e>// frescura para retornar os divisores ordenados como na primeira implementa√ß√£o
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>S√≥ h√° um problema com a implementa√ß√£o acima. Assumimos que <code>a &lt;= b</code>, caso <code>a = b</code> inserimos o divisor 2 vezes na resposta, por exemplo, para 36 podemos ter <code>a = 6</code> e <code>b = 6</code>. Assim a vers√£o final do c√≥digo fica:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// compara√ß√£o que evita o uso de doubles, a &lt;= sqrt(n) √© o mesmo que a*a &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> a;
</span></span><span style=display:flex><span>      ans.push_back(a);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(a <span style=color:#f92672>!=</span> b) ans.push_back(b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sort(ans.begin(), ans.end()); <span style=color:#75715e>// frescura para retornar os divisores ordenados como na primeira implementa√ß√£o
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>com complexidade <code>O(sqrt(n))</code>.</p><h3 id=observa√ß√µes>Observa√ß√µes</h3><p>Um n√∫mero primo tem somente dois divisores positivos, assim podemos checar se um numero <code>x</code> √© primo usando <code>all_divisors(x).size() == 2</code> ou modificando um pouco a rotina e ter uma melhor constante na complexidade</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> is_prime(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// compara√ß√£o que evita o uso de doubles, a &lt;= sqrt(n) √© o mesmo que a*a &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=passar-por-todos-os-m√∫ltiplos-de-x-at√©-n>Passar por todos os m√∫ltiplos de x at√© N</h2><p>Consideramos multiplos de <code>x</code> os n√∫meros: <code>x, 2*x, 3*x, 4*x, ...</code> ou, escrevendo de outra forma, <code>x, x+x, x+x+x, x+x+x+x, ...</code></p><p>Caso queiramos fazer algo com todos os m√∫ltiplos de <code>x</code> at√© um limite <code>N</code> podemos usar a simples rotina</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) { <span style=color:#75715e>// m √© sempre multiplo de x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Que √© executada em <code>O(N/x)</code>.</p><h2 id=passar-por-todos-os-m√∫ltiplos-de-todos-os-n√∫meros-at√©-n>Passar por todos os m√∫ltiplos de todos os n√∫meros at√© N</h2><p>Se passarmos por todos os n√∫meros <code>x</code> entre 1 e <code>N</code> e para cada um deles achar todos os m√∫ltiplos <code>m</code>.</p><p>O c√≥digo ficaria algo como</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) { <span style=color:#75715e>// m √© sempre multiplo de x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O c√≥digo acima parece ser executado em <code>O(N^2)</code>, mas podemos definir uma cota bem menor, com algumas observa√ß√µes. O c√≥digo √© executado em <code>N/1 + N/2 + ... + N/(N-1) + N/N</code> passos. Podemos botar o <code>N</code> em evidencia <code>N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N)</code>. A soma dentro dos parenteses √© menor que a √°rea abaixo da curva da fun√ß√£o <code>1/x</code>, a integral √© <code>ln(x)</code>(mas relaxa que n√£o precisa lembrar das coisas de c√°lculo 1). Portanto <code>O(N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N)) = O(N*lg N)</code>.</p><p>Podemos resolver v√°rios problemas usando isso pois <code>x</code> ser√° divisor de <code>m</code> e assim para todo <code>m</code> tamb√©m passaremos por todos os divisores deles.</p><h2 id=contando-os-divisores-de-v√°rios-n√∫meros>Contando os divisores de v√°rios n√∫meros</h2><p>Por exemplo, usando essa abordagem, poder√≠amos usar esses 2 la√ßos aninhados para gerar um vetor <code>div</code> que informa quantos divisores todos os n√∫meros at√© <code>n</code> tem.</p><p>Perceba que esses dois la√ßos executam em <code>O(n * log n)</code>, enquanto repetir o algoritmo de contar os divisores de cada n√∫mero individualmente teria complexidade <code>sqrt(1) + sqrt(2) + ... + sqrt(n)</code> = O(n * sqrt(n)), ou seja, tem complexidade melhor.</p><p>A abordagem abaixo funciona porque sempre que chegamos em um n√∫mero <code>m</code> no la√ßo mais interno, significa que temos um divisor a mais.</p><p>Na primeira itera√ß√£o passamos por todos os n√∫meros, j√° que come√ßamos e 1 e estamos incrementando de 1 em 1, todos os n√∫meros s√£o divis√≠veis por 1, ent√£o todos ganham um divisor a mais no vetor.</p><p>Na segunda itera√ß√£o, passamos apenas pelos n√∫meros m√∫ltiplos de 2, em todos os n√∫meros que chegarmos, significa que esse n√∫mero √© divis√≠vel por 2 (ou seja, sabemos que ele tem um divisor a mais). E repetimos esse racioc√≠nio para todos os n√∫meros.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> computa_divisores(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> qnt_div(N, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) {
</span></span><span style=display:flex><span>      qnt_div[m]<span style=color:#f92672>++</span>; <span style=color:#75715e>// aqui descobrimos que x √© divisor de m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> qnt_div;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 25</div><h1>N√∫meros Primos</h1><p>Em particular, sabendo a quantidade de divisores de cada n√∫mero, podemos varrer esse vetor vendo quais n√∫meros s√£o primos (tem 2 divisores).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos_ate_n(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(qnt_div[x] <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>      primos.push_back(x);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> primos;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=crivo-de-erast√≥tenes>Crivo de erast√≥tenes</h2><p>A abordagem acima tem uma complexidade aceit√°vel, e passaria no tempo para a maioria dos problemas. No entanto, existe um algoritmo com uma ideia semelhante, mas que com algumas observa√ß√µes baixa essa complexidade de <code>O(n * log n)</code> para <code>O(n * log( log n))</code>. O log j√° abaixa muito um n√∫mero, se aplicamos ele novamente, abaixamos mais ainda, ou seja, isso √© quase linear.</p><p>A ideia usada √© marcar inicialmente todos os n√∫meros entre 1 e <code>N</code> como possiveis primos. Passando em ordem crescente e quando encontramos um primo marcamos os m√∫ltiplos do primo como n√£o primos.</p><h3 id=visualiza√ß√£o>Visualiza√ß√£o</h3><p><img src=https://i.pinimg.com/originals/24/69/79/246979fd8d7bdf29a95cdb2e08cd2e89.gif alt=Crivo></p><h3 id=implementa√ß√£o>Implementa√ß√£o</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos_ate_n(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> marcacao(N, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 1 = possivel primo, 0 = com certeza n√£o primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) <span style=color:#66d9ef>if</span>(marcacao[x] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    primos.push_back(x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x<span style=color:#f92672>+</span>x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) {
</span></span><span style=display:flex><span>      marcacao[m] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// aqui descobrimos que m n√£o √© primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> primos;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 26</div><h1>Fatora√ß√£o</h1><p>Aprendemos na escola que todo n√∫mero √© composto por fatores primos, existindo uma √∫nica fatora√ß√£o pra cada n√∫mero.</p><p>Uma primeira abordagem poss√≠vel seria passar por todos os n√∫meros e ir dividindo sempre que poss√≠vel.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// retorna vetor de pair&lt;primo, expoente&gt; da fatora√ß√£o
</span></span></span><span style=display:flex><span><span style=color:#75715e>// fatora(36) = [{2, 2}, {3, 2}] ou seja, 36 = 2^2 + 3^2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; p <span style=color:#f92672>&lt;=</span> n; p<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> expoente <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> p;
</span></span><span style=display:flex><span>        expoente<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ans.emplace_back(p, expoente);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A primeira vista,como queremos decompor em fatores primos, parece que temos que testar se <code>p</code> √© primo. Entretanto passamos por <code>p</code> de forma crescente e sempre que podemos dividimos <code>n</code> por <code>p</code> ent√£o a condi√ß√£o <code>(n % p == 0)</code> s√≥ ser√° verdade para <code>p</code> primos.</p><p>Isso ocorre porque todos os fatores primos de um n√∫mero s√£o menores ou iguais a ele pr√≥prio, ent√£o quando chegamos em um n√∫mero, √© imposs√≠vel que ele divida o n√∫mero e n√£o seja primo, pois se n√£o for, os n√∫meros primos que o compoem deveriam ter sido contabilizados numa itera√ß√£o anterior.</p><p>Apesar do c√≥digo acima rodar bem para v√°rios exemplos, no pior caso <code>n</code> √© primo e o c√≥digo √© executado em <code>O(n)</code>.</p><p>Podemos melhorar a complexidade com uma simples observa√ß√£o. √â possivel ter <strong>apenas</strong> um primo maior que a <code>sqrt(n)</code>, por exemplo, 10 tem 5 como fator e <code>5 > sqrt(10)</code>, mas √© imposs√≠vel ter dois primos maiores que a raiz. Se tivermos <code>a > sqrt(n)</code> e <code>b > sqrt(n)</code>, quando multiplicamos temos que <code>a * b > sqrt(n) * sqrt(n)</code> e <code>a * b > n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; p<span style=color:#f92672>*</span>p <span style=color:#f92672>&lt;=</span> n; p<span style=color:#f92672>++</span>) { <span style=color:#75715e>// compara√ß√£o que evita o uso de doubles, p &lt;= sqrt(n) √© o mesmo que p*p &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> expoente <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> p;
</span></span><span style=display:flex><span>        expoente<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ans.emplace_back(p, expoente);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) ans.emplace_back(n, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=fatora√ß√£o-em-olg-n-para-n√∫meros-at√©-n>Fatora√ß√£o em O(lg n) para n√∫meros at√© N</h2><p>√â poss√≠vel fatorar n√∫meros ate um limite <code>N</code> em <code>O(lg n)</code> ap√≥s preprocessamento <code>O(n log( log n))</code>. O que fazemos √© uma pequena modifica√ß√£o no c√≥digo do crivo, para que enquanto fazemos o crivo, preenchamos um vetor auxiliar <code>lp</code>, aonde <code>lp[x]</code> representa o maior n√∫mero primo que divide <code>x</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lp(N, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(lp[x] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) { <span style=color:#75715e>// se x nao foi marcado antes, √© primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) <span style=color:#75715e>// todos os multiplos de i
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      lp[m] <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>Tendo este vetor podemos fatorar um numero <code>x</code> com o seguinte procedimento.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>  map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> expoentes;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>(x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    expoentes[ lp[x] ]<span style=color:#f92672>++</span>; <span style=color:#75715e>// aumentamos o expoente do primo lp[x] em 1 na resposta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    x <span style=color:#f92672>/=</span> lp[x];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p : expoentes)
</span></span><span style=display:flex><span>    ans.emplace_back(p);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade do procedimento acima √© <code>O(quantidade de fatores)</code>, que √© limitado por <code>O(lg n)</code>, da para ver que no pior caso todos os fatores s√£o 2(menor primo) e a complexidade √© o <code>k</code> de <code>2^k = n</code>.</p><h2 id=n√∫mero-de-divisores-dada-uma-fatora√ß√£o>N√∫mero de divisores dada uma fatora√ß√£o</h2><p>Vimos que todo inteiro N pode ser escrito de forma √∫nica como multiplica√ß√£o de n√∫meros primos. Assim,</p><span class="math align-center">$$N = {p_1}^{e_1}.{p_2}^{e_2}.{p_3}^{e_3}.{p_4}^{e_4}.{p_5}^{e_5}.{p_6}^{e_6} ... $$</span><p>onde pi √© primo e 0 ei > 0.</p><p>Todo divisor de N s√≥ pode ter primos que aparecem na fatora√ß√£o de N e expoente no m√°ximo o do expoente no N. Por exemplo:
<span class="math align-center">$$36 = 2^2.3^2$$</span></p><span class="math align-left">$$1 = 2^0.3^0$$</span>
<span class="math align-left">$$2 = 2^1.3^0$$</span>
<span class="math align-left">$$3 = 2^0.3^1$$</span>
<span class="math align-left">$$4 = 2^2.3^0$$</span>
<span class="math align-left">$$6 = 2^1.3^1$$</span>
<span class="math align-left">$$9 = 2^0.3^2$$</span>
<span class="math align-left">$$12 = 2^2.3^1$$</span>
<span class="math align-left">$$18 = 2^1.3^2$$</span>
<span class="math align-left">$$36 = 2^2.3^2$$</span><p>Para construir um divisor podemos escolher dentre (ei+1) possibilidades para o primo pi. O n√∫mero total de divisores √© a multiplica√ß√£o desses termos. Assim 36 tem (2+1)*(2+1) = 9 divisores.</p><p>Embora esta ideia n√£o melhore a complexidade para encontrar o n√∫mero de divisores em compara√ß√£o com as ideias anteriores, ela pode ser uma ferramenta √∫til para analisar problemas. Por exemplo, os n√∫meros com exatamente 9 divisores s√£o da forma</p><span class="math align-left">$${p_1}^8={p_1}^2.{p_2}^2$$</span><p>Como por exemplo:</p><span class="math align-left">$$256 = 2^8$$</span>
<span class="math align-left">$$6561 = 3^8$$</span>
<span class="math align-left">$$36 = 2^2.3^2$$</span>
<span class="math align-left">$$100 = 2^2.5^2$$</span>
<span class="math align-left">$$255 = 3^2.5^2$$</span><p>etc&mldr;</p><footer class=footline></footer></article></section><article class=default dir=ltr><h1>T√≥picos Avan√ßados</h1><h2 id=subp√°ginas>Subp√°ginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/avancados/lca/>Lowest Common Ancestor</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsec√ß√µes de T√≥picos Avan√ßados</h1><article class=chapter dir=ltr><div class=article-subheading>Cap√≠tulo 27</div><h1>Lowest Common Ancestor</h1><p>Lowest Common ancestor (LCA) - ou ancestral comum mais baixo, √© o nome t√≠pico dado para o seguinte problema: dado uma √Årvore cuja raiz √© um v√©rtice arbitr√°rio <code>e</code> dois v√©rtices <code>u,v</code> que a pertencem, diga qual √© o n√≥ mais baixo(relativo a raiz) que √© ancestral de <code>u,v</code>.</p><p><img src=https://i.imgur.com/OuGPlXf.png alt=a title=a></p><p>Por exemplo na imagem a cima, o LCA de 2 e 3 √© 1, o LCA de 6 e 7 √© 0, e o LCA de 1 e 2 √© 1.</p><p>um jeito naive de se fazer isso seria o seguinte, para cada n√≥ da √°rvore, pr√©-processamos sua profundidade com rela√ß√£o a raiz (raiz tem profundidade 0, filhos 1, e assim por diante). Agora, para determinarmos os LCA de dois v√©rtices <code>u,v</code>, podemos fazer o seguinte procedimento. Escolhemos qual dos dois v√©rtices est√° mais profundo, subimos nos seus pais at√© igualar as alturas de ambos, e ap√≥s isso, vamos subindo em ambos os caminhos um a um at√© que os caminhos se encontrem, ent√£o saberemos o LCA.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> depth[<span style=color:#ae81ff>100005</span>];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[<span style=color:#ae81ff>100005</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pre_process_depth</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>	depth[u] <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> adj : graph[u]) {
</span></span><span style=display:flex><span>		pre_process_depth(adj, d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>slow_lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) {
</span></span><span style=display:flex><span>		swap(u, v);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(depth[u] <span style=color:#f92672>&gt;</span> depth[v]) {
</span></span><span style=display:flex><span>		u <span style=color:#f92672>=</span> pai[u];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(u <span style=color:#f92672>!=</span> v) {
</span></span><span style=display:flex><span>		u <span style=color:#f92672>=</span> pai[u];
</span></span><span style=display:flex><span>		v <span style=color:#f92672>=</span> pai[v];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essa estrat√©gia efetivamente funciona, ent√£o ter√≠amos um pr√©-processamento que √© um DFS e ap√≥s isso conseguir√≠amos responder queries em <code>O(n)</code>, pois numa √°rvore com um ramo muito profundo ter√≠amos no pior caso que subir todos os v√©rtices, portando complexidade total de <code>O(n + Qn) = O(Qn)</code> onde <code>Q</code> √© o n√∫mero de queries e <code>n</code> a quantidade de n√≥s na √°rvore.</p><p>O LCA √© relevante porque como em uma √°rvore h√° um √∫nico caminho que liga dois v√©rtices, se conseguimos obter o LCA r√°pido ent√£o uma das coisas que j√° ganhamos de quebra √© conseguir responder as dist√¢ncias entre quaisquer par de v√©rtices.</p><p>A dist√¢ncia vai ser a dist√¢ncia de um v√©rtice para o LCA e do LCA para o outro, sendo que essas duas dist√¢ncias intermedi√°rias s√£o apenas a diferen√ßa de alturas na √°rvore.</p><p>Aqui nesse tutorial vamos mostrar duas ideias para computar LCA, uma que vai nos permitir responder Queries de LCA em <code>O(log n)</code> com preprocessamento <code>O(n log n)</code> e uma segunda abordagem que vai nos permitir responder queries de LCA em <code>O(1)</code> (isso mesmo, tempo constante!) com preprocessamento <code>O(n log n)</code> tamb√©m.</p><p>Apesar de a complexidade da segunda abordagem para responder queries de LCA ser estritamente melhor que da primeira, veremos que a primeira carrega um pouco mais de informa√ß√£o, permitindo obter algumas outras informa√ß√µes fora o LCA, enquanto na segunda podemos obter apenas o LCA.</p><h1 id=abordagem-1>Abordagem 1</h1><p>O problema da solu√ß√£o naive √© essa subida de um em um at√© que atinjamos o pai comum. Ent√£o faz sentido tentarmos atacarmos isso para ganhar um desempenho assint√≥tico melhor. Uma coisa a se observar √© que estamos fazendo duas buscas lineares. A primeira busca linear √© pelo primeiro ancestral de <code>u</code> que iguala a altura a <code>v</code> e ap√≥s isso outra busca linear para procurar o primeiro ancestral de ambos que √© comum.</p><p>Podemos observar que h√° monotonicidade nessas buscas lineares, at√© certo ponto os ancestrais n√£o satisfazem uma condi√ß√£o, e ap√≥s certo ponto todos satisfazem. Na primeira estar√≠amos buscando o ancestral mais baixo de <code>u</code> que satisfaz a condi√ß√£o &ldquo;Ter altura menor ou igual a v&rdquo;, e na segunda &ldquo;Ser ancestral de <code>v</code>&rdquo;.</p><p>Aqui usaremos o conceito de &ldquo;k-√©simo pai&rdquo; que funciona assim: o primeiro pai √© o pai do v√©rtice, o segundo pai √© o pai do pai do v√©rtice, e assim por diante.</p><p>Se n√≥s tiv√©ssemos uma fun√ß√£o <em>m√°gica</em> chamada por exemplo <code>climb(n,k)</code> que nos retornasse o k-√©simo pai do v√©rtice <code>n</code>, poder√≠amos ent√£o usar buscas bin√°rias na quantidade de v√©rtices a subir para resolver esse problema, e restaria implementar essa fun√ß√£o de maneira eficiente. Vamos seguir por essa linha de racioc√≠nio ent√£o.</p><h2 id=o-pulo-do-gato>O pulo do gato</h2><p>Se n√≥s tiv√©ssemos uma outra fun√ß√£o <code>m√°gica</code> chamada <code>p2k(n,k)</code> que retorna o (2^k)-√©simo pai de um v√©rtice <code>n</code>, poder√≠amos implementar a fun√ß√£o que sobe <code>k</code> v√©rtices da seguinte maneira. Se nosso grafo tem tamanho menor que <code>10^6</code>, sabemos que n√£o precisamos subir mais do que <code>2^20</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>climb</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&gt;=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i)) {
</span></span><span style=display:flex><span>			node <span style=color:#f92672>=</span> p2k(node,i);
</span></span><span style=display:flex><span>			k <span style=color:#f92672>-=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade dessa fun√ß√£o depende do n√∫mero que colocamos no for, que n√£o precisa ser maior do que o <code>log</code> do tamanho do grafo(n√£o faz sentido subir mais n√≥s do que o grafo possui), ent√£o conseguimos obter o k-√©simo ancestral de um v√©rtice arbitr√°rio em complexidade <code>O(log) * X</code> aonde X √© a complexidade de p2k.</p><p>Mostramos agora que podemos preprocessar todos os valores poss√≠veis de p2k em <code>O(n log n)</code>. Precisamos saber os valores dos ancestrais para todos os <code>n</code> v√©rtices e para cada v√©rtice s√≥ faz sentido saber <code>log</code> ancestrais. Podemos obter todos os valores de uma vez usando programa√ß√£o din√¢mica, com uma recorr√™ncia muito elegante.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>p2k</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> p2k(p2k(node, k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=vers√£o-recursiva>Vers√£o recursiva</h3><p>Usamos ent√£o memoiza√ß√£o para computarmos cada estado em <code>O(1)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> memo[SIZE][log2(GRAPHSIZE)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>p2k</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(memo[node][k] <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> memo[node][k];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> memo[node][k] <span style=color:#f92672>=</span> p2k(p2k(node, k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=vers√£o-iterativa>Vers√£o iterativa</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> p2k[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	p2k[node][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pai[node];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		p2k[node][k] <span style=color:#f92672>=</span> p2k[p2k[node][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Dessa forma ent√£o temos o seguinte procedimento para acharmos o LCA, fazemos uma busca bin√°ria, em cada itera√ß√£o obtemos o k-√©simo ancestral, e checamos se ele satisfaz as propriedades, tendo ent√£o complexidade <code>O(log n * log n) = O(log^2 n)</code>, j√° que fazemos <code>log</code> itera√ß√µes e em cada itera√ß√£o demoramos <code>log</code> para obter o k-√©simo ancestral. Isso funciona, mas podemos melhorar um pouco mais.</p><p>Ao inv√©s de usarmos busca bin√°ria vamos usar uma t√©cnica conhecida como <code>binary lifting</code> ou escalada bin√°ria, basicamente vamos percorrer bit a bit vendo se esse bit est√° na resposta ou n√£o.</p><p>A ideia √© a seguinte, vamos supor que a resposta da busca bin√°ria de o quanto eu tenho que subir a partir de um v√©rtice para satisfazer uma propriedade seja 6(o primeiro ancestral que satisfaz a propriedade √© o sexto pai). Podemos usar escala bin√°ria para procurar pelo √∫ltimo v√©rtice que ainda n√£o satisfaz a propriedade (no caso ent√£o seria o 5).</p><p>Usando nossa fun√ß√£o p2k, podemos come√ßar vendo se o oitavo pai j√° satisfaz a propriedade e sim satisfaz, ent√£o como estamos buscando o √∫ltimo que ainda satisfaz, n√£o subimos para o oitavo pai. Depois verificamos que o quarto pai que ainda n√£o satisfaz, ent√£o subimos para ele. Depois verificamos o segundo pai do quarto pai, isto √©, o sexto pai do v√©rtice original, que j√° satisfaz, ent√£o n√£o subimos para ele, e por √∫ltimo, verificamos o pai do quarto pai (quinto pai do v√©rtice original), que n√£o satisfaz, ent√£o subimos pra ele e sabemos o √∫ltimo v√©rtice que ainda n√£o satisfaz a propriedade.</p><p>A escalada bin√°ria pode ser usada nas mesmas situa√ß√µes aonde a busca bin√°ria pode ser usada, mas algumas vezes (como essa), podemos obter uma complexidades assint√≥ticas melhores.</p><p>Cada checagem para ver se um dos (2^k)-√©simos pais satisfazem a propriedade √© constante, e checamos os pais <code>(2^k), 2^(k-1), 2^(k-2),..., 1</code> sempre dividindo por 2, ent√£o passamos por no m√°ximo <code>log</code> vezes nessa checagem, portanto com essa ideia podemos obter o <code>lca</code> em <code>O(log n)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) swap(u,v);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(depth[p2k[u][i]] <span style=color:#f92672>&gt;=</span> depth[v])
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(u <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(p2k[v][i] <span style=color:#f92672>!=</span> p2k[u][i]) {
</span></span><span style=display:flex><span>			v <span style=color:#f92672>=</span> p2k[v][i];
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pai[v];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Perceba que estamos fazendo exatamente a ideia primeiramente apresentada na solu√ß√£o naive. Primeiro pegamos o v√©rtice que est√° mais embaixo e subimos ele at√© o n√≠vel do outro, e ap√≥s isso, subimos em ambos os v√©rtices procurando o primeiro ancestral comum, mas em vez de fazermos busca linear, fazemos escalada bin√°ria.</p><p>A escala bin√°ria desempenha melhor nessa situa√ß√£o(em rela√ß√£o a busca bin√°ria) porque quando vamos construir o (n-√©simo) pai para fazer a checagem (somando v√°rios (2^k)-√©simos pais) na busca bin√°ria, estar√≠amos colocando os mesmos v√©rtices todas as vezes, por exemplo, tome o exemplo aonde o √∫ltimo v√©rtice que satisfaz uma propridade √© o 26.</p><pre tabindex=0><code>l = 0, r = 32, mid = 16(16), checagem passa.
l = 16, r = 32, mid = 24(16 + 8), checagem passa.
l = 24, r = 32, mid = 28(16 + 8 + 4), checagem falha
l = 24, r = 28, mid = 26(16 + 8 + 2), checagem passa
l = 26, r = 28, mid = 27(16 + 8 + 2 + 1), checagem falha
</code></pre><p>Quando a checagem passou para mid = 16, pod√≠amos ter certeza que tinhamos que subir pelo menos at√© o d√©cimo sexto pai, mas a√≠ nos checks subsequentes perdemos tempo reconstruindo a resposta que j√° conhecemos. Ent√£o o que a escala bin√°ria faz √© tomar vantagem disso.</p><h3 id=vers√£o-final-do-c√≥digo>Vers√£o final do c√≥digo</h3><p>Agora como mencionado podemos obter rapidamente a dist√¢ncia entre quaisquer 2 n√≥s na √°rvore.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dist</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> depth[u] <span style=color:#f92672>+</span> depth[v] <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>depth[lca(u,v)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=vers√£o-final-do-c√≥digo-1>Vers√£o final do c√≥digo</h3><p>Apesar de n√£o fazermos a busca bin√°ria que usava a fun√ß√£o climb no final, √© poss√≠vel que essa implementa√ß√£o seja √∫til em alguns problemas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> depth[SIZE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pre_process_depth</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>	depth[u] <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> adj : graph[u]) {
</span></span><span style=display:flex><span>		pre_process_depth(adj, d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> p2k[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) swap(u,v);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(depth[p2k[u][i]] <span style=color:#f92672>&gt;=</span> depth[v])
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(u <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(p2k[v][i] <span style=color:#f92672>!=</span> p2k[u][i]) {
</span></span><span style=display:flex><span>			v <span style=color:#f92672>=</span> p2k[v][i];
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pai[v];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>climb</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&gt;=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i)) {
</span></span><span style=display:flex><span>			node <span style=color:#f92672>=</span> p2k[node][i];
</span></span><span style=display:flex><span>			k <span style=color:#f92672>-=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dist</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> depth[u] <span style=color:#f92672>+</span> depth[v] <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>depth[lca(u,v)];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// codigo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// le os pais e monta o grafo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pai[raiz] <span style=color:#f92672>=</span> raiz;
</span></span><span style=display:flex><span>	pre_proccess_depth(raiz); <span style=color:#75715e>// tipicamente qual vertice √© a raiz nao importa
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>		p2k[node][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>			p2k[node][k] <span style=color:#f92672>=</span> p2k[p2k[node][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// resolve problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=conclus√£o>Conclus√£o</h3><p>Com essa abordagem, com preprocessamento <code>O(n log n)</code>, podemos responder queries de LCA (e climb, e dist) em <code>O(log n)</code>, al√©m disso, podemos modificar a DP do LCA para guardar mais informa√ß√µes al√©m de qual o (2^k)-√©simo pai, por exemplo a aresta m√≠nima(ou m√°xima) nesse caminho, a soma dos custos das arestas(caso hajam pesos), m√°ximo divisor comum, etc.</p><h2 id=abordagem-2>Abordagem 2</h2><p>A segunda abordagem usa uma ideia diferente, mas que tamb√©m √© muito top. Com preprocessamento <code>O(n log n)</code> podemos fazer queries de LCA em <code>O(1)</code>. Parando pra pensar nisso, √© muito poderoso, n√£o importa o quanto seja o tamanho do grafo, teremos a resposta em tempo constante! A ideia para atingir essa complexidade √© a seguinte. Sabemos que usando uma Sparse Table(Vide aula de Sparse Table) podemos resolver problemas de RMQ (range minimum query) em <code>O(1)</code>, com preprocessamento <code>O(n log n)</code> a ideia √© construir um vetor de forma que a RMQ nele representa a query de LCA.</p><h2 id=materiais-complementares>Materiais complementares</h2><p><a href="https://www.youtube.com/watch?v=EKcQt-74bNw">https://www.youtube.com/watch?v=EKcQt-74bNw</a></p><h2 id=exerc√≠cios-recomendados>Exerc√≠cios recomendados</h2><ul><li><a href=https://codeforces.com/problemset/problem/208/e>https://codeforces.com/problemset/problem/208/e</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2470>https://www.urionlinejudge.com.br/judge/pt/problems/view/2470</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1135>https://www.urionlinejudge.com.br/judge/pt/problems/view/1135</a></li><li><a href=https://www.spoj.com/problems/QTREE2/>https://www.spoj.com/problems/QTREE2/</a> - queries de distancia e obter k-√©simo v√©rtice no caminho, S√≥ da pra obter k√©simo v√©rtice com LCA log.</li></ul><footer class=footline></footer></article></section></section></section></div></main></div><aside id=sidebar class="default-animation showVisitedLinks"><div id=header-wrapper class=default-animation><div id=header class=default-animation><img src=/images/logo.png alt=UnBalloon></div><div class="searchbox default-animation"><label class=a11y-only for=search-by>Procurar</label>
<i class="fas fa-search"></i>
<input data-search-input id=search-by type=search placeholder=Procurar...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["pt"]</script><script src=/js/auto-complete.js?1682184136 defer></script>
<script src=/js/lunr.min.js?1682184136 defer></script>
<script src=/js/lunr.stemmer.support.min.js?1682184136 defer></script>
<script src=/js/lunr.multi.min.js?1682184136 defer></script>
<script src=/js/lunr.pt.min.js?1682184136 defer></script>
<script src=/js/search.js?1682184136 defer></script></div><div id=homelinks class=default-animation><ul><li><a class=padding href=/><i class='fas fa-home'></i> In√≠cio</a></li></ul></div><div id=content-wrapper class=highlightable><ul class="topics collapsible-menu"><li data-nav-id=/sobre/ class="dd-item alwaysopen"><input type=checkbox id=section-6ddbbbfc94aba0359e47bedbb5c0bf1e aria-controls=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e class=toggle checked><label class="a11y-only toggle" for=section-6ddbbbfc94aba0359e47bedbb5c0bf1e>Submenu Sobre</label><a href=/sobre/>Sobre<i class="fas fa-check read-icon"></i></a><ul id=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e><li data-nav-id=/sobre/dicas/ class=dd-item><a href=/sobre/dicas/>Dicas para Iniciantes<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/unb/ class=dd-item><a href=/sobre/unb/>UnB na Competitiva<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/eventos/ class=dd-item><a href=/sobre/eventos/>Eventos Anteriores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/competicoes/ class=dd-item><a href=/sobre/competicoes/>Competi√ß√µes<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/referencias/ class=dd-item><a href=/sobre/referencias/>Refer√™ncias<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/ class="dd-item alwaysopen"><input type=checkbox id=section-cd3c658ea9d6611734f640a99ed351e7 aria-controls=subsections-cd3c658ea9d6611734f640a99ed351e7 class=toggle checked><label class="a11y-only toggle" for=section-cd3c658ea9d6611734f640a99ed351e7>Submenu Materiais</label><a href=/materiais/>Materiais<i class="fas fa-check read-icon"></i></a><ul id=subsections-cd3c658ea9d6611734f640a99ed351e7><li data-nav-id=/materiais/fundamentos/ class=dd-item><input type=checkbox id=section-fbd8681c1cd813fd274363752298e387 aria-controls=subsections-fbd8681c1cd813fd274363752298e387 class=toggle><label class="a11y-only toggle" for=section-fbd8681c1cd813fd274363752298e387>Submenu Fundamentos do C++</label><a href=/materiais/fundamentos/>Fundamentos do C++<i class="fas fa-check read-icon"></i></a><ul id=subsections-fbd8681c1cd813fd274363752298e387><li data-nav-id=/materiais/fundamentos/complexidade/ class=dd-item><a href=/materiais/fundamentos/complexidade/>Complexidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/input-output/ class=dd-item><a href=/materiais/fundamentos/input-output/>Entrada/Sa√≠da<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/ class=dd-item><input type=checkbox id=section-a42839fe6a6dc82d6acb542625c12ea3 aria-controls=subsections-a42839fe6a6dc82d6acb542625c12ea3 class=toggle><label class="a11y-only toggle" for=section-a42839fe6a6dc82d6acb542625c12ea3>Submenu Declara√ß√µes</label><a href=/materiais/fundamentos/declaracoes/>Declara√ß√µes<i class="fas fa-check read-icon"></i></a><ul id=subsections-a42839fe6a6dc82d6acb542625c12ea3><li data-nav-id=/materiais/fundamentos/declaracoes/string/ class=dd-item><a href=/materiais/fundamentos/declaracoes/string/>Strings<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/vector/ class=dd-item><a href=/materiais/fundamentos/declaracoes/vector/>Vector<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/pair/ class=dd-item><a href=/materiais/fundamentos/declaracoes/pair/>Pairs<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/iterators/ class=dd-item><a href=/materiais/fundamentos/declaracoes/iterators/>Iterators<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ class=dd-item><input type=checkbox id=section-0f35d6b01e259d59953ce71b0a1b869a aria-controls=subsections-0f35d6b01e259d59953ce71b0a1b869a class=toggle><label class="a11y-only toggle" for=section-0f35d6b01e259d59953ce71b0a1b869a>Submenu Estrutura de Dados</label><a href=/materiais/fundamentos/eds/>Estrutura de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-0f35d6b01e259d59953ce71b0a1b869a><li data-nav-id=/materiais/fundamentos/eds/ed_linear/ class=dd-item><input type=checkbox id=section-647945f1e1a23f4847ff7712e174196b aria-controls=subsections-647945f1e1a23f4847ff7712e174196b class=toggle><label class="a11y-only toggle" for=section-647945f1e1a23f4847ff7712e174196b>Submenu ED Linear</label><a href=/materiais/fundamentos/eds/ed_linear/>ED Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-647945f1e1a23f4847ff7712e174196b><li data-nav-id=/materiais/fundamentos/eds/ed_linear/pilha/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/pilha/>Pilha<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila/>Fila<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila_prioridade/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila_prioridade/>Fila de Prioridade<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/ class=dd-item><input type=checkbox id=section-b42c90bc6b6a5f5588c9a9bab5cef1a6 aria-controls=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6 class=toggle><label class="a11y-only toggle" for=section-b42c90bc6b6a5f5588c9a9bab5cef1a6>Submenu ED N√£o Linear</label><a href=/materiais/fundamentos/eds/ed_n_linear/>ED N√£o Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/map/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/map/>Map<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/set/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/set/>Set<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul></li><li data-nav-id=/materiais/ed/ class=dd-item><input type=checkbox id=section-b37842fb4120c27b31481184fc126654 aria-controls=subsections-b37842fb4120c27b31481184fc126654 class=toggle><label class="a11y-only toggle" for=section-b37842fb4120c27b31481184fc126654>Submenu Estruturas de Dados</label><a href=/materiais/ed/>Estruturas de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-b37842fb4120c27b31481184fc126654><li data-nav-id=/materiais/ed/delta_encoding/ class=dd-item><a href=/materiais/ed/delta_encoding/>Delta Encoding<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/psum/ class=dd-item><a href=/materiais/ed/psum/>Soma de Prefixos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/segtree/ class=dd-item><a href=/materiais/ed/segtree/>Segment Trees<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/sparse_table/ class=dd-item><a href=/materiais/ed/sparse_table/>Sparse Table<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/algoritmos/ class=dd-item><input type=checkbox id=section-586ba47d0e40b9c87415f456840d3d8a aria-controls=subsections-586ba47d0e40b9c87415f456840d3d8a class=toggle><label class="a11y-only toggle" for=section-586ba47d0e40b9c87415f456840d3d8a>Submenu Algoritmos</label><a href=/materiais/algoritmos/>Algoritmos<i class="fas fa-check read-icon"></i></a><ul id=subsections-586ba47d0e40b9c87415f456840d3d8a><li data-nav-id=/materiais/algoritmos/busca_binaria/ class=dd-item><a href=/materiais/algoritmos/busca_binaria/>Busca Bin√°ria<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/grafos/ class=dd-item><input type=checkbox id=section-2b03d3e4a9450bb4c9d2399c7f4c7068 aria-controls=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068 class=toggle><label class="a11y-only toggle" for=section-2b03d3e4a9450bb4c9d2399c7f4c7068>Submenu Grafos</label><a href=/materiais/grafos/>Grafos<i class="fas fa-check read-icon"></i></a><ul id=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068><li data-nav-id=/materiais/grafos/representacao/ class=dd-item><a href=/materiais/grafos/representacao/>Representa√ß√£o de Grafos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_largura/ class=dd-item><a href=/materiais/grafos/busca_largura/>Busca em Largura<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_profundidade/ class=dd-item><a href=/materiais/grafos/busca_profundidade/>Busca em Profundidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/dijkstra/ class=dd-item><a href=/materiais/grafos/dijkstra/>Dijkstra<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/bitwise/ class=dd-item><a href=/materiais/bitwise/>Bitwise<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/ class=dd-item><input type=checkbox id=section-99efeb3b1634e5d2f1c17337d707c814 aria-controls=subsections-99efeb3b1634e5d2f1c17337d707c814 class=toggle><label class="a11y-only toggle" for=section-99efeb3b1634e5d2f1c17337d707c814>Submenu Matematica</label><a href=/materiais/matematica/>Matematica<i class="fas fa-check read-icon"></i></a><ul id=subsections-99efeb3b1634e5d2f1c17337d707c814><li data-nav-id=/materiais/matematica/modulo/ class=dd-item><a href=/materiais/matematica/modulo/>M√≥dulo<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/divisores/ class=dd-item><a href=/materiais/matematica/divisores/>Divisores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/primos/ class=dd-item><a href=/materiais/matematica/primos/>N√∫meros Primos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/fatoracao/ class=dd-item><a href=/materiais/matematica/fatoracao/>Fatora√ß√£o<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/avancados/ class=dd-item><input type=checkbox id=section-57c0233d0cea835299bcd9b57157a588 aria-controls=subsections-57c0233d0cea835299bcd9b57157a588 class=toggle><label class="a11y-only toggle" for=section-57c0233d0cea835299bcd9b57157a588>Submenu T√≥picos Avan√ßados</label><a href=/materiais/avancados/>T√≥picos Avan√ßados<i class="fas fa-check read-icon"></i></a><ul id=subsections-57c0233d0cea835299bcd9b57157a588><li data-nav-id=/materiais/avancados/lca/ class=dd-item><a href=/materiais/avancados/lca/>Lowest Common Ancestor<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul><div id=shortcuts><div class=nav-title>Mais</div><ul><li><a class=padding href=https://github.com/UnBalloon/unballoon.github.io><i class='fab fa-fw fa-github'></i> Reposit√≥rio GitHub</a></li><li><a class=padding href=https://codeforces.com/group/nituVTsHQX><i class='fa fa-code'></i> CodeForces</a></li><li><a class=padding href=https://t.me/unballoon><i class='fab fa-fw fa-telegram'></i> Telegram</a></li><li><a class=padding href=https://discord.gg/uc4htcV7fD><i class='fab fa-fw fa-discord'></i> Discord</a></li><li><a class=padding href=/more/credits/><i class='fas fa-fw fa-bullhorn'></i> Cr√©ditos</a></li><li><a class=padding href=/tags/><i class='fas fa-fw fa-tags'></i> Tags</a></li></ul></div><div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"></div><hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch showVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><div class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-language>Idioma</label>
<select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></div></li><li id=select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-variant>Tema</label>
<select id=select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=neon value=neon selected>Neon</option><option id=relearn-dark value=relearn-dark>Relearn Dark</option><option id=relearn-light value=relearn-light>Relearn Light</option><option id=learn value=learn>Learn</option><option id=blue value=blue>Blue</option><option id=green value=green>Green</option><option id=red value=red>Red</option></select></div><div class=select-clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><a class=padding onclick=clearHistory()><i class="fas fa-history fa-fw"></i> Limpar Hist√≥rico</a></li></ul></div><div id=footer class="footerFooter showFooter"><style>#footer{font-size:13px;height:100px;margin-left:auto;margin-right:auto;padding:2rem 1rem;text-align:center;min-width:230px;max-width:300px}#footer p{margin:0}</style><a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/archive/main.zip data-icon=octicon-cloud-download aria-label="Download UnBalloon/unballoon.github.io on GitHub">Download</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io data-icon=octicon-star data-show-count=true aria-label="Star UnBalloon/unballoon.github.io on GitHub">Star</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/fork data-icon=octicon-repo-forked data-show-count=true aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a><p>2023 - <a href=https://github.com/BrunoVarg>Bruno Vargas</a></p><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p><script asy unballoon procurar in√≠cio submenu sobre sobre dicas para iniciantes unb na competitiva eventos anteriores competi√ß√µes refer√™ncias submenu materiais materiais submenu fundamentos do c++ fundamentos do c++ submenu estruturas de dados estruturas de dados submenu algoritmos algoritmos submenu grafos grafos bitwise submenu matematica matematica submenu t√≥picos avan√ßados t√≥picos avan√ßados mais reposit√≥rio github codeforces telegram discord cr√©ditos tags tema limpar hist√≥rico 2023 - bruno vargas built with by hugo nc src=/js/buttons.js?1682184136></script></div></div></aside><script src=/js/clipboard.min.js?1682184136 defer></script>
<script src=/js/perfect-scrollbar.min.js?1682184136 defer></script>
<script src=/js/featherlight.min.js?1682184136 defer></script>
<script>function useMathJax(e){if(!Object.assign)return;window.MathJax=Object.assign(window.MathJax||{},{loader:{load:["[tex]/mhchem"]},startup:{elements:[".math"]},tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/js/mathjax/tex-mml-chtml.js?1682184136></script>
<script src=/js/theme.js?1682184136 defer></script></body></html>