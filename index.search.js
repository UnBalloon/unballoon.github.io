var relearn_search_index=[{content:`O que √© Complexidade? Em linhas gerais, a complexidade de tempo de um algoritmo √© o quanto as vari√°veis de entrada impactam no seu tempo de execu√ß√£o.
Para se referir a complexidade de um algoritmo, se usa a nota√ß√£o Big O, denotada por O(N). A nota√ß√£o Big O tem o seguinte significado: No pior caso da execu√ß√£o deste algoritmo, o n√∫mero de opera√ß√µes realizado ser√° proporcional a N, e por simplicidade, eliminamos constantes e fatores n√£o dominantes. A quantidade de opera√ß√µes que os computadores atuais executam em um segundo √© por volta de 10^8, portanto podemos estimar o tempo de execu√ß√£o de um programa usando an√°lise de complexidade. Basta fazer o c√°lculo de complexidade e dividir por 10^8, e a resposta ser√° aproximadamente o tempo de execu√ß√£o em segundos. Esse mesmo conceito se extende a mem√≥ria utilizada por um programa, podemos fazer o c√°lculo de complexidade e dividir o resultado por 10^6, e saberemos quantos MegaBytes ser√£o utilizados pelo programa no pior caso.
Exemplos:
printf("Hello World\\n"); Esse c√≥digo tem complexidade O(1) (tamb√©m chamado de complexidade constante), porque nenhuma vari√°vel de entrada impacta no seu tempo de execu√ß√£o. A complexidade de mem√≥ria tamb√©m √© O(1).
Loops int n; scanf("%d",\u0026n); for(int i = 0; i \u003c n; i++){ printf("%d\\n",i); } Esse c√≥digo tem complexidade O(n), pois o seu tempo tempo de execu√ß√£o cresce linearmente dependendo da vari√°vel n. A mem√≥ria necess√°ria n√£o depende de nenhuma vari√°vel de entrada ent√£o √© O(1).
int n; scanf("%d",\u0026n); for(int i = 0; i \u003c 10*n; i++){ printf("%d\\n",i); } Esse c√≥digo tamb√©m tem complexidade O(n), porque eliminamos os fatores constantes para manter a simplicidade. Complexidade de mem√≥ria O(1).
int n,m; scanf("%d %d",\u0026n,\u0026m); for(int i = 0; i \u003c n; i++){ printf("%d\\n",i); } for(int i = 0; i \u003c m; i++){ printf("%d\\n",i); } Muitas vezes, a complexidade depende de mais de uma vari√°vel de entrada. Como n√£o temos nenhuma informa√ß√£o sobre o significado das vari√°veis, a complexidade √© O(n+m). Se soub√©ssemos por exemplo que m fosse sempre muito maior que m, poder√≠amos dizer O(m). Mais uma vez a mem√≥ria utilizada n√£o depende de nenhuma vari√°vel de entrada.
Multiplica√ß√£o de matrizes O c√≥digo abaixo computa C = A * B, onde A √© uma matriz n por p e B √© uma matriz p por m.
for(int i = 0; i \u003c n; i++){ for(int j = 0; j \u003c m; j++){ C[i][j] = 0; for(int k = 0; k \u003c p; k++){ C[i][j] += A[i][k] * B[k][j]; } } }	Como os fors est√£o aninhados a complexidade do c√≥digo √© a multiplica√ß√£o das complexidades de cada for, sendo ent√£o, O(n*m*p). A multiplica√ß√£o produz a matriz C como resultado, que tem dimen√ß√µes n por m, Como √© necess√°rio alocar esse espa√ßo, a complexidade de mem√≥ria √© O(n*m).
Ordena√ß√£o Um problema bastante estudado √© o de ordena√ß√£o. Existem v√°rios algoritmos resolvem o problema eficientemente, n√£o ser√° mostrado um desses. O c√≥digo a seguir ordena um vetor v de tamanho n.
for(int i = 0; i \u003c n; i++){ for(int j = i; j \u003c n; j++){ if(v[i] \u003e v[j]){ tmp = v[i]; v[i] = v[j]; v[j] = tmp; } } } A quantidade de vezes que o segundo loop executa depende do i, ent√£o √© um pouco mais dif√≠cil de analisar a complexidade.
Ao longo das itera√ß√µes do primeiro loop, a quantidade de itera√ß√µes do segundo √© n + (n-1) + (n-2) + (n-3) + ... + 1, ou seja, √© soma de PA e podemos resolver para O((n+1)*n/2). Em an√°lise de complexidade s√≥ nos importamos com quando as vari√°veis s√£o muito grandes(tendem a infinito), de um modo bem bruto infinito e infinito/2 d√° no mesmo, ent√£o podemos escrever a complexidade como O((n+1)*n). Novamente quando pensamos em n√∫meros bem altos n e n+1 se tornam praticamente a mesma coisa e podemos concluir que a complexidade √© O(n^2).
Portanto podemos dizer que a complexidade do c√≥digo acima √© O((n+1)*n/2), O((n+1)*n) ou O(n^2). Mas geralmente optamos pela forma mais simples que √© O(n^2).
A intui√ß√£o sobre a complexidade de mem√≥ria pode acabar te enganando nesse exemplo. O motivo √© o seguinte: o c√≥digo apenas troca os valores de lugar dentro do vetor, n√£o sendo necess√°rio alocar um novo vetor com a resposta(Ao contr√°rio da multiplica√ß√£o de matrizes), ent√£o a complexidade de mem√≥ria √© O(1).
Recurs√£o Tamb√©m √© poss√≠vel analisar a complexidade de fun√ß√µes recursivas.
Exponencia√ß√£o int slow_exp(int base, int e){ if(e == 0) return 1; return base * slow_exp(base,e-1); } Nessa fun√ß√£o, em cada chamada, o expoente decresce em um, atingindo o caso base quando se iguala a 0. Ent√£o s√£o feitas O(n) chamadas. Quando avaliamos complexidade de mem√≥ria de fun√ß√µes recursivas, temos que levar em conta a pilha de execu√ß√£o tamb√©m. S√£o empilhadas n chamadas na pilha, ent√£o a complexidade de mem√≥ria √© O(n).
Exponencia√ß√£o r√°pida int fast_exp(int base, int e){ if(e == 0) return 1; if(e % 2) return base * fast_exp(base * base,e/2); else return fast_exp(base * base, e/2); } Essa √© uma fun√ß√£o que tamb√©m computa uma exponencia√ß√£o. √â um bom exemplo de como problemas abordados de forma diferente ou usando propriedades matem√°ticas podem ser resolvidos de forma mas eficiente. Em cada chamada na recurs√£o, o expoente √© dividido por 2, atingindo o caso base quando se iguala a 0. √â f√°cil ver que o n√∫mero 2^k levaria k chamadas para atingir o caso base, isso ocorre porque log2 (2^k) = k, ent√£o a complexidade √© O(log N). A complexidade de mem√≥ria √© justificada da mesma forma que no caso anterior, a mem√≥ria utilizada ser√° o n√∫mero de chamadas recursivas, ent√£o, O(log n).
Fibonacci int fibonacci(int n){ if(n == 0) return 0; if(n == 1) return 1; return fibonacci(n-1) + fibonacci(n-2); } A famosa fun√ß√£o de fibonacci. Essa fun√ß√£o recursiva √© bem bonita de se ver declarada, mas n√£o √© nada eficiente.
Pense que queremos Calcular Fibonacci(7)
Essa a √°rvore formada pelas chamadas recursivas, olhe quantas vezes recomputamos as mesmas coisas. A complexidade dessa fun√ß√£o √© O(2^n), pois para cada chamada de fibonacci recursiva, fazemos outras duas, e acabamos recomputando v√°rias vezes as mesmas coisas. Implemente essa fun√ß√£o em sua m√°quina e fa√ßa uma chamada de fibonacci(40), j√° deve ser poss√≠vel sentir o tempo que o programa leva para processar isso.
A complexidade de mem√≥ria dessa fun√ß√£o pode ser um pouco mais complicada de analisar vamos por partes. No total, ser√£o feitos O(2^n) chamadas recursivas, e todas elas precisaram de um espa√ßo na pilha de execu√ß√£o, no entanto, as 2^n chamadas n√£o coexistir√£o na pilha de execu√ß√£o. Olhando bem atentamente e seguindo o fluxo das chamadas recursivas, √© poss√≠vel ver que no m√°ximo um ‚Äòramo‚Äô da √°rvore estar√° na pilha por vez, o ramo mais longo tem comprimento n portanto, complexidade de mem√≥ria O(n).
VideoAulas Complementares https://www.youtube.com/watch?v=YoZPTyGL2IQ (12 min.)
https://www.youtube.com/watch?v=moPtwq_cVH8 (51 min. MIT)
`,description:"",tags:["iniciante"],title:"Complexidade",uri:"/materiais/fundamentos/complexidade/"},{content:`Para come√ßar na programa√ß√£o competitiva voc√™ deve ter o dom√≠nio b√°sico de programa√ß√£o em alguma linguagem de programa√ß√£o.
Na competitiva a principal linguagem √© o C++, devido a sua velocidade de execu√ß√£o e flexibilidade/potencial para escrever os mais diferentes algoritmos.
D√∫vida muito comum Devo come√ßar na linguagem que tenho mais afinidade (ex: Python) ou j√° come√ßo em C++?
Essa d√∫vida pode ter diferentes caminhos/opini√µes, mas aqui vai uma sugest√£o:
Se voc√™ quer um caminho mais eficiente para ter resultados mais r√°pidos na programa√ß√£o competitiva, recomendo come√ßar em C++ com o curso do Neps. Acredito que a curva de aprendizado para entender o C++ (que √© um pouco mais chato que Python por exemplo) √© relativamente r√°pida e assim voc√™ j√° est√° com a ferramenta mais assertiva para a competitiva. Se voc√™ quer apenas experimentar um pouco a competitiva a fim de ver como funciona, participar casualmente de algumas competi√ß√µes, talvez continuar com sua linguagem de programa√ß√£o pode ser um caminho, e caso tenha mais interesse pode migrar para a sintaxe do C++. Ap√≥s ter esse contato introdut√≥rio com a Linguagem, √© importante que seja feito um ciclo de estudo e pr√°tica de novos conte√∫dos.
Pr√°tica:
A plataforma mais famosa de competitiva √© o https://codeforces.com, com diversos problemas e competi√ß√µes semanais. Tem outros sites como https://atcoder.jp (esse especificamente √© bom para iniciantes pois tem problemas partindo de um n√≠vel mais b√°sico al√©m de ter quest√µes mais ‚Äúeducativas" - com conte√∫dos mais estruturados, algoritmos cl√°ssicos etc) O https://www.beecrowd.com.br/judge/pt/login(antigo URI) √© uma bom meio para praticar tamb√©m, √© a maior plataforma nacional dessa √°rea com muitos problemas interessantes. Conte√∫do:
UnBalloon : Iniciante Neps Academy - Al√©m da parte introdut√≥ria voc√™ vai encontrar diversos outros cursos com temas para programa√ß√£o competitiva:
Estrutura de dados - https://neps.academy/br/course/estruturas-de-dados-(codcad) Grafos - https://neps.academy/br/course/algoritmos-em-grafos-(codcad) Matem√°tica - https://neps.academy/br/course/matematica-computacional-(codcad) T√©cnicas de programa√ß√£o - https://neps.academy/br/course/tecnicas-de-programacao-(codcad) Possibilidade de ordem: ED, T√©cnicas de programa√ß√£o, Matem√°tica e Grafos
Projeto de extens√£o da UnB - https://unb-cic.github.io/Maratona-Extensao/
`,description:"",tags:null,title:"Dicas para Iniciantes",uri:"/sobre/dicas/"},{content:"Subp√°ginas Pilha Fila Fila de Prioridade ",description:"",tags:["iniciante"],title:"ED Linear",uri:"/materiais/fundamentos/eds/ed_linear/"},{content:"Tudo o que voc√™ precisa saber sobre C++ Subp√°ginas Complexidade Entrada/Sa√≠da Declara√ß√µes Estrutura de Dados ",description:"",tags:null,title:"Fundamentos do C++",uri:"/materiais/fundamentos/"},{content:`O que √© Programa√ß√£o Competitiva S√£o competi√ß√µes em que basicamente voc√™ recebe desafios de programa√ß√£o para resolver em um determinado tempo. Em geral ganha quem conseguir resolver mais problemas em um menor tempo. Existem v√°rios formatos de competi√ß√£o, dentre eles √© comum:
Competi√ß√µes em grupo (ex: 3 pessoas e 1 computador) Competi√ß√µes individuais OBS: A programa√ß√£o competitiva tem uma grande similaridade com olimp√≠adas cient√≠ficas. Al√©m de ter diretamente as olimp√≠adas de programa√ß√£o (ex: OBI), a estrutura das competi√ß√µes s√£o feitas em etapas que muitas vezes giram em torno de regional ‚Üí nacional ‚Üí mundial.
Como isso pode me ajudar? Benef√≠cio pessoal üß†¬†- A programa√ß√£o competitiva possibilita um desenvolvimento muito grande do seu racioc√≠nio l√≥gico, portanto, al√©m de aumentar muito suas habilidades na programa√ß√£o (pensamentos r√°pidos, habilidade de lidar bem com algoritmos e estrutura de dados), contribui consideravelmente com o seu desenvolvimento de uma forma geral (ex: racioc√≠nio l√≥gico r√°pido para atividades do dia-a-dia ou do seu trabalho, desenvolvimento do pensamento matem√°tico, melhora na capacidade anal√≠tica etc)
Benef√≠cio Profissional üî≠¬†- A programa√ß√£o competitiva √© uma porta de entrada para o mercado de trabalho, principalmente quando se trata de empresas grandes, sejam Big Techs como Google, Facebook ou Grandes empresas Nacionais como VTEX, Quinto Andar etc. Mas como me ajuda exatamente?
Entrevistas t√©cnicas facilitadas - Muitas empresas fazem um processo seletivo com algum teste de racioc√≠nio/c√≥digo para testar suas habilidades. Uma pessoa com boas habilidades na programa√ß√£o competitiva basicamente ‚Äútira de letra‚Äù esses testes.
Oportunidades de emprego - Muitas empresas enxergam o valor de bons programadores competitivos e ‚Äúcorrem atr√°s‚Äù para contratar esse p√∫blico. Portanto, os eventos de programa√ß√£o s√£o uma grande porta para os ‚Äúolheiros‚Äù fazerem propostas de emprego. (Algo comum na final brasileira da maratona SBC de programa√ß√£o, que tem encontro com patrocinadores e din√¢micas desse tipo).
Networking ü§ù¬†- A programa√ß√£o competitiva √© um polo de pessoas inteligentes que tem muito a agregar com informa√ß√µes e expertises. Portanto esse mundo √© um √≥timo meio para se relacionar com pessoas com prop√≥sitos legais.
Ver mais Dicas para Iniciantes UnB na Competitiva Eventos Anteriores Competi√ß√µes Refer√™ncias `,description:"",tags:null,title:"Sobre",uri:"/sobre/"},{content:"Subp√°ginas Map Set ",description:"",tags:["iniciante"],title:"ED N√£o Linear",uri:"/materiais/fundamentos/eds/ed_n_linear/"},{content:`Entrada O objeto ‚Äúcin‚Äù representa o stream de entrada no C++. Ele realiza a leitura de um sequ√™ncia de dados, sem espa√ßos e sem tabula√ß√µes, vindas do teclado. Para coletar estes dados armazenados, usa-se o ‚Äúoperador de extra√ß√£o‚Äù que ‚Äúextrai‚Äù dados do stream.
Lendo um Input A primeira linha ter√° N que √© a quantidade de n√∫meros a serem lidos.
A segunda linha ser√° os N n√∫meros.
input: 4 1 5 2 3 #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin\u003e\u003en; for(int i=0; i\u003cn; i++){ int numero; cin\u003e\u003enumero; } return 0; } Sa√≠da O objeto ‚Äúcout‚Äù representa o stream de sa√≠da no C++. Este stream √© uma esp√©cie de sequ√™ncia (fluxo) de dados a serem impressos na tela. Para realizar a impress√£o, usa-se o ‚Äúoperador de inser√ß√£o‚Äù que ‚Äúinsere‚Äù dados dentro do stream.
Printando o famoso ‚ÄúHello World‚Äù
#include \u003cbits/stdc++.h\u003e using namespace std; int main(){ cout\u003c\u003c"Hello World"\u003c\u003cendl; return 0; } Informa√ß√£o O ‚Äúendl‚Äù √© usado para fazer quebra de linha, por√©m, pode ser mais lento que o ‚Äú\\n‚Äù.
Casas Decimais Para printar as casas decimais, precisamos usar o ‚Äúfixed‚Äù que √© uma fun√ß√£o do C++ usada para formatar a sa√≠da, juntamente com o ‚Äúsetprecision‚Äù, que diz quantas casas ser√° printada.
#include \u003cbits/stdc++.h\u003e using namespace std; int main(){ double pi = 3.141592653; cout\u003c\u003cfixed; cout\u003c\u003csetprecision(4); cout\u003c\u003cpi\u003c\u003cendl; // 3.1415 return 0; } Fast Cin Informa√ß√£o O printf e o scanf do C s√£o mais r√°pidos do que o cin e o cout do C++.
Isso ocorre porque o C++ usa a sincroniza√ß√£o do output, ou seja, enquanto ele est√° lendo o input, o programa pode responder ao mesmo tempo.
A resolu√ß√£o para que o cin e o cout fique mais r√°pido (pr√≥ximo √† velocidade do scanf e do printf), √© desabilitar a sincroniza√ß√£o no C++.
Segue o exemplo:
ios_base::sync_with_stdio(false); cin.tie(NULL); Exemplo #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; } `,description:"",tags:["iniciante"],title:"Entrada/Sa√≠da",uri:"/materiais/fundamentos/input-output/"},{content:"",description:"",tags:null,title:"Estruturas de Dados",uri:"/materiais/ed/"},{content:"Conte√∫dos de Programa√ß√£o Competitiva Subp√°ginas Fundamentos do C++ Estruturas de Dados Algoritmos Grafos Bitwise Matematica T√≥picos Avan√ßados ",description:"",tags:null,title:"Materiais",uri:"/materiais/"},{content:`
Equipe da UnB destaca-se em torneio mundial de programa√ß√£o
A UnB tem tido um √≥timo destaque nacional na programa√ß√£o competitiva nos √∫ltimos anos 2 anos consecutivos na final Mundial Melhor resultado Brasileiro na Mundial em 2021 13¬∫ Lugar na Nacional de 2022 9¬∫ e 11¬∫ Lugar na Regional de 2023 6¬∫ e 9¬∫ Lugar na Nacional de 2023 Time classificado pro Mundial no Egito em 2023 M√≠dia Social UnBalloon O principal √© o grupo UnBalloon üéà (Grupo da UnB envolvido na competitiva) Discord: https://discord.gg/ug677zwZsn
Telegram: https://t.me/unballoon (geral) / https://t.me/avisosunballoon (avisos)
Mat√©rias de Programa√ß√£o Competitiva Programa√ß√£o Competitiva ¬ª Darcy T√≥picos Especiais em Programa√ß√£o Competitiva ¬ª Darcy T√≥picos Especiais em Programa√ß√£o ¬ª Gama Projetos de Extens√£o Em alguns semestres s√£o realizados projetos de extens√£o para competitiva O √∫ltimo ocorreu em 2020.2: https://unb-cic.github.io/Maratona-Extensao/ `,description:"",tags:null,title:"UnB na Competitiva",uri:"/sobre/unb/"},{content:"Subp√°ginas Busca Bin√°ria ",description:"",tags:null,title:"Algoritmos",uri:"/materiais/algoritmos/"},{content:"Subp√°ginas Strings Vector Pairs Iterators ",description:"",tags:null,title:"Declara√ß√µes",uri:"/materiais/fundamentos/declaracoes/"},{content:`III Maratona UnBalloon Foi a primeira maratona UnBalloon realizada presencialmente. Houve a participa√ß√£o de 14 times presencialmente e muitos bal√µes foram entregues!
Arquivos: Fotos Problemas (mirror no Codeforces) Placar II Olimp√≠ada UnBalloon de Inform√°tica Maratona feita com o formato da OBI para treinar quem iria participar.
Arquivos: Fotos Problemas (mirror no Codeforces) Placar X Maratona UnB Foi a Maratona que selecionou os times da UnB e do IFB para a primeira fase da ICPC. Houve a participa√ß√£o de 30 times presencialmente.
Arquivos: Fotos Problemas (mirror no Codeforces) Placar Estat√≠sticas VII Maratona do IFB Maratona realizada no IFB com parceria da UnB
Arquivos: Fotos Problemas (mirror no Codeforces) Informa√ß√µes II Maratona de APC Maratona voltada para os calouros que est√£o cursando a disciplina APC
Arquivos: Fotos `,description:"",tags:null,title:"Eventos Anteriores",uri:"/sobre/eventos/"},{content:`No C++ representa uma sequ√™ncia de caracteres
Podemos declarar uma string como:
string nomevar; string nomevar = constante; string nomevar = char ‚àó variavel; string nomevar(char ‚àó variavel); string nomevar(tamanho, constante char); Concatena√ß√£o Podemos usar o operador ‚Äú+‚Äù para concatenar duas strings
#include \u003cbits/stdc++.h\u003e using namespace std; int main(){ string a = "abc"; string b = "def"; string c = a + b; cout\u003c\u003cc\u003c\u003cendl; // abcdef return 0; } Transformando um inteiro em string Podemos transformar um inteiro em uma string usando a fun√ß√£o ‚Äúto_string()‚Äù
#include \u003cbits/stdc++.h\u003e using namespace std; int main(){ int x = 123; string s = to_string(x); cout\u003c\u003cs\u003c\u003cendl; return 0; } `,description:"",tags:["iniciante"],title:"Strings",uri:"/materiais/fundamentos/declaracoes/string/"},{content:"OBI - Olimp√≠ada Brasileira de inform√°tica Voltado para estudantes do Ensino M√©dio e alunos do 1¬∫ ano da gradua√ß√£o (cursando a primeira faculdade) Competi√ß√£o individual Maratona SBC / ICPC Principal competi√ß√£o universit√°ria Competi√ß√£o em equipe (3 pessoas) Estrutura: Local (Seletiva da universidade) ‚Üí 1¬™ Fase Maratona SBC ‚Üí Final Brasileira Maratona SBC ‚Üí Final Mundial ICPC Quem pode participar? se o competidor j√° participou de duas finais mundiais, ele n√£o √© eleg√≠vel; se o competidor j√° participou de cinco regionais, ele n√£o √© eleg√≠vel; se o competidor iniciou seus estudos universit√°rios no ano 2017 ou antes E nasceu em 1998 ou antes, ele n√£o √© eleg√≠vel; aso contr√°rio, o competidor √© eleg√≠vel. Onde ocorrem as provas? Ao decorrer de 2023, a sede do DF ser√° divulgada. Quando s√£o as provas? O calend√°rio tamb√©m √© flutuante, com provas aos s√°bados. Tradicionalmente a etapa Regional ocorre no segundo s√°bado de setembro, a Nacional no segundo s√°bado de novembro e a Mundial em maio do ano seguinte. Maratonas regionais Maratona UnB - Todo ano acontece a maratona da UnB Maratona UnBalloon Maratona de APC Maratona do IESB Maratona do IFB ",description:"",tags:null,title:"Competi√ß√µes",uri:"/sobre/competicoes/"},{content:"Subp√°ginas ED Linear ED N√£o Linear ",description:"",tags:null,title:"Estrutura de Dados",uri:"/materiais/fundamentos/eds/"},{content:"Subp√°ginas Representa√ß√£o de Grafos Busca em Largura Busca em Profundidade Dijkstra ",description:"",tags:null,title:"Grafos",uri:"/materiais/grafos/"},{content:`Vector pode ser entendido como uma estruturas de dados similar a um array de tamanho expans√≠vel.
A diferen√ßa principal entre vector e array √© a aloca√ß√£o: no array adota-se aloca√ß√£o est√°tica, enquanto que no vector a aloca√ß√£ao √© din√¢mica.
Inicializar #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ // inicializando vetores vazios vector\u003cdouble\u003e vd; vector\u003cpair\u003cint,double\u003e\u003e vid; vector\u003cstring\u003e vs; vector\u003cint\u003e v; // vector\u003cint\u003e v(tamanho, valor) vector\u003cint\u003e v(4, 0); // {0, 0, 0, 0} vetor de 4 posi√ß√µes com valor 0 vector\u003cint\u003e v(4); // {0, 0, 0, 0} por default, inicializa como 0 v.push_back(5); // Adiciona o elemento 5 // v = {0, 0, 0, 0, 5} v.pop_back(); // v = {0, 0, 0, 0} } Iterar #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ vector\u003cint\u003e v = {1, 2, 3, 4, 5}; // printa um elemento em cada linha for(int i=0; i\u003cv.size(); i++){ cout\u003c\u003c v[i] \u003c\u003c endl; } } Informa√ß√£o O m√©todo size() retorna a quantidade de elementos existentes em um vector. Complexidade: O(1)
Ordenar Complexidade O(N*log(N))
#include \u003cbits/stdc++.h\u003e using namespace std; int main(){ vector\u003cint\u003e v = {3, 4, 1, 2, 5}; sort(v.begin(), v.end()); // ordena o vetor // v = {1, 2, 3, 4, 5} } Inverter Complexidade O(N)
#include \u003cbits/stdc++.h\u003e using namespace std; int main(){ vector\u003cint\u003e v = {1, 2, 3, 4, 5}; reverse(v.begin(), v.end()); // v = {5, 4, 3, 2, 1} } Vector de Pair #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ vector\u003cpair\u003cint,int\u003e\u003e v = {{1, 2}, {3, 4}, {5, 6}}; // v[0].first = 1 // v[0].second = 2 } `,description:"",tags:["iniciante"],title:"Vector",uri:"/materiais/fundamentos/declaracoes/vector/"},{content:`O pair √© muito importante quando precisamos guardar duas informa√ß√µes juntas.
Um ‚Äúpair‚Äù √© um cont√™iner que consiste de dois tipos de dados ou objetos.
Declaramos um pair como:
pair\u003ctipodado1, tipodado2\u003e variavel; Podemos inicializ√°-lo usando o make_pair ou diretamente:
variavel = make_pair(dado1, dado2); variavel = {dado1, dado2}; O primeiro elemento √© acessado usando o ‚Äúfirst‚Äù e o segundo usando ‚Äúsecond‚Äù variavel.first; variavel.second; Exemplo 1: Um Pair que armazena 2 inteiros #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ pair\u003cint, int\u003e pii; pii = {5, 10}; cout\u003c\u003c pii.first \u003c\u003c " " \u003c\u003c pii.second\u003c\u003c"\\n"; // 5 10 return 0; } Exemplo 2: Um Pair que armazena 1 inteiro e 1 double #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ pair\u003cint, double\u003e pii; pii = {2, 1.5365}; cout\u003c\u003c pii.first \u003c\u003c " " \u003c\u003c pii.second\u003c\u003c"\\n"; // 2 1.5365 return 0; } Comparando Vari√°veis: #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ pair\u003cint, int\u003e v1, v2; v1 = {3, 1}; v2 = {2, 2}; if(v1 \u003e v2) cout\u003c\u003c "v1 √© maior que v2"; else cout\u003c\u003c "v1 √© menor ou igual a v2"; return 0; } `,description:"",tags:["iniciante"],title:"Pairs",uri:"/materiais/fundamentos/declaracoes/pair/"},{content:`Iterators s√£o tipos espec√≠ficos de ponteiros que referenciam endere√ßoos de mem√≥ria de objetos e cont√™iners STL.
Exemplo 1 #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ vector\u003cint\u003e v = {1, 2, 3, 4, 5}; vector\u003cint\u003e::iterator ptr; cout\u003c\u003c"Elementos do Vetor"\u003c\u003cendl; for(ptr = v.begin(); ptr != v.end(); ptr++){ cout\u003c\u003c(*ptr)\u003c\u003cendl; } return 0; } Dica Voc√™ pode usar o auto no lugar de vector\u003cint\u003e::iterator, para facilitar
Exemplo 2 #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ vector\u003cint\u003e ar = { 1, 2, 3, 4, 5 }; // Declaring iterators to a vector vector\u003cint\u003e::iterator ptr = ar.begin(); vector\u003cint\u003e::iterator ftr = ar.end(); // Using next() to return new iterator // points to 4 auto it = next(ptr, 3); // Using prev() to return new iterator // points to 3 auto it1 = prev(ftr, 3); // Displaying iterator position cout \u003c\u003c "The position of new iterator using next() is : "; cout \u003c\u003c *it \u003c\u003c " "; cout \u003c\u003c endl; // Displaying iterator position cout \u003c\u003c "The position of new iterator using prev() is : "; cout \u003c\u003c *it1 \u003c\u003c " "; cout \u003c\u003c endl; // The position of new iterator using next() is : 4 // The position of new iterator using prev() is : 3 } `,description:"",tags:["iniciante"],title:"Iterators",uri:"/materiais/fundamentos/declaracoes/iterators/"},{content:`Plataformas de Programa√ß√£o Competitiva: https://codeforces.com https://atcoder.jp https://beecrowd.com.br (Antigo URI) Livros/sites que a galera usa para estudar: Competitive Programming 3 - Stevem Halim CP handbook: https://cses.fi/book/book.pdf CodCad: https://neps.academy/br/codcad (Bom para come√ßar) Algoritmos: https://cp-algorithms.com/ Iniciativas da UnB https://unb-cic.github.io/Maratona-Extensao/ (Aulas do projeto de extens√£o)
https://github.com/UnBalloon (Reposit√≥rio de algoritmos)
Telegram: https://t.me/unballoon
Discord: https://discord.gg/uc4htcV7fD
Mat√©rias: Programa√ß√£o competitiva, T√≥picos Especiais em Programa√ß√£o ‚Ä¢ Gama, T√≥picos Especiais em Programa√ß√£o Competitiva ‚Ä¢ Darcy
Competi√ß√µes que rolam OBI https://olimpiada.ic.unicamp.br/ (Voltada para ensino m√©dio + 1¬∫ ano da faculdade) Facebook Hacker Cup https://web.facebook.com/codingcompetitions/hacker-cup Google Code Jam https://codingcompetitions.withgoogle.com/codejam Maratona SBC http://maratona.sbc.org.br/ (√â no mesmo esquema de olimp√≠ada cient√≠fica, tem Regional - Nacional - Mundial) Competi√ß√µes DF https://codeforces.com/group/btcK4I5D5f/blog `,description:"",tags:null,title:"Refer√™ncias",uri:"/sobre/referencias/"},{content:`A pilha √© uma estrutura que, como o nome sugere, permite inser√ß√£o e remo√ß√£o apenas do ‚Äútopo‚Äù. Isto significa que, ao remover um elemento da pilha, o elemento a ser removido √© o √∫ltimo que foi inserido. Tamb√©m √© conhecido como LIFO (last-in first-out).
M√©todos: push - Insere um elemento na pilha. pop - Remove o elemento do topo da pilha. top - Retorna o elemento do topo da pilha. size - Retorna o tamanho da pilha. empty - Retorna true se estiver vazia, se n√£o, retorna falso. Exemplo Programa simples que vai inserir elementos na pilha e depois conforme for removendo, printa cada elemento #include \u003cbits/stdc++.h\u003e using namespace std; int main() { stack\u003cint\u003e pilha; // construtor, entre \u003c\u003e deve ser inserido o tipo de dado que ser√° armazenado pilha.push(2); // o metodo push insere o elemento no topo da pilha pilha.push(7); pilha.push(8); pilha.push(4); cout \u003c\u003c pilha.size() \u003c\u003c endl; // tamanho da pilha // enquanto n√£o estiver vazia, remove o elemento do topo e printa ele while(!pilha.empty()){ int elemento = pilha.top(); cout\u003c\u003celemento\u003c\u003c" "; pilha.pop(); } return 0; } Sa√≠da
4 8 7 2 Pilha de M√≠nimo E se quisermos o seguinte problema:
Dado N n√∫meros em uma pilha, para os √∫ltimos Q n√∫meros na pilha, printe o menor n√∫mero em toda pilha at√© ent√£o. Podemos fazer um c√≥digo que para cada Q √∫ltimos n√∫meros na pilha, podemos ir percorrendo toda a pilha restante, salvando os menores, sem alterar a pilha atual.
#include \u003cbits/stdc++.h\u003e using namespace std; int main(){ stack\u003cint\u003e st; st.push(5); st.push(3); st.push(8); st.push(1); st.push(7); stack\u003cint\u003e st_aux; // para os 4 √∫ltimos n√∫meros, printe o menor n√∫mero de toda a pilha at√© ele for(int q=0; q\u003c4; q++){ // menor = infinito int menor = LLINF; // empilha na stack auxiliar while(!st.empty()){ int x = st.top(); menor = min(x, menor); st.pop(); st_aux.push(x); } cout\u003c\u003cmenor\u003c\u003cendl; // desempilha na stack original while(!st_aux.empty()){ int x = st_aux.top(); st_aux.pop(); st.push(x); } if(!st.empty()){ st.pop(); } } return 0; } Por√©m, √© claro, a complexidade do c√≥digo n√£o √© boa. ficaria aproximadamente O(Q*N), se o Q e o N forem grandes, certamente levar√≠amos TLE (Time Limit Exceeded).
A solu√ß√£o para esse problema ent√£o, ser√≠amos usar a pilha de m√≠nimo.
Como funciona? A pilha de m√≠nimo usa um valor auxiliar para armazenar o menor elemento at√© a inser√ß√£o atual, podemos usar um stack\u003cpair\u003cint,int\u003e\u003e ou duas stack\u003cint\u003e.
O algoritmo ent√£o inicia a inser√ß√£o de N elementos, e para cada inser√ß√£o de elemento, vamos verificar se o elemento da stack auxiliar √© menor ou maior que o da original, e guardaremos o de menor valor na stack auxiliar.
Implementa√ß√£o #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ stack\u003cpair\u003cint,int\u003e\u003e st; int n; cin\u003e\u003en; // recebemos n n√∫meros for(int i=0; i\u003cn; i++){ int num; cin\u003e\u003enum; if(st.empty()){ // num sera o menor valor da pilha.second st.push({num,num}); }else{ // armazenamos o menor valor entre // o que esta na pilha.second e o num atual int menor = st.top().second; menor = min(menor, num); st.push({num, menor}); } } // Para Q consultas int q; cin\u003e\u003eq; for(int i=0; i\u003cq; i++){ if(!st.empty()){ // pega o menor valor int val = st.top().second; st.pop(); cout\u003c\u003cval\u003c\u003cendl; } } return 0; } E a complexidade fica somente O(N+Q), pois agora conseguimos responder em O(1) cada query.
Refer√™ncias:
https://youtu.be/lFghsipaZhc?t=4593 (Aula muito boa)
https://cp-algorithms.com/data_structures/stack_queue_modification.html
`,description:"",tags:["iniciante"],title:"Pilha",uri:"/materiais/fundamentos/eds/ed_linear/pilha/"},{content:`A fila segue o padr√£o de FIFO (first-in first-out), ao contr√°rio da pilha, o primeiro elemento inserido ser√° o primeiro a ser removido. Ela √© muito √∫til para problemas que precisamos manter os elementos na ordem em que lhes foram dados.
M√©todos push - Adiciona um elemento no fim da fila. front - Retorna o elemento do in√≠cio da fila. back - Retorna o elemento do final da fila. pop - Remove o elemento do in√≠cio da fila. empty - Retorna true se estiver vazia, e false caso contr√°rio. size - Retorna quantos elementos tem na fila. Exemplo #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ queue\u003cint\u003e q; q.push(9); q.push(5); q.push(6); q.push(1); q.push(8); cout\u003c\u003c q.size() \u003c\u003cendl; while(!q.empty()){ int elemento = q.front(); cout\u003c\u003celemento\u003c\u003c" "; q.pop(); } return 0; } Sa√≠da
9 5 6 1 8 `,description:"",tags:["iniciante"],title:"Fila",uri:"/materiais/fundamentos/eds/ed_linear/fila/"},{content:`Uma fila de prioridade tem como principal caracter√≠stica a ordena√ß√£o, ela mant√©m o elemento do topo como sempre sendo o maior (ou o menor) elemento sempre.
Caso esteja fixado para o elemento do topo ser o maior, a fila de prioridade estar√° em ordem descrescente do topo para baixo. Caso contr√°rio, a ordem ser√° crescente.
Por padr√£o, ela estar√° fixado para o elemento do topo ser o maior, logo, estar√° em ordem decrescente os elementos na fila de prioridade.
As filas de prioridades s√£o muito √∫teis quando precisamos que nossos elementos sempre estejam ordenados conforme vamos inserindo elementos.
M√©todos push - Adiciona um elemento na fila de prioridade. pop - Remove o elemento do topo da fila de prioridade. top - Retorna o valor do topo empty - Retorna true se a fila estiver vazia, caso contr√°rio, retorna false size - Retorna o tamanho da fila de prioridade. Informa√ß√£o A complexidade de inser√ß√£o e remo√ß√£o √© O(log(n)), e a de olhar o topo do heap √© O(1).
Exemplo #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ priority_queue\u003cint\u003e q; q.push(9); q.push(5); q.push(6); q.push(1); q.push(8); cout\u003c\u003c q.size() \u003c\u003cendl; while(!q.empty()){ int elemento = q.top(); cout\u003c\u003celemento\u003c\u003c" "; q.pop(); } return 0; } Sa√≠da
9 8 6 5 1 Ordena√ß√£o pelo menor valor Para ordenar pelo menor valor usamos a seguinte sintaxe na declara√ß√£o: priority_queue \u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q
Exemplo 2 #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ priority_queue \u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q; q.push(9); q.push(5); q.push(6); q.push(1); q.push(8); cout\u003c\u003c q.size() \u003c\u003cendl; while(!q.empty()){ int elemento = q.top(); cout\u003c\u003celemento\u003c\u003c" "; q.pop(); } return 0; } Sa√≠da
1 5 6 8 9 `,description:"",tags:["iniciante"],title:"Fila de Prioridade",uri:"/materiais/fundamentos/eds/ed_linear/fila_prioridade/"},{content:`O map √© uma estrutura interessante pois permite ‚Äúmapear‚Äù chaves √† valores, e dado uma chave encontrar o seu valor rapidamente (complexidade depende da implementa√ß√£o). Por exemplo, podemos fazer um map com strings de chave e int de valor, sendo poss√≠vel recuperar o valor inteiro associado a aquela string rapidamente.
Deve-se ter cuidado com o uso de map pois ele √© implementado em c++ como um set de pairs, isto √©, vai ter complexidade O(log n) para inserir e modificar dados.
Informa√ß√£o Existe tamb√©m o unordered_map, que √© uma estrutura que usa hash. No pior caso √© linear, mas em m√©dia tem complexidade constante. O seu funcionamento √© similar ao do map, com a diferen√ßa de que seus elementos n√£o est√£o ordenados.
M√©todos insert({key, element}) - Insere uma chave e um valor no map erase() - Remove uma key ou um iterator find(element) - Retorna um iterator da posi√ß√£o do element count - Retorna a quantidade de elementos de uma chave espec√≠fica size - Retorna o tamanho do map clear - Limpa todo o conte√∫do do Map begin - Retorna um iterator para o in√≠cio do map end - Retorna um iterator para o final do map Inicializa√ß√£o #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ // map chave, valor de inteiros map\u003cint, int\u003e m; // Inicializa√ß√£o de map vazio map\u003cint, int\u003e m = {{2, 3}, {4, 6}}; // Inicializa√ß√£o de map com valor m[7] = 3 m[7] ++; // 4 } Itera√ß√£o #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ // iterando por m√©todos iterator map\u003cint, int\u003e m = {{2, 3}, {4, 6}}; // Printa a chave e o valor em cada linha for(auto it = m.begin(); it != m.end(); it++){ cout\u003c\u003c it.first \u003c\u003c" "\u003c\u003c it.second\u003c\u003c endl; } // tambem pode ser escrito como: for(auto it: m){ cout\u003c\u003c it.first \u003c\u003c " "\u003c\u003c it.second\u003c\u003c endl; } } Sa√≠da
2 3 4 6 Apagando elemento #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ // iterando por m√©todos iterator map\u003cint, int\u003e m = {{2, 3}, {4, 6}} m.erase(m.find(2)); m.erase(4); } Informa√ß√£o Da primeira maneira, ele apaga em tempo constante, pois est√° passando um iterator. Da segunda maneira, ele apaga em log(N), pois ele faz uma busca no elemento.
Verificar um elemento #include \u003cbits/stdc++.h\u003e using namespace std; int main(){ // iterando por m√©todos iterator map\u003cint, int\u003e m = {{2, 3}, {4, 6}} if( m.count(2) \u003e 0 ){ // existe uma chave {2} cout\u003c\u003c "Elemento existe"; }else{ cout\u003c\u003c "Elemento n√£o existe"; } } Sa√≠da
Elemento existe `,description:"",tags:["iniciante"],title:"Map",uri:"/materiais/fundamentos/eds/ed_n_linear/map/"},{content:`A estrutura set √© bem parecida com o que conhecemos de conjuntos da matem√°tica; n√£o existem elementos repetidos e a ordem n√£o importa.
A implementa√ß√£o do set, por√©m, √© feita com uma √°rvore bin√°ria de busca, sendo assim permitido inserir, remover e acessar um elemento em O(log n).
A vantagem do set em rela√ß√£o ao vector √© que, caso queira inserir um elemento em um vector ordenado e preservar a ordena√ß√£o, voc√™ ter√° que procurar o lugar que ele deve ser inserido, fazer a inser√ß√£o e modificar a posi√ß√£o dos elementos √† direita dele. Modificar todas as posi√ß√µes √† direita tem uma complexidade ruim O(n), ent√£o este algoritmo ser√° mais eficiente com o set.
Al√©m da vantagem de efici√™ncia, essas opera√ß√µes com set s√£o feitas com alguns simples m√©todos!
M√©todos insert(element) - Insere um elemento no Set erase() - Remove uma key ou um iterator find(element) - Retorna um iterator da posi√ß√£o do element count - Retorna a quantidade de elementos de uma chave espec√≠fica size - Retorna o tamanho do set clear - Limpa todo o conte√∫do do set begin - Retorna um iterator para o in√≠cio do set end - Retorna um iterator para o final do set lower_bound(element) - Retorna um iterator para o primeiro valor \u003e= element upper_bound(element) - Retorna um iterator para o primeiro valor \u003e element Exemplo 1 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { set\u003cint\u003e s; s.insert(3); // insere elemento no set cout \u003c\u003c s.size() \u003c\u003c endl; // tamanho do set // para verificar se um elemento est√° contido no set ou nao podemos utilizar // o metodo find; caso nao esteja presente ele retornar√° o iterator para // o fim do set if(s.find(2) == s.end()) { cout \u003c\u003c "O numero 2 nao esta no set" \u003c\u003c endl; } else { cout \u003c\u003c "O numero 2 esta no set" \u003c\u003c endl; } if(s.find(3) == s.end()) { cout \u003c\u003c "O numero 3 nao esta no set" \u003c\u003c endl; } else { cout \u003c\u003c "O numero 3 esta no set" \u003c\u003c endl; } s.erase(3); // apaga elemento 3 do set if(s.find(3) == s.end()) { cout \u003c\u003c "O numero 3 nao esta no set" \u003c\u003c endl; } else { cout \u003c\u003c "O numero 3 esta no set" \u003c\u003c endl; } return 0; } Outro m√©todo extremamente √∫til √© o lower_bound (e o upper_bound). O lower_bound recebe um inteiro x como argumento e retorna o menor inteiro maior ou igual a x. Caso n√£o exista, ele retorna um iterator para o fim do set (set.end()).
Exemplo 2 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { set\u003cint\u003e s; s.insert(3); // insere elemento no set s.insert(4); s.insert(5); s.insert(7); auto iterator1 = s.lower_bound(6); // se iterator eh igual a s.end() entao nao existe if(iterator1 != s.end()) { int numero = *iterator1; cout \u003c\u003c "menor inteiro maior ou igual a 6 eh " \u003c\u003c numero \u003c\u003c endl; } else { cout \u003c\u003c "nao existe inteiro numero maior ou igual a 6" \u003c\u003c endl; } auto iterator2 = s.lower_bound(9); // se iterator eh igual a s.end() entao nao existe if(iterator2 != s.end()) { int numero = *iterator2; cout \u003c\u003c "menor inteiro maior ou igual a 9 eh " \u003c\u003c numero \u003c\u003c endl; } else { cout \u003c\u003c "nao existe inteiro numero maior ou igual a 9" \u003c\u003c endl; } return 0; } Informa√ß√£o Na verdade, voc√™ pode utilizar o lower_bound para qualquer tipo que implemente a opera√ß√£o ‚Äú\u003c‚Äù, como por exemplo o pair\u003cint, int\u003e.
`,description:"",tags:["iniciante"],title:"Set",uri:"/materiais/fundamentos/eds/ed_n_linear/set/"},{content:`Problemas de atualiza√ß√£o em intervalos Suponha que voc√™ se depare com um problema do seguinte tipo:
Voc√™ recebe um vetor v , inicialmente com todos seus n√∫meros zerados, e q queries. cada query vir√° representada por 3 inteiros (l,r,x). Ao receber cada query, a mudan√ßa esperada √©: ‚ÄúPara cada n√∫mero no vetor, seja i o seu √≠ndice. Se l \u003c= i \u003c= r, v[i] deve ter x adicionado ao seu valor. Ao final do programa, deve-se imprimir o vetor todo com seus valores atualizados.
A primeira solu√ß√£o que j√° vem a cabe√ßa √© a seguinte:
int n,q; scanf("%d %d",\u0026n,\u0026q); vi v(n,0); for (int i = 0; i \u003c q; ++i){ int l,r,x; scanf("%d %d %d",\u0026l,\u0026r,\u0026x); for (int j = l; j \u003c= r; ++j){ v[j] += x; } } Nessa solu√ß√£o, para cada uma das q queries, o pior caso seria l = 0 e r = n-1, que faz o la√ßo interno iterar n vezes, o que nos d√° uma complexidade O(n*q). Precisamos ser mais r√°pidos.
Defini√ß√£o Delta encoding √© uma t√©cnica para resolver problemas desse tipo. Precisamos fazer atualiza√ß√µes em intervalos, mas como o vetor s√≥ precisa ser visualizado no final, o que fazemos √© fazer todas de uma vez s√≥ no final. A ideia por tr√°s dessa solu√ß√£o funciona da seguinte forma: Vamos criar um vetor auxiliar delta, que √© o vetor que vai acumular as atualiza√ß√µes.
Atualiza√ß√£o do intervalo (l,r) Dessa forma, quando estivermos lendo uma query (l,r,x), faremos o seguinte:
vector\u003cint\u003e delta(n,0); for(int i = 0; i \u003c q; i++){ int l,r,x; scanf("%d %d %d",\u0026l,\u0026r,\u0026x); delta[l] += x; delta[r+1] -= x; } O trecho de c√≥digo acima √© o delta encoding por si s√≥, o nome √© esse porque estamos codificando a informa√ß√£o de que precisamos atualizar aquele intervalo. A parte interessante, √© que nesse la√ßo, nossa atualiza√ß√£o funciona em O(1).
Obtendo os valores ap√≥s v√°rias atualiza√ß√µes Tendo as informa√ß√µes organizadas dessa forma, isso nos permite percorrer o vetor delta da esquerda pra direita obtendo os valores finais do vetor, em O(n).
Isso √© feito criando uma vari√°vel atual, inicializada com 0. Ent√£o, enquanto percorremos o vetor, na i-√©sima itera√ß√£o, sempre somamos a essa vari√°vel delta[i], ap√≥s isso, a configura√ß√£o final de v[i] ser√° o valor de atual.
Ent√£o, √© por esse motivo que guardamos a informa√ß√£o daquela forma no vetor. Como vamos percorrer da esquerda pra direita, quando fazemos v[l] += x, estamos dizendo, quando voc√™ passar no √≠ndice l, voc√™ deve adicionar mais x a resposta. E quando fazemos v[r+1] -= x, dizemos: quando seu √≠ndice for maior que r, pare de considerar x no resultado.
Dessa forma, a vers√£o final:
vector\u003cint\u003e delta(n+5,0); vector\u003cint\u003e v(n); for(int i = 0; i \u003c q; i++){ int l,r,x; scanf("%d %d %d",\u0026l,\u0026r,\u0026x); delta[l] += x; delta[r+1] -= x; } int atual = 0; for(int i = 0; i \u003c n; i++){ atual += delta[i]; v[i] = atual; } for(int i = 0; i \u003c n; i++){ printf("%d ",v[i]); } printf("\\n"); Ressalvas An√°logo as somas prefixas, mas de forma inversa, essa ED processa atualiza√ß√µes em intervalo muito rapidamente O(1), por√©m, quando √© necess√°rio saber os valores do vetor, e h√° atualiza√ß√µes pendentes, √© necess√°rio percorrer novamente o vetor todo O(n), ent√£o essa ED funciona melhor com muitas atualiza√ß√µes e poucas consultas.
`,description:"",tags:["iniciante"],title:"Delta Encoding",uri:"/materiais/ed/delta_encoding/"},{content:`Problemas de consulta em intervalos Suponha que voc√™ se depare com o seguinte problema:
√â dado um vetor V, com n n√∫meros inteiros, em seguida, um n√∫mero q de consultas que ser√£o feitas nesse vetor. Cada consulta consiste de um par de inteiros (l,r), representando um intervalo, a resposta para cada consulta √© a soma dos inteiros nesse intervalo(inclusivo).
At√© agora, em qual complexidade sabemos resolver esse problema?
A solu√ß√£o simples seria:
int n; int q; cin \u003e\u003e n; vector\u003cint\u003e v(n); // leitura dos elementos for(int i = 0; i \u003c n; i++){ scanf("%d",v+i); } cin \u003e\u003e q; // respondendo as consultas for(int i = 0; i \u003c q; i++){ int l, r; scanf("%d %d",\u0026l,\u0026r); int soma = 0; for(int j = l; j \u003c= r; j++){ soma += v[j]; } cout \u003c\u003c soma \u003c\u003c endl; } Essa solu√ß√£o teria complexidade O(q*n) aonde q √© o n√∫mero de consultas, e n o tamanho do vetor.
Defini√ß√£o O vetor de somas prefixas √© uma ED que podemos usar para resolver esse tipo de problema de forma mais eficiente. A ideia √© construir um vetor P tal que P[i] representa a soma do √≠ndice 0 at√© o √≠ndice i.
Tendo essas informa√ß√µes, para responder uma consulta (l,r) podemos usar a seguinte ideia: sabe-se que em P[r] temos a resposta para a consulta (0,r), com isso, podemos agora subtrair a parte que n√£o nos interessa, (0,l-1) ou P[l-1].
Constru√ß√£o A constru√ß√£o do vetor de somas prefixas em v tem complexidade O(n).
vector\u003cint\u003e psum(v.size(), v[0]); for(int i = 1; i \u003c v.size(); i++) { psum[i] = v[i] + psum[i-1]; } Resposta de consulta (l,r) A resposta √†s consultas tem complexidade constante, j√° que s√£o s√≥ acessos ao vetor. Apenas tem-se que tomar cuidado quando l = 0.
int sum(int l, int r){ if(l == 0) return psum[r]; else return psum[r] - psum[l-1]; } Ressalvas Vale lembrar que essa ED √© mais interessante de ser usada quando n√£o h√° (ou h√° poucas) atualiza√ß√µes nos valores do vetor, caso haja, √© necess√°rio recomputar as somas prefixas do vetor todo em O(n), o que n√£o √© uma complexidade atrativa.
Al√©m disso, esse racioc√≠nio n√£o precisa se extender apenas a somas, funciona para opera√ß√µes como xor, por exemplo.
`,description:"",tags:["iniciante"],title:"Soma de Prefixos",uri:"/materiais/ed/psum/"},{content:`Segment tree (Segtree) √© outra estrutura de dados para lidar com problemas de consulta em intervalos. O que tornas as segtrees poderosas √© sua capacidade de fazer atualiza√ß√£o e consulta em intervalos em complexidade O(log n), al√©m do tipo da consulta ser bem abrangente.
A ideia √© a seguinte: Criamos uma √°rvore, de forma que cada nodo representa a informa√ß√£o que desejamos saber a respeito de um segmento do vetor, e tem dois filhos, um filho representa a metade esquerda desse intervalo, e o outro, a metade direita. Esse processo recursa at√© que os intervalos atinjam tamanho 1.
Aqui h√° uma demonsta√ß√£o visual de como funciona: https://visualgo.net/en/segmenttree
√â interessante entender o funcionamento da segtree pois, por mais que tenhamos o c√≥digo pronto, quando mudamos de opera√ß√£o ou precisamos inserir long longs, ser√° necess√°rio mexer na sua estrutura interna.
Representa√ß√£o Nossa segtree ser√° representada como um vetor. Cada nodo ter√° um id nesse vetor, e o conte√∫do dessa posi√ß√£o representa a informa√ß√£o que aquele nodo guarda. A raiz da segtree ser√° o nodo 0, que guarda a informa√ß√£o sobre o vetor todo. A partir do √≠ndice id de um nodo, podemos obter os filhos sem colis√µes da seguinte forma: √≠ndice dos filhos esquerdo e direito s√£o (id*2 + 1,id*2 +2), respectivamente.
vector\u003cint\u003e st; int size; Opera√ß√£o Essa fun√ß√£o define que informa√ß√£o queremos saber a respeito dos elementos do vetor. Nese caso √© uma segtree que computa o m√°ximo de intervalos, mas poderia ser soma, m√≠nimo, produto, xor, gcd, mmc(lcm), or e and l√≥gicos etc.
int f(int a, int b){ return max(a,b); } Elemento neutro O elemento neutro depende da opera√ß√£o. Como queremos saber os m√°ximos, o elemento neutro dessa opera√ß√£o seria um n√∫mero muito baixo, que nunca ser√° o m√°ximo.
Caso n√£o saiba a defini√ß√£o de elemento neutro, a defini√ß√£o √© a seguinte: e √© um elemento neutro da opera√ß√£o f se f(e,x) = x para todo x.
Caso fosse uma soma, nosso elemento neutro seria 0, caso fosse um produto, seria 1, etc..
int el_neutro = -(1e9 + 7); Consulta A fun√ß√£o recursiva abaixo responde √†s consultas na segtree. Cada par√¢metro tem o seguinte significado:
sti: id do nodo que estamos na segment tree stl: limite inferior do intervalo que aquele nodo representa(inclusivo) str: limite superior do intervalo que aquele nodo representa(inclusivo) l : limite inferior do intervalo que queremos fazer a consulta r : limite superior do intervalo que queremos fazer a consulta int query(int sti, int stl, int str, int l, int r){ //O nodo est√° fora do intervalo que estamos interessados, retorne o elemento neutro que n√£o afeta a consulta if(str \u003c l || r \u003c stl) return el_neutro; // O nodo est√° completamente inclu√≠do no intervalos que estamos interessados, retorne a informa√ß√£o contida naquele nodo. if(stl \u003e= l and str \u003c= r) return st[sti]; // Se chegarmos aqui, √© porque esse Nodo est√° parcialmente contido no intervalo que estamos interessados. Ent√£o, continuamos procurando nos filhos. int mid = (str+stl)/2; return f(query(sti*2+1,stl,mid,l,r),query(sti*2+2,mid+1,str,l,r)); } Atualiza√ß√£o Essa fun√ß√£o atualiza um elemento da segtree. Cada par√¢metro tem o seguinte significado:
sti: id do nodo que estamos na segment tree stl: limite inferior do intervalo que aquele nodo representa(inclusivo) str: limite superior do intervalo que aquele nodo representa(inclusivo) i : √≠ndice do vetor que queremos atualizar amm: novo valor daquele √≠ndice no vetor void update(int sti, int stl, int str, int i, int amm){ // Chegamos no √≠ndice que queremos, vamos atualizar o valor if(stl == i and str == i){ st[sti] = amm; return; } // O intervalo que estamos n√£o contem o √≠ndice que queremos atualizar, retorne if(stl \u003e i or str \u003c i) return; // O intervalo cont√©m o √≠ndice, mas temos que chegar no nodo espec√≠fico, recurse para os filhos. int mid = (stl + str)/2; update(sti*2+1,stl,mid,i,amm); update(sti*2+2,mid+1,str,i,amm); // Ap√≥s os filhos mais em baixo, precisamos atualizar o valor desse nodo st[sti] = f(st[sti*2+1],st[sti*2+2]); } Declara√ß√£o Essa √© a classe com as funcionalidades implementadas.
class SegTree{ vector\u003cint\u003e st; int size; int el_neutro = -(1e9 + 7); int f(int a, int b){ return max(a,b); } int query(int sti, int stl, int str, int l, int r){ if(str \u003c l || r \u003c stl) return el_neutro; if(stl \u003e= l and str \u003c= r) return st[sti]; int mid = (str+stl)/2; return f(query(sti*2+1,stl,mid,l,r),query(sti*2+2,mid+1,str,l,r)); } void update(int sti, int stl, int str, int i, int amm){ if(stl == i and str == i){ st[sti] += amm; return; } if(stl \u003e i or str \u003c i) return; int mid = (stl + str)/2; update(sti*2+1,stl,mid,i,amm); update(sti*2+2,mid+1,str,i,amm); st[sti] = f(st[sti*2+1],st[sti*2+2]); } public: SegTree(int n): st(4*n,0){size = n;} int query(int l, int r){return query(0,0,size-1,l,r);} void update(int i, int amm){update(0,0,size-1,i,amm);} }; Interface Os m√©todos que mostramos s√£o todos internos da segtree, na hora de chama-los, n√£o precisamos passar tantos par√¢metros assim.
public: SegTree(int n): st(4*n,0){size = n;} int query(int l, int r){return query(0,0,size-1,l,r);} void update(int i, int amm){update(0,0,size-1,i,amm);} SegTree Construtor, recebe o tamanho do vetor.
query Executa uma consulta, recebe o intervalo(l,r) da consulta, retorna o resultado.
update Atualiza um √≠ndice no vetor recebe o √≠ndice e o novo valor.
Constru√ß√£o vector\u003cint\u003e v; SegTree st(v.size()); for(int i = 0; i\u003c v.size();i++){ st.update(i,v[i]); } Atualiza√ß√µes em intervalos A segtree que temos at√© agora faz atualiza√ß√£o de uma posi√ß√£o no vetor e consulta de qualquer em intervalo, em O(log n). Mas e se precisarmos atualizar um intervalo, por exemplo: ‚ÄúTodos os elementos da posi√ß√£o 1 at√© 10 recebem 2‚Äù. Assim, a melhor forma que ter√≠amos de fazer isso seria
SegTree st(n); // preenche segtree for(int i = 1 ; i \u003c= 10; i++){ st.update(i,2); } O que tem complexidade O(n * log n). Precisamos fazer isso mais r√°pido.
Lazy progapation Lazy propagation √© uma altera√ß√£o na segtree que nos permite fazer atualiza√ß√µes em intervalos em O(log n).
A ideia Em nossa abordagem anterior, o que tornava a execu√ß√£o lenta √© que procur√°vamos o nodo respons√°vel por cada elemento que precisava ser atualizado.
Para acelerar esse processo, podemos usar uma ideia parecida com a da consulta, em vez de atualizar individualmente os elementos, podemos atualizar a resposta nos intervalos que os cont√©m, e postergar a atualiza√ß√£o nos filhos.
Para implementar lazy propagation, cada configura√ß√£o de segtree vai requerer uma implementa√ß√£o um pouco diferente, por isso, ser√° necess√°rio entender o que cada parte do c√≥digo est√° fazendo.
O exemplo a seguir ser√° de uma segtree de soma, aonde a atualiza√ß√£o de intervalo vai setar todos os elementos para um qualquer.
vetor de lazy A ideia √© introduzir um vetor extra com o seguinte significado: Quando eu passar no nodo identificado por id, em uma consulta, ou outra atualiza√ß√£o, preciso atualizar seu valor para lazy[id]. O vetor has indica se h√° uma atualiza√ß√£o para ser feita naquele nodo.
vector\u003cint\u003e st; vector\u003cint\u003e lazy; vector\u003cbool\u003e has; int size; A propaga√ß√£o A fun√ß√£o de propaga√ß√£o √© a fun√ß√£o que atualiza o valor de um nodo, e posterga a atualiza√ß√£o para os filhos. Precisamos chamar essa fun√ß√£o toda vez que passamos por algum nodo.
void propagate(int sti, int stl, int str){ // Se h√° algo para atualizar, atualize() if(has[sti]) //O valor desse nodo da segtree ser√° (n√∫mero de elementos que esse intervalo representa vezes novo valor de cada elemento do intervalo) st[sti] = lazy[sti] * (str - stl + 1); // Se o n√≥ representa um segmento de tamanho maior que 1, isto √©, n√£o √© terminal, propague a atualiza√ß√£o para os filhos. if(stl != str){ lazy[sti*2 + 1] = lazy[sti]; lazy[sti*2 + 2] = lazy[sti]; has[sti*2 + 1] = true; has[sti*2 + 2] = true; } // agora n√£o √© mais necess√°rio atualizar esse nodo has[sti] = false; } } A fun√ß√£o de atualiza√ß√£o em intervalo Essa √© a fun√ß√£o que realiza a atualiza√ß√£o de intervalos. O significado dos argumentos √©:
sti: id do nodo que estamos na segment tree stl: limite inferior do intervalo que aquele nodo representa(inclusivo) str: limite superior do intervalo que aquele nodo representa(inclusivo) l: limite inferior do intervalo que queremos atualizar no vetor r: limite superior do intervalo que queremos atualizar no vetor amm: novo valor dos elementos nesse intervalo void update_range(int sti, int stl, int str, int l,int r, int amm){ if(stl \u003e= l and str \u003c= r){ // O valor que ser√° atribuido a todo elemento no intervalo lazy[sti] = amm; has[sti] = true; propagate(sti, stl, str); return; } if(stl \u003e r or str \u003c l) return; int mid = (stl + str)/2; update_range(sti*2+1,stl,mid,l,r,amm); update_range(sti*2+2,mid+1,str,l,r,amm); st[sti] = f(st[sti*2+1],st[sti*2+2]); } Vers√£o final Essa √© a vers√£o final da nossa ED.
class SegTree{ vector\u003cint\u003e st; vector\u003cint\u003e lazy; vector\u003cbool\u003e has; int size; int el_neutro = 0; int f(int a, int b){ return a + b; } void propagate(int sti, int stl, int str){ if(has[sti]){ st[sti] = lazy[sti] * (str - stl + 1); if(stl != str){ lazy[sti*2 + 1] = lazy[sti]; lazy[sti*2 + 2] = lazy[sti]; has[sti*2 + 1] = true; has[sti*2 + 2] = true; } has[sti] = false; } } int query(int sti, int stl, int str, int l, int r){ propagate(sti, stl, str); if(str \u003c l || r \u003c stl) return el_neutro; if(stl \u003e= l and str \u003c= r) return st[sti]; int mid = (str+stl)/2; return f(query(sti*2+1,stl,mid,l,r),query(sti*2+2,mid+1,str,l,r)); } void update_range(int sti, int stl, int str, int l,int r, int amm){ if(stl \u003e= l and str \u003c= r){ lazy[sti] = amm; has[sti] = true; propagate(sti, stl, str); return; } if(stl \u003e r or str \u003c l) return; int mid = (stl + str)/2; update_range(sti*2+1,stl,mid,l,r,amm); update_range(sti*2+2,mid+1,str,l,r,amm); st[sti] = f(st[sti*2+1],st[sti*2+2]); } public: SegTree(int n): st(4*n,0), lazy(4*n,0),has(4*n,false){size = n;} int query(int l, int r){return query(0,0,size-1,l,r);} void update_range(int l, int r, int amm){update_range(0,0,size-1,l,r,amm);} }; Problemas recomendados Compras em FdI Produto do Intervalo Distinct Characthers Cards Sorting Ant Colony Xenia and Bit Operations Consultas Horr√≠veis SUM and REPLACE Sereja and Brackets Kquery DQuery `,description:"",tags:["intermediario"],title:"Segment Trees",uri:"/materiais/ed/segtree/"},{content:`Nesse tutorial vamos falar sobre uma estrutura de dados chamada Sparse Table, que √© uma estrutura de dados poderosa para resolvermos range queries de algumas opera√ß√µes espec√≠ficas em complexidades superiores as de uma Segment Tree por exemplo.
Por exemplo, uma Sparse Table conseque resolver range minimum(ou maximum) query em O(1), enquanto numa segment tree precisar√≠amos de O(log n). Outro exemplo poderia ser range query de gcd, numa Segment Tree podemos resolver range queries de GCD em O(log^2 n), j√° na sparse table conseguimos isso em O(log n). No geral, quando a opera√ß√£o da range query tem uma propriedade chamada idempot√™ncia, podemos tirar um log da complexidade usando a Sparse Table.
Idempot√™ncia A propriedade que uma opera√ß√£o precisa ter para que possamos ganhar tempo de execu√ß√£o usando a Sparse Table √© a idempot√™ncia. Na defini√ß√£o que estamos levando em considera√ß√£o, uma opera√ß√£o op (bin√°ria) √© idempotente quando para todo x e todo y, op(x,y) = op(x,op(x,y)). Poder√≠amos dar uma defini√ß√£o mais precisa por√©m o que precisamos saber √© que numa opera√ß√£o idempotente, aplicar a opera√ß√£o uma vez √© o mesmo que aplicar 2,3,4,‚Ä¶ qualquer n√∫mero de vezes maior que 0.
A opera√ß√£o min possui essa propriedade, para qualquer x,y, min(x,y) = min(x,min(x,y)). Outro exemplo √© o pr√≥prio gcd como mencionado acima. para qualquer x,y, gcd(x,y) = gcd(x,gcd(x,y)).
Mas essa propriedade n√£o √© verdade para a opera√ß√£o de soma, por exemplo, seja sum(x,y) = x + y, sum(3,4) != sum(3,sum(3,4)), aplicar a opera√ß√£o mais de uma vez com os mesmos argumentos a direita(ou a esquerda) resulta num resultado diferente, ent√£o soma n√£o √© idempotente. Na verdade as opera√ß√µes mais comuns v√£o ser GCD e min/max, mas √© importante saber a propriedade para entender porque a ideia que vamos usar funciona e tamb√©m caso haja uma opera√ß√£o meio maluca que seja idempotente saber se consegue montar a Sparse table sobre ela.
O pulo do gato Imagine que tenhamos uma fun√ß√£o m√°gica, chamada dp(n,k), que retorna a opera√ß√£o aplicada no intervalo [n, n + (2^k) - 1].
k = 0, [n, n] k = 1, [n, n + 1] k = 2, [n, n + 3] k = 3, [n, n + 7] . . Ent√£o se a opera√ß√£o for min, vai ser o m√≠nimo dos elementos nesse intervalo, se for gcd vai ser o gcd entre todos os n√∫mero desse intervalo etc. Certo ent√£o com essa fun√ß√£o, vamos fingir que recebemos uma min query para o intervalo [4, 17] em um vetor.
Como a opera√ß√£o √© idempotente, podemos fazer o seguinte. A resposta vai ser min(dp(4,3), dp(10,3)),
[0, 1, 2, 3, (4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)] [1, 3, 2, 5, (9, 6, 8, 0, 1, 2, 40, 51, 2, 4, 63, 20, 2, 4)] O intervalo que estamos interessados est√° demarcado com um par√™ntese. Bem, dp(4, 3) = 0, e dp(10,3) = 2, e min(0,2) = 0, que realmente √© o m√≠nimo do intervalo. Se a query fosse no intervalo [4,10] poder√≠amos fazer min(dp(4,2), dp(7,2)), e assim por diante.
Ent√£o o que n√≥s estamos fazendo aqui √© selecionando uma potencia de dois e duas posi√ß√µes aonde duas chamadas a essa fun√ß√£o m√°gica v√£o ser suficientes para cobrir exatamente o intervalo que estamos interessados. E a opera√ß√£o precisa ser idempotente porque como estamos selecionando apenas intervalos que tem tamanhos de pot√™ncias de dois, no caso geral n√£o conseguimos selecionar dois intervalos que n√£o tenham interse√ß√£o, e caso a opera√ß√£o n√£o seja idempotente, isso far√° com que a interse√ß√£o seja contada duas vezes, fazendo ent√£o com que essa ideia n√£o funcione. Voltaremos mais tarde na implementa√ß√£o de como selecionar essas pot√™ncias.
Ent√£o a complexidade que temos at√© ent√£o para resolver consultas √© a seguinte: O(k + 2*q) aonde k √© o custo da opera√ß√£o, e q √© o custo da nossa fun√ß√£o m√°gica. Veremos que conseguimos com programa√ß√£o din√¢mica precomputar os valores pra essa fun√ß√£o fazendo com que as chamadas a ela tenham tempo constante. Como min() tem tempo constante de gcd() tempo log, √© assim que resultamos nas complexidades mencionadas no come√ßo do texto.
Recorr√™ncia Esta √© a recorr√™ncia da programa√ß√£o din√¢mica, nessa recorr√™ncia, estamos apenas dizendo o seguinte: O resultado da opera√ß√£o em um intervalo √© o resultado da primeira metade combinado com o resultado da segunda metade.
int dp(int i, int k) { if(k == 0) { return v[i]; } return op(dp(i,k-1),dp(i + (1 \u003c\u003c (k-1)). k-1)); } Vers√£o recursiva int memo[SIZE][log2(SIZE)+1]; vector\u003cint\u003e v(SIZE); int dp(int i, int k) { if(i \u003e= SIZE) return 0; if(k == 0) { return v[i]; } if(memo[i][k] != -1) return memo[i][k]; return memo[i][k] = min(dp(i,k-1),dp(i + (1 \u003c\u003c (k-1)), k-1)); } Vers√£o iterativa int memo[SIZE][log2(SIZE)+1]; vector\u003cint\u003e v(SIZE); for(int i = 0; i \u003c SIZE; i++) { memo[i][0] = v[i]; } for(int k = 1; k \u003c= log2(SIZE); k++) { for(int i = 0; i \u003c SIZE; i++) { if(i + (1 \u003c\u003c k -1) \u003e= SIZE) { memo[i][k] = memo[i][k-1]; } else { memo[i][k] = op(memo[i][k-1], memo[i + (1 \u003c\u003c (k-1))][k-1]); } } } Precisamos apenas computar para pot√™ncias at√© log2(SIZE) + 1 porque pot√™ncias maiores que essa com certeza j√° s√£o maiores que o vetor.
Outro detalhe de implementa√ß√£o √© que temos que tomar cuidado para n√£o acessar fora do vetor, algumas alternativas que temos podem ser por exemplo adicionar um if(i \u003e= SIZE) return 0; na vers√£o recusiva. Na vers√£o iterativa fazemos de maneira an√°loga.
Estamos preenchendo uma tabela de tamanho O(n log n) aonde n √© o tamanho da √°rvore, para preencher cada c√©lula dessa tabela fazemos opera√ß√µes constantes e uma chamada a op, ent√£o a complexidade de montarmos essa tabela para responder as queries √© O(n log n * K), aonde K √© a complexidade de op.
Ajustando a consulta Acima demos alguns exemplos de como podemos usar a recorr√™ncia que definimos para computar intervalos espec√≠ficos, por exemplo para [4,17], escolhemos (4,3) e (10,7). O intervalo em quest√£o tem tamanho 14, ent√£o a menor pot√™ncia de 2 que podemos usar para cobri-lo √© 8(2^3). Em geral essa menor pot√™ncia pode ser calculada pela express√£o log2(b-a), aonde log2(x) √© o ch√£o do logaritmo de x na base 2 e assumimos que b \u003e a.
log2(13) = 3 log2(14) = 3 log2(15) = 3 log2(16) = 4 . . . E sobre as posi√ß√µes da query, a primeira sempre ser√° no come√ßo do intervalo, e a segunda temos que ajustar de forma que o √∫ltimo elemento levado em considera√ß√£o seja o √∫ltimo.
int query(int a, int b) { int lg = log2(b-a); return F(tb[a][lg],tb[1 + b-(1 \u003c\u003c lg)][lg]) } Conte√∫do complementar https://www.youtube.com/watch?v=EKcQt-74bNw
Exerc√≠cios recomendados `,description:"",tags:["avancado"],title:"Sparse Table",uri:"/materiais/ed/sparse_table/"},{content:`Busca bin√°ria √© um algoritmo de divis√£o e conquista usado em sua maior parte para minimizar o tempo de uma busca linear. Na busca bin√°ria sempre estamos procurando o ‚Äúo maior x valor que satisfaz uma condi√ß√£o c(x)‚Äù ou ‚Äúo menor x valor que satisfaz uma condi√ß√£o c(x)‚Äù, retornaremos nesse ponto depois no texto.
Imagine voc√™ com um livro de 1000 p√°ginas em m√£os no momento em que o professor pede para que o abra no come√ßo do capitulo 6 se√ß√£o 4. Existem v√°rias maneiras de se alcan√ßar a p√°gina certa. Uma delas √© ir de uma em uma at√© que se alcance a p√°gina desejada. Outra maneira √© ir pulando alguns blocos de p√°ginas, se voc√™ est√° numa p√°gina depois do come√ßo do capitulo 6 se√ß√£o 4 pula algumas p√°ginas para tras, se voc√™ est√° numa p√°gina antes, pula algumas p√°ginas para frente.
Perceba que no exemplo acima uma busca linear (passar de p√°gina em p√°gina) demoraria muito mais do que ir pulando algumas partes do livro. E fazendo da segunda maneira involuntariamente voc√™ acaba aplicando uma vers√£o primitiva do que chamamos de busca bin√°ria.
O algortimo Usando a mesma ideia do livro por√©m agora em uma linguagem mais computacional. No lugar de 1000 p√°ginas podemos ter um vetor de 1000 posi√ß√µes onde a i-√©sima tem um pair \u003ccapitulo, se√ß√£o\u003e da pagina i, por exemplo, se a p√°gina 125 faz parte do cap√≠tulo 4 se√ß√£o 2 ent√£o v[125] = make_pair(4, 2);. E digamos que o cap√≠tulo 6 se√ß√£o 4 est√° na p√°gina 375(que n√£o sabemos no come√ßo da busca).
Primeiro podemos, por exemplo, para a p√°gina 400. A partir do pair daquela posi√ß√£o aprendemos que o que procuramos est√° antes de 400, ent√£o agora n√£o precisamos procurar a resposta no intervalo [1, 1000] e sim no intervalo [1, 399]. Podemos fazer um segundo chute na posicao 300, por exemplo pois podemos chutar em qualquer posi√ß√£o do intervalo, e depois de olhar v[300] aprendemos que a resposta est√° no intervalo [301, 399]. Podemos ent√£o chutar na p√°gina 375 e encontrar que esta √© a resposta que procuramos.
O √∫nico problema do que foi descrito acima √© determinar como chutar o elemento dentro do intervalo j√° que os chutes foram meio aleat√≥rios. O primeiro chute foi no elemento 400 num intervalo [1, 1000], depois de olhar o elemento poder√≠amos passar a ter que olhar o intervalo [1, 399](se o que procuramos est√° antes) ou [401, 1000](se o que procuramos est√° depois), tivemos sorte e caimos no primeiro caso mas no pior caso poder√≠amos cair no intervalo maior. O jeito de garantirmos de no pior caso sempre irmos para um intervalo de menor tamanho possivel √© chutar de uma forma a dividir o intervalo em 2 intervalos de tamanhos (aproximadamente) iguais. Podemos fazer isso s√≥ chutando na metade do intervalo, assim √© melhor fazer o primeiro chuta na posi√ß√£o 500 e nao 400.
Condi√ß√µes para aplicar busca bin√°ria Nem sempre √© poss√≠vel aplicar busca bin√°ria para encontrar uma resposta: um exemplo seria um livro cujos capitulos e se√ßoes nao est√£o em ordem crescente. Nessa situa√ß√£o, n√£o poderiamos mais ter certeza que um capitulo ou se√ß√£o maior estaria a direita.
Como mencionamos acima, na busca bin√°ria estamos procurando o maior ou menor valor que satisfaz uma propriedade. Ent√£o por exemplo, no exemplo acima, estamos buscando pelo menor √≠ndice(p√°gina) do vetor(livro) que satisfaz a condi√ß√£o ‚Äúestar num (cap√≠tulo, se√ß√£o) maior ou igual a (6,4)‚Äù, porque a primeira p√°gina que satisfazer essa propriedade ser√° o in√≠cio do cap√≠tulo 6 se√ß√£o 4. Considere agora o outro exemplo de aplicarmos busca binaria no vetor para descobrir se um elemento x esta l√° ou n√£o. Uma maneira de fazer isso seria procurar pelo menor elemento y que seja maior ou igual x, se y for igual a x, ent√£o x est√° no vetor, caso contr√°rio x n√£o est√° no vetor.
Dizemos que √© poss√≠vel aplicar busca bin√°ria em um problema quando a checagem se um valor satisfaz as condi√ß√µes apresenta monotonicidade. Formalmente, monotonicidade pode ser definida da seguinte forma. Seja check(x) uma fun√ß√£o que verifica uma propriedade de x Se para todo x, check(x) = true implica check(x+1) = true, ou para todo x, check(x) = false implica check(x+1) = false, ent√£o a fun√ß√£o check √© mon√≥tona.
Ent√£o, se x = 11 e o vetor v = [1,2,3,5, 8, 11, 12, 14, 16] observe o que acontece com o comportamento de uma fun√ß√£o check que checa se um elemento √© maior ou igual a x.
bool check(int val) { return val \u003e= x; } [1,2,3,5,8,11,12,14,16] [0,0,0,0,0,1,1,1,1,1] Ent√£o se colocarmos graficamente os resultados de uma fun√ß√£o check monotona, veremos exatamente isso, ou um monte de valores 0s e a partir de certo ponto todos s√£o 1s, ou o contr√°rio, um monte de 1s e a partir de certo ponto todos s√£o 0s. No exemplo a cima √© a primeira possibilidade.
Ent√£o a fun√ß√£o check para essa situa√ß√£o √© mon√≥tona, e isso √© relevante porque se um valor do vetor satisfizer a condi√ß√£o, todos os valores a direita tamb√©m v√£o satisfaz√™-la, e de forma an√°loga, todos os valores a esquerda de um √≠ndice que n√£o satisfaz a condi√ß√£o, tamb√©m n√£o v√£o satisfazer, e √© isso que nos permite aplicar busca bin√°ria. E a fun√ß√£o check s√≥ se torna mon√≥tona nesse exemplo quando o vetor est√° ordenado, por isso busca bin√°ria s√≥ √© feita em vetores ordenados : ).
Ent√£o o que faremos √© chutar intervalo aonde a resposta com certeza estar√° no come√ßo, fazemos ent√£o v√°rias intera√ß√µes checando no meio, e dependendo da resposta, descartamos os elementos a direita ou a esquerda, mas sempre dividimos o tamanho do intervalo por 2, at√© que o intervalo tenha tamanho 1.
Complexidade Tudo muito massa, mas falta a complexidade! Depois de saber isso podemos come√ßar a aplicar esse algoritmo nos problemas por ae :)
por enquanto nosso algoritmo de maneira abstrata √© o seguinte
while(tamanho do intervalo que a resposta pode estar != 1) { chuta no meio e descarta a metade da direita ou da esquerda(dependendo do resultado), dividindo o intervalo por 2; } Suponha um vetor ordenado de tamanho N onde vamos aplicar o algoritmo de busca bin√°ria e o valor procurado n√£o est√° presente no vetor (pior caso). Na nossa primeira itera√ß√£o iremos dividir o vetor em 2 partes ou seja teremos N/2 elementos restantes, na segunda itera√ß√£o iremos dividir do que restou e teremos (N/2)/2 ou seja N/4, seguindo essa l√≥gica na K-√©sima itera√ß√£o vamos dividir o tamanho do vetor K vezes por 2, ou seja, N/(2^K) e como estamos calculando complexidade temos que pensar no pior caso, quando chegarmos no ponto onde teremos um espa√ßo de apenas 1 elemento(e verificamos que o elemento n√£o est√° no vetor). O que estamos buscando para saber a complexidade √© K (quantidade de passos) para o pior caso ent√£o temos que N/(2^K) = 1 da√≠ temos que N = 2^K e tirando o log2 dos dois lados temos que K = log2(N). Ent√£o no pior caso nosso algortimo demora O(log2(N)) passos, N sendo o tamanho do intervalo inicial. Se a fun√ß√£o de checagem tiver uma complexidade O(f(x)), ent√£o teremos complexidade no total O(log2(N) * f(x))*.
C√≥digo base para busca bin√°ria H√° v√°rias maneiras de se implementar busca bin√°ria, vamos apresentar v√°rias delas. Vamos usar sempre a fun√ß√£o check em separado, os jeitos de implementar diferente s√£o apenas do corpo da busca bin√°ria.
bool check(int val){ // nessa fun√ß√£o checamos se uma resposta satisfaz as condi√ß√µes para ser uma resposta v√°lida, e retornamos um booleano dependendo disso. } Tipo 1 Valor m√≠nimo (Menor valor que torna check verdadeiro) int l = a;// sei que a resposta n√£o √© menos que a int r = b;// sei que a resposta n√£o √© mais que b (as vezes esse chute tem que ser bom, para evitar overflow) while(r \u003e l+1){// repita enquanto o intervalo tiver tamanho \u003e 2 int mid = (l + r)/2; if(check(mid)){ // mid √© v√°lido r = mid; // como queremos minimizar a resposta, e mid √© uma resposta v√°lida //descartamos tudo a direita de mid (mas n√£o mid) } else{ l = mid+1; // Se mid n√£o √© v√°lido, descartamos ele e tudo abaixo. } } // Ao final desse la√ßo, a resposta pode estar em l ou r. // Queremos minimizar a resposta, ent√£o se l for v√°lido, // ficaremos com l, e caso contr√°rio, com r int ans = r; if(check(l)){ ans = l; } Valor m√°ximo (Maior valor que torna check verdadeiro) int l = a; int r = b; while(r \u003e l+1){ int mid = (l + r)/2; if(check(mid)){// mid √© v√°lido l = mid; // como queremos maximizar a resposta, e mid √© uma resposta v√°lida //descartamos tudo a esquerda de mid (mas n√£o mid) } else{ r = mid-1; // Se mid n√£o √© v√°lido, descartamos ele e tudo acima. } } int ans = r; if(check(l)){ ans = l; } Tipo2 Valor m√≠nimo int l = a; int r = b; while (l \u003c r) { int mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid + 1; } // a resposta fica em l Valor m√°ximo √â f√°cil alterar o c√≥digo de valor m√≠nimo para encontrar o valor m√°ximo: Imagine que uma fun√ß√£o de check d√™ o resultado [1,1,1,0,0]. Veja que encontrar o √∫ltimo 1 nesse array √© equivalente a encontrar o primeiro 0 e subtrair 1 da posi√ß√£o! Assim, podemos aplicar a busca bin√°ria de valor m√≠nimo no valor contr√°rio do checker (!check(mid)) e subtrair 1 da resposta ao final.
int l = a; int r = b; while (l \u003c r) { int mid = (l + r) / 2; if (!check(mid)) r = mid; // check vira !check else l = mid + 1; } // a resposta fica em l-1 Detalhe: como usamos l-1 no final, a busca n√£o inclui b, ou seja, buscamos no intervalo [a, b).
Exemplos de aplica√ß√£o Implementa√ß√£o de lower_bound Consideremos o problema de achar o indice do primeiro elemento maior ou igual um x num vetor v de tamanho n.
int v[MAXN], n; // vetor global para facilitar o c√≥digo // funcao que retorna se id √© uma resposta v√°lida pro nosso problema bool check(int id, int x){ return v[id] \u003e= x; } // retorna o indice do primeiro elemento \u003e= x, considerando que o vetor v est√° ordenado // se todos os elementos sao menores que x, retorna -1 int lower_bound(int x){ int L, R, ans; L = 0; // come√ßo do intervalo que consideraremos R = n-1; // fim do intervalo que consideraremos ans = n; // come√ßamos a resposta com um valor fora do vetor, inv√°lido para marcar se conseguimos achar alguma resposta ou nao while(L \u003c= R){ // enquanto tiver algum n√∫mero no intervalo int mid = (L+R)/2; if(check(mid, x)){ // se esse mid √© uma resposta apropriada ans = mid; // achamos uma nova resposta para o problema R = mid-1; // se mid √© uma resposta temos que tentar procurar uma resposta menor(nesse problema em especifico) } else{ // se mid nao √© uma resposta pro nosso problema L = mid+1; // precisamos procurar em indices maiores(neste problema) } } if(ans == n) return -1; // se ans ainda √© n depois da busca bin√°ria, ent√£o nunca achamos resposta return ans; } Perceba que se quisermos achar o indice do √∫ltimo elemento maior ou igual um x num vetor v de tamanho n.
long long int v[MAXN], n; // vetor global para facilitar o c√≥digo // funcao que retorna se id √© uma resposta v√°lida pro nosso problema bool check(int id, int x){ return v[id] \u003e= x; } // retorna o indice do primeiro elemento \u003e= x, considerando que o vetor v est√° ordenado // se todos os elementos sao menores que x, retorna -1 int lower_bound(int x){ int L, R, ans; L = 0; // come√ßo do intervalo que consideraremos R = n-1; // fim do intervalo que consideraremos ans = n; // come√ßamos a resposta com um valor fora do vetor, inv√°lido para marcar se conseguimos achar alguma resposta ou nao while(L \u003c= R){ // enquanto tiver algum n√∫mero no intervalo int mid = (L+R)/2; if(check(mid, x)){ // se esse mid √© uma resposta apropriada ans = mid; // achamos uma nova resposta para o problema L = mid+1; // se mid √© uma resposta temos que tentar procurar uma resposta maior(nesse problema em especifico) } else{ // se mid nao √© uma resposta pro nosso problema R = mid-1; // precisamos procurar em indices menores(neste problema) } } if(ans == n) return -1; // se ans ainda √© n depois da busca bin√°ria, ent√£o nunca achamos resposta return ans; } Em ambos os exemplos a complexidade de checar se mid √© uma resposta v√°lida para o problema √© O(1). Portanto a complexidade total √© O(lg n).
Muitas pessoas ja viram o exemplo de realizar busca bin√°ria em vetores, mas quando se fala em busca bin√°ria na resposta, ficam confusas. Na verdade, busca bin√°ria em vetores √© busca bin√°ria na resposta, mas a resposta √© um √≠ndice.
Material complementar Exerc√≠cios recomendados Estes exerc√≠cios n√£o est√£o necessariamente em ordem de dificuldade.
https://codeforces.com/contest/1234/problem/A - N√£o √© necess√°rio busca bin√°ria mas √© um exerc√≠cio legal para aprender https://codeforces.com/problemset/problem/817/C - Bem interessante, (se x √© um numero realmente grande entao x+1 √© realmente grande) https://codeforces.com/problemset/problem/760/B - Se frodo n√£o consegue ter x de altura ent√£o consegue ter x+1 de altura. Cuidado com overflows! https://codeforces.com/gym/102346/problem/M - (Tente minimizar o quanto cada competidor come j√° que a resposta √© em fun√ß√£o do competidor que mais come) `,description:"",tags:["iniciante"],title:"Busca Bin√°ria",uri:"/materiais/algoritmos/busca_binaria/"},{content:`Um dos assuntos mais frequentes s√£o problemas relacionados a grafos, ou que podem ser representados como grafos, apesar de n√£o ser √≥bvio √† primeira vista.
Conceitos H√° diversos tipos e atributos de um grafo:
O que √© um grafo? Um grafo √© definido simplesmente por um conjunto de v√©rtices, e outro conjunto de arestas. Essas arestas ligam dois v√©rtices, e podem ter pesos atrelados √† elas.
Grafo simples Grafo simples √© um grafo que n√£o cujas arestas n√£o tem peso, n√£o possui loops, e nem arestas m√∫ltiplas. Loops s√£o arestas do tipo (u,u), ou seja, que saem do v√©rtice u, e v√£o para o v√©rtice u. Um grafo com arestas m√∫ltiplas √© um grafo que tem duas aresta iguais.
Grafos direcionados Existem grafos direcionados e n√£o direcionados. No caso dos direcionados, significa que cada aresta tem uma dire√ß√£o, ou seja, se √© poss√≠vel chegar de a em b, n√£o significa que √© poss√≠vel chegar de b em a.
Ciclos A defini√ß√£o de ciclo √© um pouco diferente dependendo se o grafo √© direcionado ou n√£o.
Caso o grafo n√£o seja direcionado, e hajam dois caminhos diferentes de um v√©rtice a para um v√©rtice b, ent√£o h√° um ciclo.
Caso contr√°rio, ou seja, caso o grafo seja direcionado, para que haja um ciclo √© necess√°rio que exista um v√©rtice a tal que seja poss√≠vel voltar a a partindo dele mesmo.
Conexo Um grafo conexo √© um grafo tal que para dois v√©rtices quaisquer u e w, sempre existe um caminho de u para w.
Componentes conexas Um grafo que n√£o √© conexo pode ter v√°rias componentes conexas (grafos conexos tem somente uma componente). Essencialmente, uma componente conexa √© um peda√ßo conexo do grafo. Esse conceito √© usado no caso de grafos n√£o-direcionados.
Componentes fortemente conexas J√° nos casos do grafos direcionados, o termo usado √© esse, tamb√©m chamados por SCCs(Strongly Connectec Components). A defini√ß√£o mais ‚Äòformal‚Äô √© a seguinte: dentro de uma componente conexa de um grafo direcionado, para todo v√©rtice a e b, deve ser poss√≠vel de chegar de b partindo de a e em a partindo de b.
Basicamente o que a defini√ß√£o acima est√° dizendo √©: uma componente fortemente conexa √© um ciclo, mas √© importante lembrar que se dois ciclos se juntam, formam um ciclo maior, logo, uma componente maior.
√Årvore Uma √°rvore √© um tipo de grafo. Para ser uma √°rvore, o grafo precisa ser conexo, n√£o ter ciclos e ter n-1 arestas, aonde n √© o n√∫mero de v√©rtices.
DAG DAG √© uma sigla para Directed Acyclic Graph, ou seja, um grafo ac√≠clico e direcionado. √â um termo bastante usado.
Grafos bipartidos Um grafo bipartido √© um grafo tal que √© poss√≠vel dividir seus v√©rtices em dois grupos, de forma que s√≥ hajam arestas ligando v√©rtices do primeiro ao segundo grupo.
Representa√ß√£o de um grafo Mas como representar um grafo em c√≥digo?
Na verdade √© bem mais simples do que parece. Para cada v√©rtice, temos que manter apenas uma lista das arestas que saem daquele v√©rtice.
Nessa representa√ß√£o, a i-√©sima posi√ß√£o no vector de fora vector\u003cint\u003e, esse vector representam as arestas que saem daquele v√©rtice. Ent√£o, cada v√©rtice tem um n√∫mero associado a ele.
Exemplo vector\u003cint\u003e graph[7]; graph[4].push_back(6); graph[6].push_back(4); graph[4].push_back(5); graph[5].push_back(4); graph[4].push_back(3); graph[3].push_back(4); graph[2].push_back(3); graph[3].push_back(2); graph[2].push_back(5); graph[5].push_back(2); graph[4].push_back(6); graph[6].push_back(4); graph[2].push_back(1); graph[1].push_back(2); // lembrando que no caso de grafos n√£o direcionados, quando adicionamos (a,b) precisamos sempre adicionar (b,a) junto. Representa√ß√£o da grafos impl√≠citos Considere o seguinte problema para guiar a explica√ß√£o: http://codeforces.com/problemset/problem/520/B
A principio, nao parece exatamente muito f√°cil relacionar esse problema com grafos. Onde est√£o os v√©rtices e as arestas? Na verdade nesse problema h√° o que chamamos de grafo impl√≠cito.
Podemos considerar os v√©rtices como o n√∫mero mostrado pelo display, e as arestas como os v√©rtices que consigo alcan√ßar apertando os bot√µes, a partir do v√©rtice que estou. Mas n√≥s n√£o vamos criar uma estrutura de lista de adjac√™ncias em mem√≥ria igual ao caso anterior, n√£o precisamos. A √∫nica coisa que precisamos √© saber quais v√©rtices podemos atingir a partir de um v√©rtice x, ent√£o quando formos percorrer esse grafo impl√≠cito, como todos os v√©rtices seguem essa regra, n√£o precisamos criar as arestas propriamente ditas. Apenas sabemos que √© poss√≠vel atingir os v√©rtices x-1 e 2x.
O mesmo ocorre pra representa√ß√£o de jogos de turno, por exemplo jogo da velha ou damas. Podemos considerar uma configura√ß√£o do tabuleiro como um v√©rtice, e as arestas ligando para todas as configura√ß√µes poss√≠veis de atingir segundo as regras de jogada.
VideoAulas complementares https://www.youtube.com/watch?v=zaBhtODEL0w
Exerc√≠cios recomendados https://www.urionlinejudge.com.br/judge/pt/problems/view/1910 - Caminho m√≠nimo em grafo impl√≠cito sem pesos. https://www.urionlinejudge.com.br/judge/pt/problems/view/1907 - Contagem de componentes conexas em grafo que √© um grid (impl√≠cito). https://codeforces.com/gym/102346/problem/A - Se considerarmos as paredes e sensores v√©rtices, vendo se alguns v√©rtices est√£o na mesma componente conexa podemos ver se h√° um caminho que bloqueia o ladr√£o. https://www.urionlinejudge.com.br/judge/pt/problems/view/2194 - (implementa√ß√£o mais dif√≠cil), resolver o reconhecimento por meio da contagem das componentes conexas de cada hier√≥glifo. `,description:"",tags:["iniciante"],title:"Representa√ß√£o de Grafos",uri:"/materiais/grafos/representacao/"},{content:`Podemos cham√°-la tamb√©m de BFS (Breadth-First Search).
Uma das formas de percorrer um grafo √© fazer um percorrimento em largura. Come√ßamos a explorar os v√©rtices do grafo a partir de um certo v√©rtice a. E a ordem que vamos navegando entre os v√©rtices √© de forma que os mais pr√≥ximos a a sempre ser√£o visitados antes. Ent√£o, primeiro a ser√° visitado, depois os v√©rtices que s√£o adjacentes a a(dist√¢ncia 1), depois os v√©rtices que est√£o a duas arestas de dist√¢ncia, e assim por diante. Como os v√©rtices mais pr√≥ximos s√£o sempre visitados antes, esse algoritmo serve para, por exemplo, dizer qual a dist√¢ncia m√≠nima entre dois v√©rtices no grafo.
Esse comportamento √© implementado usando-se uma fila. Primeiro insere-se na fila o v√©rtice inicial, e come√ßa-se a desenfileirar da fila enquando houver algum nodo. Quando um v√©rtice a √© desenfileirado, enfileram-se todos os v√©rtice adjacentes a a que n√£o foram visitados. Caso n√£o marquemos os visitados, e o grafo tiver ciclos, nosso programa n√£o terminar√°.
O algoritmo abaixo √© uma BFS que simplesmente percorre o grafo.
const int MAX_SIZE = 1e5; // globais // inicializa visited como false bool visited[MAX_SIZE]; vector\u003cint\u003e graph[MAX_SIZE]; void bfs(int start){ queue\u003cint\u003e q; q.push(start); visited[start] = true; while(!q.empty()){//Enquanto n√£o estiver vazia // Retire o v√©rtice da frente int u = q.front(); q.pop(); for(int w: graph[u]){ // Para cada v√©rtice adjacente a u if(!visited[w]){ q.push(w); visited[w] = true; } } } } A complexidade desse c√≥digo √© O(n+m), temos no m√°ximo n v√©rtices enfileirados, e no loop interno, cada itera√ß√£o √© considerar uma aresta, como n√£o estamos voltando no grafo, n√£o passaremos por uma aresta mais que duas vezes naquele loop. Ent√£o, em todas as chamadas, aquele loop iterar√° no pior caso m vezes.
`,description:"",tags:["iniciante"],title:"Busca em Largura",uri:"/materiais/grafos/busca_largura/"},{content:`Outra forma de percorrer um grafo √© fazer percorrimento em profundidade, tamb√©m de chamado de DFS(Depth-first search). O algoritmo se chama assim porque funciona de uma forma que sempre vamos ‚Äòmergulhar‚Äô no grafo o mais fundo que pudermos. Quando n√£o for mais poss√≠vel ir mais fundo no grafo, voltamos at√© que seja ir mais fundo novamente, sem repetir v√©rtices j√° visitados.
A implementa√ß√£o da DFS mais comum √© recursiva, por ser mais intuitiva. Assim como o exemplo anterior, esse programa simplesmente percorre o grafo, mas na ordem que um DFS percorre.
Visualiza√ß√£o Implementa√ß√£o const int MAX_SIZE = 1e5; vector\u003cint\u003e graph[MAX_SIZE]; bool visited[MAX_SIZE]; // globais, inicializados na main. void dfs(int vertex){ // na main chamamos dfs(start), aonde start √© o v√©rtice que come√ßamos o dfs visited[vertex] = true; for(int w: graph[vertex]){ if(!visited[w]){ dfs(w); } } } A complexidade desse c√≥digo √© O(n+m), temos no m√°ximo n chamadas recursivas, e no loop interno √†s chamadas, assim como no BFS, estaremos considerando uma aresta e n√£o passaremos nela mais de uma vez. Ent√£o no m√°ximo m itera√ß√µes ao longo de todas as chamadas.
`,description:"",tags:["iniciante"],title:"Busca em Profundidade",uri:"/materiais/grafos/busca_profundidade/"},{content:` Complexidade O(E*log(V))
E = Edges V = Vertex
O algoritmo de Dijkstra √© um algoritmo muito conhecido para percorrimento de grafos cujas arestas tem pesos, ele nos permite percorrer os v√©rtices na ordem de dist√¢ncia para um v√©rtice fonte. E efetivamente descobrir essas dist√¢ncias.
Mais especificamente, de uma forma tal que considerando o v√©rtice fonte como s, se o menor caminho de s para um v√©rtice u √© estritamente menor que o menor caminho de s para um outro v√©rtice v, com certeza visitaremos u antes de v.
A forma como o algoritmo opera √© muito parecida com o BFS, mas em vez de usarmos uma fila, usamos uma fila de prioridades(priorizando menores valores). O motivo de usarmos essa outra estrutura de dados √© que usar uma fila n√£o gera mais o mesmo comportamento que desejamos quando as arestas passam a ter pesos.
Como as arestas tem pesos, nosso grafo ser√° um vector\u003cpair\u003cint,int\u003e\u003e grafo[n] ao inv√©s de um vector\u003cint\u003e grafo[n].
A ideia Assim como no BFS, teremos essa fila que ditar√° a ordem com que os nodos ser√£o desenfileirados (visitados). Mas agora Nossa Fila √© de prioridades abriga pares ao inv√©s de apenas um inteiro.
Pra qualquer par p na fila, (p.first,p.second) significa: Consigo chegar no v√©rtice p.second por um caminho de custo p.first. Por isso no come√ßo da execu√ß√£o enfileiramos o par (0, s), dizendo: consigo chegar no v√©rtice fonte pagando 0, afinal j√° estamos nele no come√ßo do percorrimento.
Quando desinfileiramos um v√©rtice, assim como no BFS, consideramos seguir por todas as arestas que partem dele, agora com pesos.
Bem, para cada aresta, sabemos seu destino e seu peso, ent√£o, a informa√ß√£o que podemos tirar disso √© que podemos ir para aquele destino com o custo da aresta somado com o custo para chegar no v√©rtice que acabamos de desinfileirar.
Na implementa√ß√£o do BFS, na hora de verificar se dev√≠amos enfileirar algo, verificavamos apenas se aquele destino j√° tinha sido enfileirado antes, usando um vetor pra armazenar essa informa√ß√£o.
Na nossa implementa√ß√£o, ao inv√©s de um vetor marcando quais j√° foram enfileirados, usaremos um vetor indicando o melhor custo conhecido para se atingir cada v√©rtice.
O motivo disso √© que n√£o h√° mais garantia que na primeira vez que enfileiramos um v√©rtice j√° obtivemos o melhor custo para chegar nele. Pode ser que posteriormente enfileiremos um custo menor pra chegar nesse v√©rtice.
Ent√£o, na hora de enfileirarmos, verificaremos se aquele enfileiramento √© vantajoso, isto √©, se ele melhora o melhor custo que j√° conhec√≠amos para chegar em algum v√©rtice. De come√ßo assumimos o custo infinito para chegar em todos.
Visualiza√ß√£o Implementa√ß√£o #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int N = 100005; const ll oo = 1e18; ll d[N]; // vetor onde guardamos as distancias int n; // numeros de vertices // lista de adjacencias guarda // pair \u003cvertice para onde a aresta vai, peso da aresta\u003e vector\u003cpair\u003cint, ll\u003e\u003e g[N]; void dijkstra(int start){ // inicialmente a distancia do vertice // start para todo os outros √© infinita for(int u = 1; u \u003c= n; u++) d[u] = oo; // fila de prioridade de pair\u003cll, int\u003e, mas que o // menor pair fica no topo da fila // guardamos um pair \u003cdistancia ate o vertice, vertice\u003e // assim o topo da fila sempre √© o vertice com menor distancia priority_queue\u003cpair\u003cll, int\u003e, vector\u003cpair\u003cll, int\u003e\u003e, greater\u003cpair\u003cll, int\u003e\u003e \u003e pq; d[start] = 0; pq.emplace(d[start], start); ll dt, w; int u, v; while(!pq.empty()){ tie(dt, u) = pq.top(); pq.pop(); if(dt \u003e d[u]) continue; for(auto edge : g[u]){ tie(v, w) = edge; // se a distancia ate o u somado com o peso // da aresta √© menor do que a distancia ate o v que // tinhamos antes, melhoramos a distancia ate o v if(d[v] \u003e d[u] + w){ d[v] = d[u] + w; pq.emplace(d[v], v); } } } } int main(){ // l√™ o input, qnt de vertices, arestas // e vertice inicial(start) dijkstra(start); for(int u = 1; u \u003c= n; u++){ printf("Distancia de %d para %d: %lld\\n", start, u, d[u]); } } Assim como no BFS, podemos facilmente adicionar um vetor indicando os predecessores de cada v√©rtice, dessa forma podemos obter n√£o s√≥ a informa√ß√£o dos custos, mas tamb√©m a sequ√™ncia de v√©rtices que a origina.
`,description:"",tags:["intermediario"],title:"Dijkstra",uri:"/materiais/grafos/dijkstra/"},{content:`Representa√ß√£o bin√°ria Qualquer tipo de dado, seja um n√∫mero inteiro, n√∫mero racional ou um caracter, pode ser representado por bits. Exemplos de representa√ß√£o bin√°ria de n√∫meros inteiros (sem sinal):
1) 14 = {1110}2 = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 = 14.
2) 20 = {10100}2 = 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 20.
Operadores bit-a-bit NOT ( ~ ): Bitwise NOT √© um operador un√°rio que flipa os bits de um n√∫mero (se o bit √© 0, vira 1 e vice-versa). Bitwise NOT √© apenas o complemento de 1 de um n√∫mero.
N = 5 = (101)2
~N = ~5 = ~(101)2 = (010)2 = 2
AND ( \u0026 ): Bitwise AND √© um operador bin√°rio que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posi√ß√£o comparada das palavras forem 1, ent√£o o valor do bit resultante nessa posi√ß√£o na palavra final ser√° 1, qualquer outro caso o bit resultante ser√° 0. A = 5 = (101)2
B = 3 = (011)2
A \u0026 B = (101)2 \u0026 (011)2= (001)2 = 1
OR ( | ): Bitwise OR, similarmente ao bitwise AND, √© um operador bin√°rio que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posi√ß√£o comparada forem 0, o valor do bit resultante nessa posi√ß√£o na palavra final ser√° 0, qualquer outro caso o bit resultante ser√° 1.
A = 5 = (101)2
B = 3 = (011)2
A | B = (101)2 | (011)2 = (111)2 = 7
XOR ( ^ ): Bitwise XOR tamb√©m √© um operador bin√°rio que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posi√ß√£o comparada forem iguais (0 ou 1), o valor do bit resultante nessa posi√ß√£o na palavra final ser√° 0, se os bits forem diferentes (um 0 e outro 1), o bit resultante ser√° 1.
A = 5 = (101)2
B = 3 = (011)2
A ^ B = (101)2 ^ (011)2 = (110)2 = 6
Left Shift ( ¬´ ): Existem dois operadores de deslocamento (left shift e righr shift). O left shift operator √© um operador bin√°rio que desloca os bits de uma palavra X vezes para a esquerda e preenche a palavra com X 0s √† direita. Left shift de X bits em um n√∫mero inteiro √© equivalente a multuplic√°-lo por 2^X.
1 ¬´ 1 = 2
1 ¬´ 2 = 4
2 ¬´ 2 = {00010}2 ¬´ 2 = {01000}2 = 8
1 ¬´ n = 2^n
Right Shift ( ¬ª ): O right shift operator √© um operador bin√°rio que desloca os bits de uma palavra X vezes para a direita e preenche a palavra com X 0s √† esquerda. Right shift de X bits em um n√∫mero inteiro √© equivalente a dividi-lo por 2^X.
4 ¬ª 1 = 2
6 ¬ª 1 = 3
5 ¬ª 1 = 2
16 ¬ª 4 = 1
Tabela-verdade X Y X\u0026Y X|Y X^Y 0 0 0 0 0 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 Manipulando bits Checando se um determinado bit est√° ligado Para checarmos de um jeito eficiente se o i-√©simo bit de um n√∫mero N est√° ligado, basta apenas checar se o AND de 2^i e N √© diferente de 0. Como vimos anteriormente, o n√∫mero 2^i √© simplesmente o n√∫mero 1 shiftado de i bits (1 ¬´ i).
bool isSet(int bitPosition, int number) { bool ret = ((number \u0026 (1 \u003c\u003c bitPosition)) != 0); return ret; } Ligando um determinado bit em um n√∫mero Para ligar o i-√©simo bit de um n√∫mero N, basta apenas fazermos o OR de 2^i com N.
bool setBit(int bitPosition, int number) { return (number | (1 \u003c\u003c bitPosition) ); } Representando conjunto com bits - bitmasks Suponha que tenhamos conjunto universo com 8 elementos, U = {a,b,c,d,e,f,g,h}.
Vamos associar cada elemento de U a um bit:
a -\u003e bit 7
b -\u003e bit 6
c -\u003e bit 5
d -\u003e bit 4
e -\u003e bit 3
f -\u003e bit 2
g -\u003e bit 1
h -\u003e bit 0
Com essa associa√ß√£o, podemos representar qualquer subconjunto de U como uma m√°scara de 8 bits. Exemplo:
Conjunto Bitmask {b,c,f,h} 01100101 {a} 10000000 {} 00000000 Adicionar um elemento ao conjunto Para adicionarmos um elemento a um conjunto que est√° representado como uma bitmask √© simples. Basta apenas setarmos o bit correspondente ao elemento na bitmask do conjunto.
int addElement(int bitmask, int elementPosition) { bitmask = bitmsak | (1 \u003c\u003c elementPosition); return bitmask; } Checar se um conjunto contem um elemento Essa opera√ß√£o √© a mesma de checar se um dado bit est√° setado na bitmask.
bool hasElement(int bitmask, int elementPosition){ bool ret = ((bitmask \u0026 (1 \u003c\u003c elementPosition)) != 0); return ret; } Uni√£o de 2 conjuntos Um elemento estar√° presente na uni√£o de 2 conjuntos se e somente se pelo menos um dos conjuntos contiver este elemento. Com base nisso e na tabela-verdade, podemos ver que a m√°scara que representa a uni√£o de duas m√°scaras √© o OR delas.
int union(int bitmaskA, int bitmaskB){ return (bitmaskA | bitmaskB); } Interse√ß√£o de 2 conjuntos Um elemento estar√° presente na interse√ß√£o de 2 conjuntos se e somente se os 2 conjuntos contiverem este elemento. Logo, a m√°scara que representa a interse√ß√£o de duas m√°scaras √© o AND delas.
int intersection(int bitmaskA, int bitmaskB){ return (bitmaskA \u0026 bitmaskB); } Gerando todos os subconjuntos de um conjunto Suponha que voc√™ tenha um conjunto S = {p,q,r}.
Para formar um subconjunto de S, podemos escolher ou n√£o o elemento p (2 op√ß√µes), escolher ou n√£o o elemento q (2 op√ß√µes de novo) e escolher ou n√£o o elemento r (2 op√ß√µes novamente). Logo, podemos formar um subconjunto de S de 2*2*2 maneiras diferentes. Um conjunto de N elementos possui 2^N subconjuntos. S possui 2^3 = 8 subconjuntos.
Ok, agora vamos representar cada elemento do conjunto S com um bit, como S tem 3 elementos, precisamos de 3 bits para isso:
p = bit 2,
q = bit 1,
r = bit 0
Com esta associa√ß√£o de elementos e bits, podemos representar todos os subconjuntos de S como uma palavra de 3 bits. Veja:
0 = (000)2 = {}
1 = (001)2 = {r}
2 = (010)2 = {q}
3 = (011)2 = {q, r}
4 = (100)2 = {p}
5 = (101)2 = {p, r}
6 = (110)2 = {p, q}
7 = (111)2 = {p, q, r}
Como temos 2^N subconjuntos em um conjunto de N elementos, passando por todos os n√∫meros de [0, 2^N - 1] √© poss√≠vel representar todos os subconjuntos de um conjunto.
C√≥digo para printar todos os subconjuntos de um conjunto:
void possibleSubsets(char S[], int N) { for(int i = 0;i \u003c (1 \u003c\u003c N); ++i) { // i = [0, 2^N - 1] for(int j = 0;j \u003c N;++j) if(i \u0026 (1 \u003c\u003c j)) // se o j-√©simo bit de i est√° setado, printamos S[j] cout \u003c\u003c S[j] \u003c\u003c " "; cout \u003c\u003c endl; } } `,description:"",tags:["intermediario"],title:"Bitwise",uri:"/materiais/bitwise/"},{content:"Subp√°ginas M√≥dulo Divisores N√∫meros Primos Fatora√ß√£o ",description:"",tags:null,title:"Matematica",uri:"/materiais/matematica/"},{content:`Diversos problemas em ju√≠zes online (e competi√ß√µes) costumam pedir a resposta m√≥dulo algum primo alto (bastante comum 10^9 + 7). O motivo disso √© evitar overflow. Por exemplo: finja que voc√™ tem o seguinte problema:
Imprimir o resultado de 3^x (0 \u003c= x \u003c= 100), por exemplo. Esse resultado claramente excede 2^64 (limite de long long), ent√£o n√£o faz muito sentido pedir o resultado por si s√≥ (na verdade, alguns problemas realmente pedem coisas do tipo, nesses casos, o recomendado √© usar python, que n√£o tem overflow).
Ent√£o pedem o resultado m√≥dulo 10^9 + 7, ou algum primo muito alto, para que n√£o force as pessoas a usarem uma linguagem ou outra.
O motivo de ser um n√∫mero alto √© minimizar a chance de seu programa a computar a resposta errada (e por sorte ser igual em m√≥dulo a resposta correta) e o ju√≠z aceit√°-la.
O motivo de ser um n√∫mero primo √© que adicionam algumas propriedades a mais que podemos usar para calcular a resposta, como o inverso multiplicativo, mas n√£o abordaremos isso aqui.
As seguintes propriedades valem no c√°lculo do m√≥dulo:
(a + b) % c = ((a % c) + (b % c)) % c
(a * b) % c = ((a % c) * (b % c)) % c
O que isso quer dizer √© que se a resposta est√° sendo computada por meio de adi√ß√µes e multiplica√ß√µes, e no final voc√™ precisa tirar o m√≥dulo dela, voc√™ pode tirar m√≥dulo em todas as opera√ß√µes intermedi√°rias que isso n√£o afetar√° a resposta.
Ent√£o, por exemplo:
long long exp(int p) { if(p == 0) return 1; return 3ll * exp(p-1); } int main() { int mod = 1e9+7; int n; scanf("%d",\u0026n); printf("%lld\\n", exp(n) % mod); } O c√≥digo acima gera overflow, a resposta vai estourar o limite de long long (j√° ter√° se tornado negativa) quando tirarmos o mod. No entanto, conceitualmente, ele est√° correto.
Ent√£o, usando as propriedades vistas em cima, podemos fazer:
int mod = 1e9+7; long long exp(int p) { if(p == 0) return 1; return (3ll * exp(p-1)) % mod; } int main() { int n; scanf("%d",\u0026n); printf("%lld\\n", exp(n)); } De forma que o c√≥digo acima imprime (3^n) % (1000000007), sem causar overflow.
`,description:"",tags:["intermediario"],title:"M√≥dulo",uri:"/materiais/matematica/modulo/"},{content:"Subp√°ginas Lowest Common Ancestor ",description:"",tags:null,title:"T√≥picos Avan√ßados",uri:"/materiais/avancados/"},{content:`Um problema recorrente √© o de encontrar divisores de um n√∫mero positivo. A maneira mais simples de resolv√™-lo seria passar por todos os n√∫meros e testar se o resto da divis√£o √© 0, ou seja, se √© divis√≠vel.
vector\u003clong long\u003e all_divisors(long long n) { vector\u003clong long\u003e ans; for(long long i = 1; i \u003c= n; i++) if(n % i == 0) ans.push_back(i); return ans; } √© f√°cil ver que a complexidade do c√≥digo acima √© O(n), podemos fazer melhor que isso com algumas observa√ß√µes.
Se a √© um divisor n ent√£o o resto da divis√£o de n por a √© 0 assim b = n/a √© um inteiro. Sabemos ent√£o que a*b = n, ou seja, a = n/b e assim b tamb√©m √© um divisor de n. Se fixarmos que a \u003c= b, qual o valor m√°ximo de a? Como a √© no m√°ximo b, consideremos o caso em que a = b temos que a*a = n, ou seja, a = sqrt(n).
Agora √© possivel modificar o c√≥digo passando por todos os valores poss√≠veis de a e computar o respectivo b para encontrar todos os divisores.
vector\u003clong long\u003e all_divisors(long long n) { vector\u003clong long\u003e ans; for(long long a = 1; a*a \u003c= n; a++) { // compara√ß√£o que evita o uso de doubles, a \u003c= sqrt(n) √© o mesmo que a*a \u003c= n, ja que a e n sao positivos if(n % a == 0) { long long b = n / a; ans.push_back(a); ans.push_back(b); } } sort(ans.begin(), ans.end()); // frescura para retornar os divisores ordenados como na primeira implementa√ß√£o return ans; } S√≥ h√° um problema com a implementa√ß√£o acima. Assumimos que a \u003c= b, caso a = b inserimos o divisor 2 vezes na resposta, por exemplo, para 36 podemos ter a = 6 e b = 6. Assim a vers√£o final do c√≥digo fica:
vector\u003clong long\u003e all_divisors(long long n) { vector\u003clong long\u003e ans; for(long long a = 1; a*a \u003c= n; a++) { // compara√ß√£o que evita o uso de doubles, a \u003c= sqrt(n) √© o mesmo que a*a \u003c= n if(n % a == 0) { long long b = n / a; ans.push_back(a); if(a != b) ans.push_back(b); } } sort(ans.begin(), ans.end()); // frescura para retornar os divisores ordenados como na primeira implementa√ß√£o return ans; } com complexidade O(sqrt(n)).
Observa√ß√µes Um n√∫mero primo tem somente dois divisores positivos, assim podemos checar se um numero x √© primo usando all_divisors(x).size() == 2 ou modificando um pouco a rotina e ter uma melhor constante na complexidade
vector\u003clong long\u003e is_prime(long long n) { if(n == 1) return 0; for(long long a = 2; a*a \u003c= n; a++) { // compara√ß√£o que evita o uso de doubles, a \u003c= sqrt(n) √© o mesmo que a*a \u003c= n if(n % a == 0){ return 0; } } return 1; } Passar por todos os m√∫ltiplos de x at√© N Consideramos multiplos de x os n√∫meros: x, 2*x, 3*x, 4*x, ... ou, escrevendo de outra forma, x, x+x, x+x+x, x+x+x+x, ...
Caso queiramos fazer algo com todos os m√∫ltiplos de x at√© um limite N podemos usar a simples rotina
for(int m = x; m \u003c N; m += x) { // m √© sempre multiplo de x // code } Que √© executada em O(N/x).
Passar por todos os m√∫ltiplos de todos os n√∫meros at√© N Se passarmos por todos os n√∫meros x entre 1 e N e para cada um deles achar todos os m√∫ltiplos m.
O c√≥digo ficaria algo como
for(int x = 1; x \u003c N; x++) { for(int m = x; m \u003c N; m += x) { // m √© sempre multiplo de x // code } } O c√≥digo acima parece ser executado em O(N^2), mas podemos definir uma cota bem menor, com algumas observa√ß√µes. O c√≥digo √© executado em N/1 + N/2 + ... + N/(N-1) + N/N passos. Podemos botar o N em evidencia N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N). A soma dentro dos parenteses √© menor que a √°rea abaixo da curva da fun√ß√£o 1/x, a integral √© ln(x)(mas relaxa que n√£o precisa lembrar das coisas de c√°lculo 1). Portanto O(N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N)) = O(N*lg N).
Podemos resolver v√°rios problemas usando isso pois x ser√° divisor de m e assim para todo m tamb√©m passaremos por todos os divisores deles.
Contando os divisores de v√°rios n√∫meros Por exemplo, usando essa abordagem, poder√≠amos usar esses 2 la√ßos aninhados para gerar um vetor div que informa quantos divisores todos os n√∫meros at√© n tem.
Perceba que esses dois la√ßos executam em O(n * log n), enquanto repetir o algoritmo de contar os divisores de cada n√∫mero individualmente teria complexidade sqrt(1) + sqrt(2) + ... + sqrt(n) = O(n * sqrt(n)), ou seja, tem complexidade melhor.
A abordagem abaixo funciona porque sempre que chegamos em um n√∫mero m no la√ßo mais interno, significa que temos um divisor a mais.
Na primeira itera√ß√£o passamos por todos os n√∫meros, j√° que come√ßamos e 1 e estamos incrementando de 1 em 1, todos os n√∫meros s√£o divis√≠veis por 1, ent√£o todos ganham um divisor a mais no vetor.
Na segunda itera√ß√£o, passamos apenas pelos n√∫meros m√∫ltiplos de 2, em todos os n√∫meros que chegarmos, significa que esse n√∫mero √© divis√≠vel por 2 (ou seja, sabemos que ele tem um divisor a mais). E repetimos esse racioc√≠nio para todos os n√∫meros.
vector\u003cint\u003e computa_divisores(int N) { vector\u003cint\u003e qnt_div(N, 0); for(int x = 1; x \u003c N; x++) { for(int m = x; m \u003c N; m += x) { qnt_div[m]++; // aqui descobrimos que x √© divisor de m } } return qnt_div; } `,description:"",tags:["intermediario"],title:"Divisores",uri:"/materiais/matematica/divisores/"},{content:`Em particular, sabendo a quantidade de divisores de cada n√∫mero, podemos varrer esse vetor vendo quais n√∫meros s√£o primos (tem 2 divisores).
vector\u003cint\u003e primos_ate_n(int N) { vector\u003cint\u003e primos; for(int x = 1; x \u003c N; x++) { if(qnt_div[x] == 2) primos.push_back(x); } return primos; } Crivo de erast√≥tenes A abordagem acima tem uma complexidade aceit√°vel, e passaria no tempo para a maioria dos problemas. No entanto, existe um algoritmo com uma ideia semelhante, mas que com algumas observa√ß√µes baixa essa complexidade de O(n * log n) para O(n * log( log n)). O log j√° abaixa muito um n√∫mero, se aplicamos ele novamente, abaixamos mais ainda, ou seja, isso √© quase linear.
A ideia usada √© marcar inicialmente todos os n√∫meros entre 1 e N como possiveis primos. Passando em ordem crescente e quando encontramos um primo marcamos os m√∫ltiplos do primo como n√£o primos.
Visualiza√ß√£o Implementa√ß√£o vector\u003cint\u003e primos_ate_n(int N) { vector\u003cint\u003e marcacao(N, 1); // 1 = possivel primo, 0 = com certeza n√£o primo vector\u003cint\u003e primos; for(int x = 2; x \u003c N; x++) if(marcacao[x] == 1) { primos.push_back(x); for(int m = x+x; m \u003c N; m += x) { marcacao[m] = 0; // aqui descobrimos que m n√£o √© primo } } return primos; } `,description:"",tags:["intermediario"],title:"N√∫meros Primos",uri:"/materiais/matematica/primos/"},{content:"Aprendemos na escola que todo n√∫mero √© composto por fatores primos, existindo uma √∫nica fatora√ß√£o pra cada n√∫mero.\nUma primeira abordagem poss√≠vel seria passar por todos os n√∫meros e ir dividindo sempre que poss√≠vel.\n// retorna vetor de pair\u003cprimo, expoente\u003e da fatora√ß√£o // fatora(36) = [{2, 2}, {3, 2}] ou seja, 36 = 2^2 + 3^2 vector\u003cpair\u003clong long, int\u003e\u003e fatora(long long n) { vector\u003cpair\u003clong long, int\u003e\u003e ans; for(long long p = 2; p \u003c= n; p++) { if(n % p == 0){ int expoente = 0; while(n % p == 0) { n /= p; expoente++; } ans.emplace_back(p, expoente); } } return ans; } A primeira vista,como queremos decompor em fatores primos, parece que temos que testar se p √© primo. Entretanto passamos por p de forma crescente e sempre que podemos dividimos n por p ent√£o a condi√ß√£o (n % p == 0) s√≥ ser√° verdade para p primos.\nIsso ocorre porque todos os fatores primos de um n√∫mero s√£o menores ou iguais a ele pr√≥prio, ent√£o quando chegamos em um n√∫mero, √© imposs√≠vel que ele divida o n√∫mero e n√£o seja primo, pois se n√£o for, os n√∫meros primos que o compoem deveriam ter sido contabilizados numa itera√ß√£o anterior.\nApesar do c√≥digo acima rodar bem para v√°rios exemplos, no pior caso n √© primo e o c√≥digo √© executado em O(n).\nPodemos melhorar a complexidade com uma simples observa√ß√£o. √â possivel ter apenas um primo maior que a sqrt(n), por exemplo, 10 tem 5 como fator e 5 \u003e sqrt(10), mas √© imposs√≠vel ter dois primos maiores que a raiz. Se tivermos a \u003e sqrt(n) e b \u003e sqrt(n), quando multiplicamos temos que a * b \u003e sqrt(n) * sqrt(n) e a * b \u003e n.\nvector\u003cpair\u003clong long, int\u003e\u003e fatora(long long n) { vector\u003cpair\u003clong long, int\u003e\u003e ans; for(long long p = 2; p*p \u003c= n; p++) { // compara√ß√£o que evita o uso de doubles, p \u003c= sqrt(n) √© o mesmo que p*p \u003c= n if(n % p == 0) { int expoente = 0; while(n % p == 0) { n /= p; expoente++; } ans.emplace_back(p, expoente); } } if(n \u003e 1) ans.emplace_back(n, 1); return ans; } Fatora√ß√£o em O(lg n) para n√∫meros at√© N √â poss√≠vel fatorar n√∫meros ate um limite N em O(lg n) ap√≥s preprocessamento O(n log( log n)). O que fazemos √© uma pequena modifica√ß√£o no c√≥digo do crivo, para que enquanto fazemos o crivo, preenchamos um vetor auxiliar lp, aonde lp[x] representa o maior n√∫mero primo que divide x.\nvector\u003cint\u003e lp(N, -1); for(int x = 2; x \u003c N; x++) if(lp[x] == -1) { // se x nao foi marcado antes, √© primo for(int m = x; m \u003c N; m += x) // todos os multiplos de i lp[m] = x; } Tendo este vetor podemos fatorar um numero x com o seguinte procedimento.\nvector\u003cpair\u003cint, int\u003e\u003e fatora(int x) { map\u003cint, int\u003e expoentes; while(x \u003e 1) { expoentes[ lp[x] ]++; // aumentamos o expoente do primo lp[x] em 1 na resposta x /= lp[x]; } vector\u003cpair\u003cint, int\u003e\u003e ans; for(pair\u003cint, int\u003e p : expoentes) ans.emplace_back(p); return ans; } A complexidade do procedimento acima √© O(quantidade de fatores), que √© limitado por O(lg n), da para ver que no pior caso todos os fatores s√£o 2(menor primo) e a complexidade √© o k de 2^k = n.\nN√∫mero de divisores dada uma fatora√ß√£o Vimos que todo inteiro N pode ser escrito de forma √∫nica como multiplica√ß√£o de n√∫meros primos. Assim,\n$$N = {p_1}^{e_1}.{p_2}^{e_2}.{p_3}^{e_3}.{p_4}^{e_4}.{p_5}^{e_5}.{p_6}^{e_6} ... $$ onde pi √© primo e 0 ei \u003e 0.\nTodo divisor de N s√≥ pode ter primos que aparecem na fatora√ß√£o de N e expoente no m√°ximo o do expoente no N. Por exemplo: $$36 = 2^2.3^2$$ $$1 = 2^0.3^0$$ $$2 = 2^1.3^0$$ $$3 = 2^0.3^1$$ $$4 = 2^2.3^0$$ $$6 = 2^1.3^1$$ $$9 = 2^0.3^2$$ $$12 = 2^2.3^1$$ $$18 = 2^1.3^2$$ $$36 = 2^2.3^2$$ Para construir um divisor podemos escolher dentre (ei+1) possibilidades para o primo pi. O n√∫mero total de divisores √© a multiplica√ß√£o desses termos. Assim 36 tem (2+1)*(2+1) = 9 divisores.\nEmbora esta ideia n√£o melhore a complexidade para encontrar o n√∫mero de divisores em compara√ß√£o com as ideias anteriores, ela pode ser uma ferramenta √∫til para analisar problemas. Por exemplo, os n√∫meros com exatamente 9 divisores s√£o da forma\n$${p_1}^8={p_1}^2.{p_2}^2$$ Como por exemplo:\n$$256 = 2^8$$ $$6561 = 3^8$$ $$36 = 2^2.3^2$$ $$100 = 2^2.5^2$$ $$255 = 3^2.5^2$$ etc‚Ä¶\n",description:"",tags:["intermediario"],title:"Fatora√ß√£o",uri:"/materiais/matematica/fatoracao/"},{content:`Lowest Common ancestor (LCA) - ou ancestral comum mais baixo, √© o nome t√≠pico dado para o seguinte problema: dado uma √Årvore cuja raiz √© um v√©rtice arbitr√°rio e dois v√©rtices u,v que a pertencem, diga qual √© o n√≥ mais baixo(relativo a raiz) que √© ancestral de u,v.
Por exemplo na imagem a cima, o LCA de 2 e 3 √© 1, o LCA de 6 e 7 √© 0, e o LCA de 1 e 2 √© 1.
um jeito naive de se fazer isso seria o seguinte, para cada n√≥ da √°rvore, pr√©-processamos sua profundidade com rela√ß√£o a raiz (raiz tem profundidade 0, filhos 1, e assim por diante). Agora, para determinarmos os LCA de dois v√©rtices u,v, podemos fazer o seguinte procedimento. Escolhemos qual dos dois v√©rtices est√° mais profundo, subimos nos seus pais at√© igualar as alturas de ambos, e ap√≥s isso, vamos subindo em ambos os caminhos um a um at√© que os caminhos se encontrem, ent√£o saberemos o LCA.
int depth[100005]; vector\u003cint\u003e graph[100005]; void pre_process_depth(int u, int d) { depth[u] = d; for(auto adj : graph[u]) { pre_process_depth(adj, d + 1); } } int slow_lca(int u, int v) { if(depth[u] \u003c depth[v]) { swap(u, v); } while(depth[u] \u003e depth[v]) { u = pai[u]; } while(u != v) { u = pai[u]; v = pai[v]; } return u; } Essa estrat√©gia efetivamente funciona, ent√£o ter√≠amos um pr√©-processamento que √© um DFS e ap√≥s isso conseguir√≠amos responder queries em O(n), pois numa √°rvore com um ramo muito profundo ter√≠amos no pior caso que subir todos os v√©rtices, portando complexidade total de O(n + Qn) = O(Qn) onde Q √© o n√∫mero de queries e n a quantidade de n√≥s na √°rvore.
O LCA √© relevante porque como em uma √°rvore h√° um √∫nico caminho que liga dois v√©rtices, se conseguimos obter o LCA r√°pido ent√£o uma das coisas que j√° ganhamos de quebra √© conseguir responder as dist√¢ncias entre quaisquer par de v√©rtices.
A dist√¢ncia vai ser a dist√¢ncia de um v√©rtice para o LCA e do LCA para o outro, sendo que essas duas dist√¢ncias intermedi√°rias s√£o apenas a diferen√ßa de alturas na √°rvore.
Aqui nesse tutorial vamos mostrar duas ideias para computar LCA, uma que vai nos permitir responder Queries de LCA em O(log n) com preprocessamento O(n log n) e uma segunda abordagem que vai nos permitir responder queries de LCA em O(1) (isso mesmo, tempo constante!) com preprocessamento O(n log n) tamb√©m.
Apesar de a complexidade da segunda abordagem para responder queries de LCA ser estritamente melhor que da primeira, veremos que a primeira carrega um pouco mais de informa√ß√£o, permitindo obter algumas outras informa√ß√µes fora o LCA, enquanto na segunda podemos obter apenas o LCA.
Abordagem 1 O problema da solu√ß√£o naive √© essa subida de um em um at√© que atinjamos o pai comum. Ent√£o faz sentido tentarmos atacarmos isso para ganhar um desempenho assint√≥tico melhor. Uma coisa a se observar √© que estamos fazendo duas buscas lineares. A primeira busca linear √© pelo primeiro ancestral de u que iguala a altura a v e ap√≥s isso outra busca linear para procurar o primeiro ancestral de ambos que √© comum.
Podemos observar que h√° monotonicidade nessas buscas lineares, at√© certo ponto os ancestrais n√£o satisfazem uma condi√ß√£o, e ap√≥s certo ponto todos satisfazem. Na primeira estar√≠amos buscando o ancestral mais baixo de u que satisfaz a condi√ß√£o ‚ÄúTer altura menor ou igual a v‚Äù, e na segunda ‚ÄúSer ancestral de v‚Äù.
Aqui usaremos o conceito de ‚Äúk-√©simo pai‚Äù que funciona assim: o primeiro pai √© o pai do v√©rtice, o segundo pai √© o pai do pai do v√©rtice, e assim por diante.
Se n√≥s tiv√©ssemos uma fun√ß√£o m√°gica chamada por exemplo climb(n,k) que nos retornasse o k-√©simo pai do v√©rtice n, poder√≠amos ent√£o usar buscas bin√°rias na quantidade de v√©rtices a subir para resolver esse problema, e restaria implementar essa fun√ß√£o de maneira eficiente. Vamos seguir por essa linha de racioc√≠nio ent√£o.
O pulo do gato Se n√≥s tiv√©ssemos uma outra fun√ß√£o m√°gica chamada p2k(n,k) que retorna o (2^k)-√©simo pai de um v√©rtice n, poder√≠amos implementar a fun√ß√£o que sobe k v√©rtices da seguinte maneira. Se nosso grafo tem tamanho menor que 10^6, sabemos que n√£o precisamos subir mais do que 2^20.
int climb(int node, int k){ for(int i = 20; i \u003e= 0; i--) { if(k \u003e= (1 \u003c\u003c i)) { node = p2k(node,i); k -= (1 \u003c\u003c i); } } return node; } A complexidade dessa fun√ß√£o depende do n√∫mero que colocamos no for, que n√£o precisa ser maior do que o log do tamanho do grafo(n√£o faz sentido subir mais n√≥s do que o grafo possui), ent√£o conseguimos obter o k-√©simo ancestral de um v√©rtice arbitr√°rio em complexidade O(log) * X aonde X √© a complexidade de p2k.
Mostramos agora que podemos preprocessar todos os valores poss√≠veis de p2k em O(n log n). Precisamos saber os valores dos ancestrais para todos os n v√©rtices e para cada v√©rtice s√≥ faz sentido saber log ancestrais. Podemos obter todos os valores de uma vez usando programa√ß√£o din√¢mica, com uma recorr√™ncia muito elegante.
int p2k(int node, int k) { if(k == 0) { return pai[node]; } return p2k(p2k(node, k-1),k-1); } Vers√£o recursiva Usamos ent√£o memoiza√ß√£o para computarmos cada estado em O(1)
int memo[SIZE][log2(GRAPHSIZE)]; int p2k(int node, int k) { if(k == 0) { return pai[node]; } if(memo[node][k] != -1) { return memo[node][k];	} return memo[node][k] = p2k(p2k(node, k-1),k-1); } Vers√£o iterativa int p2k[SIZE][log2(SIZE)+1]; for(int node = 0; node \u003c SIZE; node++) { p2k[node][0] = pai[node]; } for(int k = 1; k \u003c= log2(SIZE); k++) { for(int node = 0; node \u003c SIZE; node++) { p2k[node][k] = p2k[p2k[node][k-1]][k-1]; } } Dessa forma ent√£o temos o seguinte procedimento para acharmos o LCA, fazemos uma busca bin√°ria, em cada itera√ß√£o obtemos o k-√©simo ancestral, e checamos se ele satisfaz as propriedades, tendo ent√£o complexidade O(log n * log n) = O(log^2 n), j√° que fazemos log itera√ß√µes e em cada itera√ß√£o demoramos log para obter o k-√©simo ancestral. Isso funciona, mas podemos melhorar um pouco mais.
Ao inv√©s de usarmos busca bin√°ria vamos usar uma t√©cnica conhecida como binary lifting ou escalada bin√°ria, basicamente vamos percorrer bit a bit vendo se esse bit est√° na resposta ou n√£o.
A ideia √© a seguinte, vamos supor que a resposta da busca bin√°ria de o quanto eu tenho que subir a partir de um v√©rtice para satisfazer uma propriedade seja 6(o primeiro ancestral que satisfaz a propriedade √© o sexto pai). Podemos usar escala bin√°ria para procurar pelo √∫ltimo v√©rtice que ainda n√£o satisfaz a propriedade (no caso ent√£o seria o 5).
Usando nossa fun√ß√£o p2k, podemos come√ßar vendo se o oitavo pai j√° satisfaz a propriedade e sim satisfaz, ent√£o como estamos buscando o √∫ltimo que ainda satisfaz, n√£o subimos para o oitavo pai. Depois verificamos que o quarto pai que ainda n√£o satisfaz, ent√£o subimos para ele. Depois verificamos o segundo pai do quarto pai, isto √©, o sexto pai do v√©rtice original, que j√° satisfaz, ent√£o n√£o subimos para ele, e por √∫ltimo, verificamos o pai do quarto pai (quinto pai do v√©rtice original), que n√£o satisfaz, ent√£o subimos pra ele e sabemos o √∫ltimo v√©rtice que ainda n√£o satisfaz a propriedade.
A escalada bin√°ria pode ser usada nas mesmas situa√ß√µes aonde a busca bin√°ria pode ser usada, mas algumas vezes (como essa), podemos obter uma complexidades assint√≥ticas melhores.
Cada checagem para ver se um dos (2^k)-√©simos pais satisfazem a propriedade √© constante, e checamos os pais (2^k), 2^(k-1), 2^(k-2),..., 1 sempre dividindo por 2, ent√£o passamos por no m√°ximo log vezes nessa checagem, portanto com essa ideia podemos obter o lca em O(log n).
int lca(int u, int v) { if(depth[u] \u003c depth[v]) swap(u,v); for (int i = 20; i \u003e= 0; --i) { if(depth[p2k[u][i]] \u003e= depth[v]) u = p2k[u][i];	} if(u == v) return u; for (int i = 20; i \u003e= 0; --i) { if(p2k[v][i] != p2k[u][i]) { v = p2k[v][i]; u = p2k[u][i]; } } return pai[v]; } Perceba que estamos fazendo exatamente a ideia primeiramente apresentada na solu√ß√£o naive. Primeiro pegamos o v√©rtice que est√° mais embaixo e subimos ele at√© o n√≠vel do outro, e ap√≥s isso, subimos em ambos os v√©rtices procurando o primeiro ancestral comum, mas em vez de fazermos busca linear, fazemos escalada bin√°ria.
A escala bin√°ria desempenha melhor nessa situa√ß√£o(em rela√ß√£o a busca bin√°ria) porque quando vamos construir o (n-√©simo) pai para fazer a checagem (somando v√°rios (2^k)-√©simos pais) na busca bin√°ria, estar√≠amos colocando os mesmos v√©rtices todas as vezes, por exemplo, tome o exemplo aonde o √∫ltimo v√©rtice que satisfaz uma propridade √© o 26.
l = 0, r = 32, mid = 16(16), checagem passa. l = 16, r = 32, mid = 24(16 + 8), checagem passa. l = 24, r = 32, mid = 28(16 + 8 + 4), checagem falha l = 24, r = 28, mid = 26(16 + 8 + 2), checagem passa l = 26, r = 28, mid = 27(16 + 8 + 2 + 1), checagem falha Quando a checagem passou para mid = 16, pod√≠amos ter certeza que tinhamos que subir pelo menos at√© o d√©cimo sexto pai, mas a√≠ nos checks subsequentes perdemos tempo reconstruindo a resposta que j√° conhecemos. Ent√£o o que a escala bin√°ria faz √© tomar vantagem disso.
Vers√£o final do c√≥digo Agora como mencionado podemos obter rapidamente a dist√¢ncia entre quaisquer 2 n√≥s na √°rvore.
int dist(int u, int v){ return depth[u] + depth[v] -2*depth[lca(u,v)]; } Vers√£o final do c√≥digo Apesar de n√£o fazermos a busca bin√°ria que usava a fun√ß√£o climb no final, √© poss√≠vel que essa implementa√ß√£o seja √∫til em alguns problemas.
int depth[SIZE]; vector\u003cint\u003e graph[SIZE]; void pre_process_depth(int u, int d) { depth[u] = d; for(auto adj : graph[u]) { pre_process_depth(adj, d + 1); } } int p2k[SIZE][log2(SIZE)+1]; int lca(int u, int v) { if(depth[u] \u003c depth[v]) swap(u,v); for (int i = 20; i \u003e= 0; --i) { if(depth[p2k[u][i]] \u003e= depth[v]) u = p2k[u][i];	} if(u == v) return u; for (int i = 20; i \u003e= 0; --i) { if(p2k[v][i] != p2k[u][i]) { v = p2k[v][i]; u = p2k[u][i]; } } return pai[v]; } int climb(int node, int k){ for(int i = 20; i \u003e= 0; i--) { if(k \u003e= (1 \u003c\u003c i)) { node = p2k[node][i]; k -= (1 \u003c\u003c i); } } return node; } int dist(int u, int v){ return depth[u] + depth[v] -2*depth[lca(u,v)]; } int main() { // codigo // le os pais e monta o grafo pai[raiz] = raiz; pre_proccess_depth(raiz); // tipicamente qual vertice √© a raiz nao importa for(int node = 0; node \u003c SIZE; node++){ p2k[node][0] = pai[node]; } for(int node = 0; node \u003c SIZE; node++) { for(int k = 1; k \u003c= log2(SIZE); k++) { p2k[node][k] = p2k[p2k[node][k-1]][k-1]; } } // resolve problema } Conclus√£o Com essa abordagem, com preprocessamento O(n log n), podemos responder queries de LCA (e climb, e dist) em O(log n), al√©m disso, podemos modificar a DP do LCA para guardar mais informa√ß√µes al√©m de qual o (2^k)-√©simo pai, por exemplo a aresta m√≠nima(ou m√°xima) nesse caminho, a soma dos custos das arestas(caso hajam pesos), m√°ximo divisor comum, etc.
Abordagem 2 A segunda abordagem usa uma ideia diferente, mas que tamb√©m √© muito top. Com preprocessamento O(n log n) podemos fazer queries de LCA em O(1). Parando pra pensar nisso, √© muito poderoso, n√£o importa o quanto seja o tamanho do grafo, teremos a resposta em tempo constante! A ideia para atingir essa complexidade √© a seguinte. Sabemos que usando uma Sparse Table(Vide aula de Sparse Table) podemos resolver problemas de RMQ (range minimum query) em O(1), com preprocessamento O(n log n) a ideia √© construir um vetor de forma que a RMQ nele representa a query de LCA.
Materiais complementares https://www.youtube.com/watch?v=EKcQt-74bNw
Exerc√≠cios recomendados https://codeforces.com/problemset/problem/208/e https://www.urionlinejudge.com.br/judge/pt/problems/view/2470 https://www.urionlinejudge.com.br/judge/pt/problems/view/1135 https://www.spoj.com/problems/QTREE2/ - queries de distancia e obter k-√©simo v√©rtice no caminho, S√≥ da pra obter k√©simo v√©rtice com LCA log. `,description:"",tags:["avancado"],title:"Lowest Common Ancestor",uri:"/materiais/avancados/lca/"},{content:"",description:"",tags:null,title:"avancado",uri:"/tags/avancado/"},{content:"",description:"",tags:null,title:"Categories",uri:"/categories/"},{content:`Contribuidores Agradecimento especial ao Jos√© Leite por ter come√ßado e incentivado a maratona UnBalloon, e pelo maravilhoso caderno de consulta.
Gabriel Taumaturgo por ajudar com a comunidade e com v√°rios conte√∫dos do UnBalloon.
Vinicius Borges professor que sempre ajudou a comunidade e deu as aulas de competitiva na UnB.
Alberto Tavares por ajudar toda a comunidade UnBalloon promovendo aulas, maratonas e dando todo o apoio necess√°rio.
Tiago Fernandes por ajudar com aulas, maratonas e disponibilizar um bel√≠ssimo caderno de consulta.
Pablo Ara√∫jo por ajudar com a descri√ß√£o sobre a programa√ß√£o competitiva e a maratona da UnB e dando valiosas dicas para iniciantes.
`,description:"",tags:null,title:"Cr√©ditos",uri:"/more/credits/"},{content:"",description:"",tags:null,title:"iniciante",uri:"/tags/iniciante/"},{content:"",description:"",tags:null,title:"intermediario",uri:"/tags/intermediario/"},{content:"",description:"",tags:null,title:"Tags",uri:"/tags/"},{content:" ",description:"",tags:null,title:"UnBalloon",uri:"/"}]