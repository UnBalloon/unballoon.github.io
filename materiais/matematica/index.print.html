<!doctype html><html lang=pt dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.105.0"><meta name=generator content="Relearn 5.4.0+tip"><meta name=description content="Repositorio do UnBalloon"><meta name=author content="Bruno Vargas"><title>Matematica :: UnBalloon</title><link href=/materiais/matematica/ rel=canonical type=text/html title=UnBalloon><link href=/materiais/matematica/index.xml rel=alternate type=application/rss+xml title=UnBalloon><link href=/images/favicon.png?1668562484 rel=icon type=image/png><link href=/css/fontawesome-all.min.css?1668562484 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css?1668562484 rel=stylesheet></noscript><link href=/css/featherlight.min.css?1668562484 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/featherlight.min.css?1668562484 rel=stylesheet></noscript><link href=/css/auto-complete.css?1668562484 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/auto-complete.css?1668562484 rel=stylesheet></noscript><link href=/css/perfect-scrollbar.min.css?1668562484 rel=stylesheet><link href=/css/nucleus.css?1668562484 rel=stylesheet><link href=/css/fonts.css?1668562484 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css?1668562484 rel=stylesheet></noscript><link href=/css/theme.css?1668562484 rel=stylesheet><link href=/css/theme-relearn-dark.css?1668562484 rel=stylesheet id=variant-style><link href=/css/ie.css?1668562484 rel=stylesheet><link href=/css/variant.css?1668562484 rel=stylesheet><link href=/css/print.css?1668562484 rel=stylesheet media=print><link href=/css/format-print.css?1668562484 rel=stylesheet><script src=/js/variant.js?1668562484></script>
<script>window.index_js_url="/index.search.js";var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copiar para a área de transferência",window.T_Copied_to_clipboard="Copiado para a área de transferência!",window.T_Copy_link_to_clipboard="Link de cópia para a área de transferência",window.T_Link_copied_to_clipboard="Link copiado para a área de transferência!",baseUriFull="https://unballoon.github.io/",window.variants&&variants.init(["relearn-dark","relearn-light","learn","neon","blue","green","red"])</script><script src=/js/jquery.min.js?1668562484 defer></script></head><body class="mobile-support print" data-url=/materiais/matematica/><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div class=navigation><a class="nav nav-next" href=/materiais/matematica/modulo/ title="Módulo (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a></div><div class=navigation><a class="nav nav-prev" href=/materiais/bitwise/ title="Bitwise (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a></div><div id=top-print-link><a class=print-link title='Imprimir capítulo inteiro (CTRL+ALT+p)' href=/materiais/matematica/index.print.html><i class="fas fa-print fa-fw"></i></a></div><div id=top-github-link><a class=github-link title='Editar (CTRL+ALT+w)' href=https://github.com/UnBalloon/unballoon.github.io/edit/main/content/materiais/matematica/_index.md target=blank><i class="fas fa-pen fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span>
<span id=toc-menu title='Índice (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/materiais/><span itemprop=name>Materiais</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Matematica</span><meta itemprop=position content="2"></li></ol></div><div class="default-animation progress"><div class=toc-wrapper dir=ltr><nav id=TableOfContents><ul><li><a href=#subpáginas>Subpáginas</a></li></ul></nav></div></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class=default dir=ltr><h1>Matematica</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/matematica/modulo/>Módulo</a></li><li><a href=/materiais/matematica/divisores/>Divisores</a></li><li><a href=/materiais/matematica/primos/>Números Primos</a></li><li><a href=/materiais/matematica/fatoracao/>Fatoração</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Matematica</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 23</div><h1>Módulo</h1><p>Diversos problemas em juízes online (e competições) costumam pedir a resposta módulo algum primo alto (bastante comum 10^9 + 7). O motivo disso é evitar overflow. Por exemplo: finja que você tem o seguinte problema:</p><p>Imprimir o resultado de 3^<code>x</code> (0 &lt;= <code>x</code> &lt;= 100), por exemplo. Esse resultado claramente excede 2^64 (limite de long long), então não faz muito sentido pedir o resultado por si só (na verdade, alguns problemas realmente pedem coisas do tipo, nesses casos, o recomendado é usar python, que não tem overflow).</p><p>Então pedem o resultado módulo 10^9 + 7, ou algum primo muito alto, para que não force as pessoas a usarem uma linguagem ou outra.</p><p>O motivo de ser um número alto é minimizar a chance de seu programa a computar a resposta errada (e por sorte ser igual em módulo a resposta correta) e o juíz aceitá-la.</p><p>O motivo de ser um número primo é que adicionam algumas propriedades a mais que podemos usar para calcular a resposta, como o inverso multiplicativo, mas não abordaremos isso aqui.</p><p>As seguintes propriedades valem no cálculo do módulo:</p><p><code>(a + b) % c = ((a % c) + (b % c)) % c</code></p><p><code>(a * b) % c = ((a % c) * (b % c)) % c</code></p><p>O que isso quer dizer é que se a resposta está sendo computada por meio de adições e multiplicações, e no final você precisa tirar o módulo dela, você pode tirar módulo em todas as operações intermediárias que isso não afetará a resposta.</p><p>Então, por exemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>exp</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3ll</span> <span style=color:#f92672>*</span> exp(p<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>  scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, exp(n) <span style=color:#f92672>%</span> mod);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O código acima gera overflow, a resposta vai estourar o limite de long long (já terá se tornado negativa) quando tirarmos o mod. No entanto, conceitualmente, ele está correto.</p><p>Então, usando as propriedades vistas em cima, podemos fazer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>exp</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (<span style=color:#ae81ff>3ll</span> <span style=color:#f92672>*</span> exp(p<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>  scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, exp(n));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>De forma que o código acima imprime (3^n) % (1000000007), sem causar overflow.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 24</div><h1>Divisores</h1><p>Um problema recorrente é o de encontrar divisores de um número positivo. A maneira mais simples de resolvê-lo seria passar por todos os números e testar se o resto da divisão é 0, ou seja, se é divisível.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      ans.push_back(i);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>é fácil ver que a complexidade do código acima é <code>O(n)</code>, podemos fazer melhor que isso com algumas observações.</p><p>Se <code>a</code> é um divisor <code>n</code> então o resto da divisão de <code>n</code> por <code>a</code> é 0 assim <code>b = n/a</code> é um inteiro. Sabemos então que <code>a*b = n</code>, ou seja, <code>a = n/b</code> e assim <code>b</code> também é um divisor de <code>n</code>. Se fixarmos que <code>a &lt;= b</code>, qual o valor máximo de <code>a</code>? Como <code>a</code> é no máximo <code>b</code>, consideremos o caso em que <code>a = b</code> temos que <code>a*a = n</code>, ou seja, <code>a = sqrt(n)</code>.</p><p>Agora é possivel modificar o código passando por todos os valores possíveis de <code>a</code> e computar o respectivo <code>b</code> para encontrar todos os divisores.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, a &lt;= sqrt(n) é o mesmo que a*a &lt;= n, ja que a e n sao positivos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> a;
</span></span><span style=display:flex><span>      ans.push_back(a);
</span></span><span style=display:flex><span>      ans.push_back(b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sort(ans.begin(), ans.end()); <span style=color:#75715e>// frescura para retornar os divisores ordenados como na primeira implementação
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Só há um problema com a implementação acima. Assumimos que <code>a &lt;= b</code>, caso <code>a = b</code> inserimos o divisor 2 vezes na resposta, por exemplo, para 36 podemos ter <code>a = 6</code> e <code>b = 6</code>. Assim a versão final do código fica:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, a &lt;= sqrt(n) é o mesmo que a*a &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> a;
</span></span><span style=display:flex><span>      ans.push_back(a);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(a <span style=color:#f92672>!=</span> b) ans.push_back(b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sort(ans.begin(), ans.end()); <span style=color:#75715e>// frescura para retornar os divisores ordenados como na primeira implementação
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>com complexidade <code>O(sqrt(n))</code>.</p><h3 id=observações>Observações</h3><p>Um número primo tem somente dois divisores positivos, assim podemos checar se um numero <code>x</code> é primo usando <code>all_divisors(x).size() == 2</code> ou modificando um pouco a rotina e ter uma melhor constante na complexidade</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> is_prime(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, a &lt;= sqrt(n) é o mesmo que a*a &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=passar-por-todos-os-múltiplos-de-x-até-n>Passar por todos os múltiplos de x até N</h2><p>Consideramos multiplos de <code>x</code> os números: <code>x, 2*x, 3*x, 4*x, ...</code> ou, escrevendo de outra forma, <code>x, x+x, x+x+x, x+x+x+x, ...</code></p><p>Caso queiramos fazer algo com todos os múltiplos de <code>x</code> até um limite <code>N</code> podemos usar a simples rotina</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) { <span style=color:#75715e>// m é sempre multiplo de x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Que é executada em <code>O(N/x)</code>.</p><h2 id=passar-por-todos-os-múltiplos-de-todos-os-números-até-n>Passar por todos os múltiplos de todos os números até N</h2><p>Se passarmos por todos os números <code>x</code> entre 1 e <code>N</code> e para cada um deles achar todos os múltiplos <code>m</code>.</p><p>O código ficaria algo como</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) { <span style=color:#75715e>// m é sempre multiplo de x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O código acima parece ser executado em <code>O(N^2)</code>, mas podemos definir uma cota bem menor, com algumas observações. O código é executado em <code>N/1 + N/2 + ... + N/(N-1) + N/N</code> passos. Podemos botar o <code>N</code> em evidencia <code>N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N)</code>. A soma dentro dos parenteses é menor que a área abaixo da curva da função <code>1/x</code>, a integral é <code>ln(x)</code>(mas relaxa que não precisa lembrar das coisas de cálculo 1). Portanto <code>O(N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N)) = O(N*lg N)</code>.</p><p>Podemos resolver vários problemas usando isso pois <code>x</code> será divisor de <code>m</code> e assim para todo <code>m</code> também passaremos por todos os divisores deles.</p><h2 id=contando-os-divisores-de-vários-números>Contando os divisores de vários números</h2><p>Por exemplo, usando essa abordagem, poderíamos usar esses 2 laços aninhados para gerar um vetor <code>div</code> que informa quantos divisores todos os números até <code>n</code> tem.</p><p>Perceba que esses dois laços executam em <code>O(n * log n)</code>, enquanto repetir o algoritmo de contar os divisores de cada número individualmente teria complexidade <code>sqrt(1) + sqrt(2) + ... + sqrt(n)</code> = O(n * sqrt(n)), ou seja, tem complexidade melhor.</p><p>A abordagem abaixo funciona porque sempre que chegamos em um número <code>m</code> no laço mais interno, significa que temos um divisor a mais.</p><p>Na primeira iteração passamos por todos os números, já que começamos e 1 e estamos incrementando de 1 em 1, todos os números são divisíveis por 1, então todos ganham um divisor a mais no vetor.</p><p>Na segunda iteração, passamos apenas pelos números múltiplos de 2, em todos os números que chegarmos, significa que esse número é divisível por 2 (ou seja, sabemos que ele tem um divisor a mais). E repetimos esse raciocínio para todos os números.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> computa_divisores(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> qnt_div(N, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) {
</span></span><span style=display:flex><span>      qnt_div[m]<span style=color:#f92672>++</span>; <span style=color:#75715e>// aqui descobrimos que x é divisor de m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> qnt_div;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 25</div><h1>Números Primos</h1><p>Em particular, sabendo a quantidade de divisores de cada número, podemos varrer esse vetor vendo quais números são primos (tem 2 divisores).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos_ate_n(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(qnt_div[x] <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>      primos.push_back(x);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> primos;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=crivo-de-erastótenes>Crivo de erastótenes</h2><p>A abordagem acima tem uma complexidade aceitável, e passaria no tempo para a maioria dos problemas. No entanto, existe um algoritmo com uma ideia semelhante, mas que com algumas observações baixa essa complexidade de <code>O(n * log n)</code> para <code>O(n * log( log n))</code>. O log já abaixa muito um número, se aplicamos ele novamente, abaixamos mais ainda, ou seja, isso é quase linear.</p><p>A ideia usada é marcar inicialmente todos os números entre 1 e <code>N</code> como possiveis primos. Passando em ordem crescente e quando encontramos um primo marcamos os múltiplos do primo como não primos.</p><h3 id=visualização>Visualização</h3><p><img src=https://i.pinimg.com/originals/24/69/79/246979fd8d7bdf29a95cdb2e08cd2e89.gif alt=Crivo></p><h3 id=implementação>Implementação</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos_ate_n(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> marcacao(N, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 1 = possivel primo, 0 = com certeza não primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) <span style=color:#66d9ef>if</span>(marcacao[x] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    primos.push_back(x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x<span style=color:#f92672>+</span>x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) {
</span></span><span style=display:flex><span>      marcacao[m] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// aqui descobrimos que m não é primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> primos;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 26</div><h1>Fatoração</h1><p>Aprendemos na escola que todo número é composto por fatores primos, existindo uma única fatoração pra cada número.</p><p>Uma primeira abordagem possível seria passar por todos os números e ir dividindo sempre que possível.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// retorna vetor de pair&lt;primo, expoente&gt; da fatoração
</span></span></span><span style=display:flex><span><span style=color:#75715e>// fatora(36) = [{2, 2}, {3, 2}] ou seja, 36 = 2^2 + 3^2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; p <span style=color:#f92672>&lt;=</span> n; p<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> expoente <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> p;
</span></span><span style=display:flex><span>        expoente<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ans.emplace_back(p, expoente);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A primeira vista,como queremos decompor em fatores primos, parece que temos que testar se <code>p</code> é primo. Entretanto passamos por <code>p</code> de forma crescente e sempre que podemos dividimos <code>n</code> por <code>p</code> então a condição <code>(n % p == 0)</code> só será verdade para <code>p</code> primos.</p><p>Isso ocorre porque todos os fatores primos de um número são menores ou iguais a ele próprio, então quando chegamos em um número, é impossível que ele divida o número e não seja primo, pois se não for, os números primos que o compoem deveriam ter sido contabilizados numa iteração anterior.</p><p>Apesar do código acima rodar bem para vários exemplos, no pior caso <code>n</code> é primo e o código é executado em <code>O(n)</code>.</p><p>Podemos melhorar a complexidade com uma simples observação. É possivel ter <strong>apenas</strong> um primo maior que a <code>sqrt(n)</code>, por exemplo, 10 tem 5 como fator e <code>5 > sqrt(10)</code>, mas é impossível ter dois primos maiores que a raiz. Se tivermos <code>a > sqrt(n)</code> e <code>b > sqrt(n)</code>, quando multiplicamos temos que <code>a * b > sqrt(n) * sqrt(n)</code> e <code>a * b > n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; p<span style=color:#f92672>*</span>p <span style=color:#f92672>&lt;=</span> n; p<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, p &lt;= sqrt(n) é o mesmo que p*p &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> expoente <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> p;
</span></span><span style=display:flex><span>        expoente<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ans.emplace_back(p, expoente);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) ans.emplace_back(n, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=fatoração-em-olg-n-para-números-até-n>Fatoração em O(lg n) para números até N</h2><p>É possível fatorar números ate um limite <code>N</code> em <code>O(lg n)</code> após preprocessamento <code>O(n log( log n))</code>. O que fazemos é uma pequena modificação no código do crivo, para que enquanto fazemos o crivo, preenchamos um vetor auxiliar <code>lp</code>, aonde <code>lp[x]</code> representa o maior número primo que divide <code>x</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lp(N, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(lp[x] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) { <span style=color:#75715e>// se x nao foi marcado antes, é primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) <span style=color:#75715e>// todos os multiplos de i
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      lp[m] <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>Tendo este vetor podemos fatorar um numero <code>x</code> com o seguinte procedimento.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>  map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> expoentes;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>(x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    expoentes[ lp[x] ]<span style=color:#f92672>++</span>; <span style=color:#75715e>// aumentamos o expoente do primo lp[x] em 1 na resposta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    x <span style=color:#f92672>/=</span> lp[x];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p : expoentes)
</span></span><span style=display:flex><span>    ans.emplace_back(p);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade do procedimento acima é <code>O(quantidade de fatores)</code>, que é limitado por <code>O(lg n)</code>, da para ver que no pior caso todos os fatores são 2(menor primo) e a complexidade é o <code>k</code> de <code>2^k = n</code>.</p><h2 id=número-de-divisores-dada-uma-fatoração>Número de divisores dada uma fatoração</h2><p>Vimos que todo inteiro N pode ser escrito de forma única como multiplicação de números primos. Assim,</p><span class="math align-center">$$N = {p_1}^{e_1}.{p_2}^{e_2}.{p_3}^{e_3}.{p_4}^{e_4}.{p_5}^{e_5}.{p_6}^{e_6} ... $$</span><p>onde pi é primo e 0 ei > 0.</p><p>Todo divisor de N só pode ter primos que aparecem na fatoração de N e expoente no máximo o do expoente no N. Por exemplo:
<span class="math align-center">$$36 = 2^2.3^2$$</span></p><span class="math align-left">$$1 = 2^0.3^0$$</span>
<span class="math align-left">$$2 = 2^1.3^0$$</span>
<span class="math align-left">$$3 = 2^0.3^1$$</span>
<span class="math align-left">$$4 = 2^2.3^0$$</span>
<span class="math align-left">$$6 = 2^1.3^1$$</span>
<span class="math align-left">$$9 = 2^0.3^2$$</span>
<span class="math align-left">$$12 = 2^2.3^1$$</span>
<span class="math align-left">$$18 = 2^1.3^2$$</span>
<span class="math align-left">$$36 = 2^2.3^2$$</span><p>Para construir um divisor podemos escolher dentre (ei+1) possibilidades para o primo pi. O número total de divisores é a multiplicação desses termos. Assim 36 tem (2+1)*(2+1) = 9 divisores.</p><p>Embora esta ideia não melhore a complexidade para encontrar o número de divisores em comparação com as ideias anteriores, ela pode ser uma ferramenta útil para analisar problemas. Por exemplo, os números com exatamente 9 divisores são da forma</p><span class="math align-left">$${p_1}^8={p_1}^2.{p_2}^2$$</span><p>Como por exemplo:</p><span class="math align-left">$$256 = 2^8$$</span>
<span class="math align-left">$$6561 = 3^8$$</span>
<span class="math align-left">$$36 = 2^2.3^2$$</span>
<span class="math align-left">$$100 = 2^2.5^2$$</span>
<span class="math align-left">$$255 = 3^2.5^2$$</span><p>etc&mldr;</p><footer class=footline></footer></article></section></div></main></div><aside id=sidebar class="default-animation showVisitedLinks"><div id=header-wrapper class=default-animation><div id=header class=default-animation><img src=/images/logo.png alt=UnBalloon></div><div class="searchbox default-animation"><label class=a11y-only for=search-by>Procurar</label>
<i class="fas fa-search"></i>
<input data-search-input id=search-by type=search placeholder=Procurar...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["pt"]</script><script src=/js/auto-complete.js?1668562484 defer></script>
<script src=/js/lunr.min.js?1668562484 defer></script>
<script src=/js/lunr.stemmer.support.min.js?1668562484 defer></script>
<script src=/js/lunr.multi.min.js?1668562484 defer></script>
<script src=/js/lunr.pt.min.js?1668562484 defer></script>
<script src=/js/search.js?1668562484 defer></script></div><div id=homelinks class=default-animation><ul><li><a class=padding href=/><i class='fas fa-home'></i> Início</a></li></ul></div><div id=content-wrapper class=highlightable><ul class="topics collapsible-menu"><li data-nav-id=/materiais/ class="dd-item parent alwaysopen"><input type=checkbox id=section-cd3c658ea9d6611734f640a99ed351e7 aria-controls=subsections-cd3c658ea9d6611734f640a99ed351e7 class=toggle checked><label class="a11y-only toggle" for=section-cd3c658ea9d6611734f640a99ed351e7>Submenu Materiais</label><a href=/materiais/>Materiais<i class="fas fa-check read-icon"></i></a><ul id=subsections-cd3c658ea9d6611734f640a99ed351e7><li data-nav-id=/materiais/fundamentos/ class=dd-item><input type=checkbox id=section-fbd8681c1cd813fd274363752298e387 aria-controls=subsections-fbd8681c1cd813fd274363752298e387 class=toggle><label class="a11y-only toggle" for=section-fbd8681c1cd813fd274363752298e387>Submenu Fundamentos do C++</label><a href=/materiais/fundamentos/>Fundamentos do C++<i class="fas fa-check read-icon"></i></a><ul id=subsections-fbd8681c1cd813fd274363752298e387><li data-nav-id=/materiais/fundamentos/complexidade/ class=dd-item><a href=/materiais/fundamentos/complexidade/>Complexidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/input-output/ class=dd-item><a href=/materiais/fundamentos/input-output/>Entrada/Saída<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/ class=dd-item><input type=checkbox id=section-a42839fe6a6dc82d6acb542625c12ea3 aria-controls=subsections-a42839fe6a6dc82d6acb542625c12ea3 class=toggle><label class="a11y-only toggle" for=section-a42839fe6a6dc82d6acb542625c12ea3>Submenu Declarações</label><a href=/materiais/fundamentos/declaracoes/>Declarações<i class="fas fa-check read-icon"></i></a><ul id=subsections-a42839fe6a6dc82d6acb542625c12ea3><li data-nav-id=/materiais/fundamentos/declaracoes/string/ class=dd-item><a href=/materiais/fundamentos/declaracoes/string/>Strings<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/vector/ class=dd-item><a href=/materiais/fundamentos/declaracoes/vector/>Vector<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/pair/ class=dd-item><a href=/materiais/fundamentos/declaracoes/pair/>Pairs<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/iterators/ class=dd-item><a href=/materiais/fundamentos/declaracoes/iterators/>Iterators<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ class=dd-item><input type=checkbox id=section-0f35d6b01e259d59953ce71b0a1b869a aria-controls=subsections-0f35d6b01e259d59953ce71b0a1b869a class=toggle><label class="a11y-only toggle" for=section-0f35d6b01e259d59953ce71b0a1b869a>Submenu Estrutura de Dados</label><a href=/materiais/fundamentos/eds/>Estrutura de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-0f35d6b01e259d59953ce71b0a1b869a><li data-nav-id=/materiais/fundamentos/eds/ed_linear/ class=dd-item><input type=checkbox id=section-647945f1e1a23f4847ff7712e174196b aria-controls=subsections-647945f1e1a23f4847ff7712e174196b class=toggle><label class="a11y-only toggle" for=section-647945f1e1a23f4847ff7712e174196b>Submenu ED Linear</label><a href=/materiais/fundamentos/eds/ed_linear/>ED Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-647945f1e1a23f4847ff7712e174196b><li data-nav-id=/materiais/fundamentos/eds/ed_linear/pilha/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/pilha/>Pilha<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila/>Fila<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila_prioridade/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila_prioridade/>Fila de Prioridade<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/ class=dd-item><input type=checkbox id=section-b42c90bc6b6a5f5588c9a9bab5cef1a6 aria-controls=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6 class=toggle><label class="a11y-only toggle" for=section-b42c90bc6b6a5f5588c9a9bab5cef1a6>Submenu ED Não Linear</label><a href=/materiais/fundamentos/eds/ed_n_linear/>ED Não Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/map/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/map/>Map<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/set/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/set/>Set<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul></li><li data-nav-id=/materiais/ed/ class=dd-item><input type=checkbox id=section-b37842fb4120c27b31481184fc126654 aria-controls=subsections-b37842fb4120c27b31481184fc126654 class=toggle><label class="a11y-only toggle" for=section-b37842fb4120c27b31481184fc126654>Submenu Estruturas de Dados</label><a href=/materiais/ed/>Estruturas de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-b37842fb4120c27b31481184fc126654><li data-nav-id=/materiais/ed/delta_encoding/ class=dd-item><a href=/materiais/ed/delta_encoding/>Delta Encoding<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/psum/ class=dd-item><a href=/materiais/ed/psum/>Soma de Prefixos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/segtree/ class=dd-item><a href=/materiais/ed/segtree/>Segment Trees<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/sparse_table/ class=dd-item><a href=/materiais/ed/sparse_table/>Sparse Table<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/algoritmos/ class=dd-item><input type=checkbox id=section-586ba47d0e40b9c87415f456840d3d8a aria-controls=subsections-586ba47d0e40b9c87415f456840d3d8a class=toggle><label class="a11y-only toggle" for=section-586ba47d0e40b9c87415f456840d3d8a>Submenu Algoritmos</label><a href=/materiais/algoritmos/>Algoritmos<i class="fas fa-check read-icon"></i></a><ul id=subsections-586ba47d0e40b9c87415f456840d3d8a><li data-nav-id=/materiais/algoritmos/busca_binaria/ class=dd-item><a href=/materiais/algoritmos/busca_binaria/>Busca Binária<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/grafos/ class=dd-item><input type=checkbox id=section-2b03d3e4a9450bb4c9d2399c7f4c7068 aria-controls=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068 class=toggle><label class="a11y-only toggle" for=section-2b03d3e4a9450bb4c9d2399c7f4c7068>Submenu Grafos</label><a href=/materiais/grafos/>Grafos<i class="fas fa-check read-icon"></i></a><ul id=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068><li data-nav-id=/materiais/grafos/representacao/ class=dd-item><a href=/materiais/grafos/representacao/>Representação de Grafos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_largura/ class=dd-item><a href=/materiais/grafos/busca_largura/>Busca em Largura<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_profundidade/ class=dd-item><a href=/materiais/grafos/busca_profundidade/>Busca em Profundidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/dijkstra/ class=dd-item><a href=/materiais/grafos/dijkstra/>Dijkstra<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/bitwise/ class=dd-item><a href=/materiais/bitwise/>Bitwise<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/ class="dd-item active parent"><input type=checkbox id=section-99efeb3b1634e5d2f1c17337d707c814 aria-controls=subsections-99efeb3b1634e5d2f1c17337d707c814 class=toggle checked><label class="a11y-only toggle" for=section-99efeb3b1634e5d2f1c17337d707c814>Submenu Matematica</label><a href=/materiais/matematica/>Matematica<i class="fas fa-check read-icon"></i></a><ul id=subsections-99efeb3b1634e5d2f1c17337d707c814><li data-nav-id=/materiais/matematica/modulo/ class=dd-item><a href=/materiais/matematica/modulo/>Módulo<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/divisores/ class=dd-item><a href=/materiais/matematica/divisores/>Divisores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/primos/ class=dd-item><a href=/materiais/matematica/primos/>Números Primos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/fatoracao/ class=dd-item><a href=/materiais/matematica/fatoracao/>Fatoração<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/avancados/ class=dd-item><input type=checkbox id=section-57c0233d0cea835299bcd9b57157a588 aria-controls=subsections-57c0233d0cea835299bcd9b57157a588 class=toggle><label class="a11y-only toggle" for=section-57c0233d0cea835299bcd9b57157a588>Submenu Tópicos Avançados</label><a href=/materiais/avancados/>Tópicos Avançados<i class="fas fa-check read-icon"></i></a><ul id=subsections-57c0233d0cea835299bcd9b57157a588><li data-nav-id=/materiais/avancados/lca/ class=dd-item><a href=/materiais/avancados/lca/>Lowest Common Ancestor<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul><div id=shortcuts><div class=nav-title>Mais</div><ul><li><a class=padding href=https://github.com/UnBalloon/unballoon.github.io><i class='fab fa-fw fa-github'></i> Repositório GitHub</a></li><li><a class=padding href=https://codeforces.com/group/nituVTsHQX><i class='fa fa-code'></i> CodeForces</a></li><li><a class=padding href=/more/credits/><i class='fas fa-fw fa-bullhorn'></i> Créditos</a></li><li><a class=padding href=/tags/><i class='fas fa-fw fa-tags'></i> Tags</a></li></ul></div><div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"></div><hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch showVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><div class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-language>Idioma</label>
<select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></div></li><li id=select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-variant>Tema</label>
<select id=select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=relearn-dark value=relearn-dark selected>Relearn Dark</option><option id=relearn-light value=relearn-light>Relearn Light</option><option id=learn value=learn>Learn</option><option id=neon value=neon>Neon</option><option id=blue value=blue>Blue</option><option id=green value=green>Green</option><option id=red value=red>Red</option></select></div><div class=select-clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><a class=padding onclick=clearHistory()><i class="fas fa-history fa-fw"></i> Limpar Histórico</a></li></ul></div><div id=footer class="footerFooter showFooter"><style>#footer{font-size:13px;height:100px;margin-left:auto;margin-right:auto;padding:2rem 1rem;text-align:center;min-width:230px;max-width:300px}#footer p{margin:0}</style><a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/archive/main.zip data-icon=octicon-cloud-download aria-label="Download UnBalloon/unballoon.github.io on GitHub">Download</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io data-icon=octicon-star data-show-count=true aria-label="Star UnBalloon/unballoon.github.io on GitHub">Star</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/fork data-icon=octicon-repo-forked data-show-count=true aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a><p>2022 - <a href=https://github.com/BrunoVarg>Bruno Vargas</a></p><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p><script async src=/js/buttons.js?1668562484></script></div></div></aside><script src=/js/clipboard.min.js?1668562484 defer></script>
<script src=/js/perfect-scrollbar.min.js?1668562484 defer></script>
<script src=/js/featherlight.min.js?1668562484 defer></script>
<script>function useMathJax(e){if(!Object.assign)return;window.MathJax=Object.assign(window.MathJax||{},{loader:{load:["[tex]/mhchem"]},startup:{elements:[".math"]},tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/js/mathjax/tex-mml-chtml.js?1668562484></script>
<script src=/js/theme.js?1668562484 defer></script></body></html>