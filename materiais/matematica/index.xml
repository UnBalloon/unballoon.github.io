<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Matematica on UnBalloon</title><link>https://unballoon.github.io/materiais/matematica/</link><description>Recent content in Matematica on UnBalloon</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><atom:link href="https://unballoon.github.io/materiais/matematica/index.xml" rel="self" type="application/rss+xml"/><item><title>Módulo</title><link>https://unballoon.github.io/materiais/matematica/modulo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/matematica/modulo/</guid><description>Diversos problemas em juízes online (e competições) costumam pedir a resposta módulo algum primo alto (bastante comum 10^9 + 7). O motivo disso é evitar overflow. Por exemplo: finja que você tem o seguinte problema:
Imprimir o resultado de 3^x (0 &amp;lt;= x &amp;lt;= 100), por exemplo. Esse resultado claramente excede 2^64 (limite de long long), então não faz muito sentido pedir o resultado por si só (na verdade, alguns problemas realmente pedem coisas do tipo, nesses casos, o recomendado é usar python, que não tem overflow).</description></item><item><title>Divisores</title><link>https://unballoon.github.io/materiais/matematica/divisores/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/matematica/divisores/</guid><description>Um problema recorrente é o de encontrar divisores de um número positivo. A maneira mais simples de resolvê-lo seria passar por todos os números e testar se o resto da divisão é 0, ou seja, se é divisível.
vector&amp;lt;long long&amp;gt; all_divisors(long long n) { vector&amp;lt;long long&amp;gt; ans; for(long long i = 1; i &amp;lt;= n; i++) if(n % i == 0) ans.push_back(i); return ans; } é fácil ver que a complexidade do código acima é O(n), podemos fazer melhor que isso com algumas observações.</description></item><item><title>Números Primos</title><link>https://unballoon.github.io/materiais/matematica/primos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/matematica/primos/</guid><description>Em particular, sabendo a quantidade de divisores de cada número, podemos varrer esse vetor vendo quais números são primos (tem 2 divisores).
vector&amp;lt;int&amp;gt; primos_ate_n(int N) { vector&amp;lt;int&amp;gt; primos; for(int x = 1; x &amp;lt; N; x++) { if(qnt_div[x] == 2) primos.push_back(x); } return primos; } Crivo de erastótenes A abordagem acima tem uma complexidade aceitável, e passaria no tempo para a maioria dos problemas. No entanto, existe um algoritmo com uma ideia semelhante, mas que com algumas observações baixa essa complexidade de O(n * log n) para O(n * log( log n)).</description></item><item><title>Fatoração</title><link>https://unballoon.github.io/materiais/matematica/fatoracao/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/matematica/fatoracao/</guid><description>Aprendemos na escola que todo número é composto por fatores primos, existindo uma única fatoração pra cada número.
Uma primeira abordagem possível seria passar por todos os números e ir dividindo sempre que possível.
// retorna vetor de pair&amp;lt;primo, expoente&amp;gt; da fatoração // fatora(36) = [{2, 2}, {3, 2}] ou seja, 36 = 2^2 + 3^2 vector&amp;lt;pair&amp;lt;long long, int&amp;gt;&amp;gt; fatora(long long n) { vector&amp;lt;pair&amp;lt;long long, int&amp;gt;&amp;gt; ans; for(long long p = 2; p &amp;lt;= n; p++) { if(n % p == 0){ int expoente = 0; while(n % p == 0) { n /= p; expoente++; } ans.</description></item></channel></rss>