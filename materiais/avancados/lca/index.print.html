<!doctype html><html lang=pt dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.111.3"><meta name=generator content="Relearn 5.4.0+tip"><meta name=description content="Repositorio do UnBalloon"><meta name=author content="Bruno Vargas"><title>Lowest Common Ancestor :: UnBalloon</title><link href=/materiais/avancados/lca/ rel=canonical type=text/html title=UnBalloon><link href=/materiais/avancados/lca/index.xml rel=alternate type=application/rss+xml title=UnBalloon><link href=/images/favicon.png?1682198470 rel=icon type=image/png><link href=/css/fontawesome-all.min.css?1682198470 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css?1682198470 rel=stylesheet></noscript><link href=/css/featherlight.min.css?1682198470 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/featherlight.min.css?1682198470 rel=stylesheet></noscript><link href=/css/auto-complete.css?1682198470 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/auto-complete.css?1682198470 rel=stylesheet></noscript><link href=/css/perfect-scrollbar.min.css?1682198470 rel=stylesheet><link href=/css/nucleus.css?1682198470 rel=stylesheet><link href=/css/fonts.css?1682198470 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css?1682198470 rel=stylesheet></noscript><link href=/css/theme.css?1682198470 rel=stylesheet><link href=/css/theme-relearn-dark.css?1682198470 rel=stylesheet id=variant-style><link href=/css/ie.css?1682198470 rel=stylesheet><link href=/css/variant.css?1682198470 rel=stylesheet><link href=/css/print.css?1682198470 rel=stylesheet media=print><link href=/css/format-print.css?1682198470 rel=stylesheet><script src=/js/variant.js?1682198470></script>
<script>window.index_js_url="/index.search.js";var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copiar para a área de transferência",window.T_Copied_to_clipboard="Copiado para a área de transferência!",window.T_Copy_link_to_clipboard="Link de cópia para a área de transferência",window.T_Link_copied_to_clipboard="Link copiado para a área de transferência!",baseUriFull="https://unballoon.github.io/",window.variants&&variants.init(["relearn-dark","relearn-light","neon","learn","blue","green","red"])</script><script src=/js/jquery.min.js?1682198470 defer></script></head><body class="mobile-support print" data-url=/materiais/avancados/lca/><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div class=navigation><span class="nav nav-next"><i class="fa fa-chevron-right fa-fw"></i></span></div><div class=navigation><a class="nav nav-prev" href=/materiais/avancados/ title="Tópicos Avançados (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a></div><div id=top-print-link><a class=print-link title='Imprimir capítulo inteiro (CTRL+ALT+p)' href=/materiais/avancados/lca/index.print.html><i class="fas fa-print fa-fw"></i></a></div><div id=top-github-link><a class=github-link title='Editar (CTRL+ALT+w)' href=https://github.com/UnBalloon/unballoon.github.io/edit/main/content/materiais/avancados/lca/_index.md target=blank><i class="fas fa-pen fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span>
<span id=toc-menu title='Índice (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/materiais/><span itemprop=name>Materiais</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/materiais/avancados/><span itemprop=name>Tópicos Avançados</span></a><meta itemprop=position content="2">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Lowest Common Ancestor</span><meta itemprop=position content="3"></li></ol></div><div class="default-animation progress"><div class=toc-wrapper dir=ltr><nav id=TableOfContents><ul><li><a href=#o-pulo-do-gato>O pulo do gato</a><ul><li><a href=#versão-recursiva>Versão recursiva</a></li><li><a href=#versão-iterativa>Versão iterativa</a></li><li><a href=#versão-final-do-código>Versão final do código</a></li><li><a href=#versão-final-do-código-1>Versão final do código</a></li><li><a href=#conclusão>Conclusão</a></li></ul></li><li><a href=#abordagem-2>Abordagem 2</a></li><li><a href=#materiais-complementares>Materiais complementares</a></li><li><a href=#exercícios-recomendados>Exercícios recomendados</a></li></ul></nav></div></div></div></nav><main id=body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><div id=head-tags><div class=tags dir=ltr><a class=tag-link href=/tags/avancado/>avancado</a></div></div><article class=chapter dir=ltr><div class=article-subheading>Capítulo 27</div><h1>Lowest Common Ancestor</h1><p>Lowest Common ancestor (LCA) - ou ancestral comum mais baixo, é o nome típico dado para o seguinte problema: dado uma Árvore cuja raiz é um vértice arbitrário <code>e</code> dois vértices <code>u,v</code> que a pertencem, diga qual é o nó mais baixo(relativo a raiz) que é ancestral de <code>u,v</code>.</p><p><img src=https://i.imgur.com/OuGPlXf.png alt=a title=a></p><p>Por exemplo na imagem a cima, o LCA de 2 e 3 é 1, o LCA de 6 e 7 é 0, e o LCA de 1 e 2 é 1.</p><p>um jeito naive de se fazer isso seria o seguinte, para cada nó da árvore, pré-processamos sua profundidade com relação a raiz (raiz tem profundidade 0, filhos 1, e assim por diante). Agora, para determinarmos os LCA de dois vértices <code>u,v</code>, podemos fazer o seguinte procedimento. Escolhemos qual dos dois vértices está mais profundo, subimos nos seus pais até igualar as alturas de ambos, e após isso, vamos subindo em ambos os caminhos um a um até que os caminhos se encontrem, então saberemos o LCA.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> depth[<span style=color:#ae81ff>100005</span>];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[<span style=color:#ae81ff>100005</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pre_process_depth</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>	depth[u] <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> adj : graph[u]) {
</span></span><span style=display:flex><span>		pre_process_depth(adj, d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>slow_lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) {
</span></span><span style=display:flex><span>		swap(u, v);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(depth[u] <span style=color:#f92672>&gt;</span> depth[v]) {
</span></span><span style=display:flex><span>		u <span style=color:#f92672>=</span> pai[u];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(u <span style=color:#f92672>!=</span> v) {
</span></span><span style=display:flex><span>		u <span style=color:#f92672>=</span> pai[u];
</span></span><span style=display:flex><span>		v <span style=color:#f92672>=</span> pai[v];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essa estratégia efetivamente funciona, então teríamos um pré-processamento que é um DFS e após isso conseguiríamos responder queries em <code>O(n)</code>, pois numa árvore com um ramo muito profundo teríamos no pior caso que subir todos os vértices, portando complexidade total de <code>O(n + Qn) = O(Qn)</code> onde <code>Q</code> é o número de queries e <code>n</code> a quantidade de nós na árvore.</p><p>O LCA é relevante porque como em uma árvore há um único caminho que liga dois vértices, se conseguimos obter o LCA rápido então uma das coisas que já ganhamos de quebra é conseguir responder as distâncias entre quaisquer par de vértices.</p><p>A distância vai ser a distância de um vértice para o LCA e do LCA para o outro, sendo que essas duas distâncias intermediárias são apenas a diferença de alturas na árvore.</p><p>Aqui nesse tutorial vamos mostrar duas ideias para computar LCA, uma que vai nos permitir responder Queries de LCA em <code>O(log n)</code> com preprocessamento <code>O(n log n)</code> e uma segunda abordagem que vai nos permitir responder queries de LCA em <code>O(1)</code> (isso mesmo, tempo constante!) com preprocessamento <code>O(n log n)</code> também.</p><p>Apesar de a complexidade da segunda abordagem para responder queries de LCA ser estritamente melhor que da primeira, veremos que a primeira carrega um pouco mais de informação, permitindo obter algumas outras informações fora o LCA, enquanto na segunda podemos obter apenas o LCA.</p><h1 id=abordagem-1>Abordagem 1</h1><p>O problema da solução naive é essa subida de um em um até que atinjamos o pai comum. Então faz sentido tentarmos atacarmos isso para ganhar um desempenho assintótico melhor. Uma coisa a se observar é que estamos fazendo duas buscas lineares. A primeira busca linear é pelo primeiro ancestral de <code>u</code> que iguala a altura a <code>v</code> e após isso outra busca linear para procurar o primeiro ancestral de ambos que é comum.</p><p>Podemos observar que há monotonicidade nessas buscas lineares, até certo ponto os ancestrais não satisfazem uma condição, e após certo ponto todos satisfazem. Na primeira estaríamos buscando o ancestral mais baixo de <code>u</code> que satisfaz a condição &ldquo;Ter altura menor ou igual a v&rdquo;, e na segunda &ldquo;Ser ancestral de <code>v</code>&rdquo;.</p><p>Aqui usaremos o conceito de &ldquo;k-ésimo pai&rdquo; que funciona assim: o primeiro pai é o pai do vértice, o segundo pai é o pai do pai do vértice, e assim por diante.</p><p>Se nós tivéssemos uma função <em>mágica</em> chamada por exemplo <code>climb(n,k)</code> que nos retornasse o k-ésimo pai do vértice <code>n</code>, poderíamos então usar buscas binárias na quantidade de vértices a subir para resolver esse problema, e restaria implementar essa função de maneira eficiente. Vamos seguir por essa linha de raciocínio então.</p><h2 id=o-pulo-do-gato>O pulo do gato</h2><p>Se nós tivéssemos uma outra função <code>mágica</code> chamada <code>p2k(n,k)</code> que retorna o (2^k)-ésimo pai de um vértice <code>n</code>, poderíamos implementar a função que sobe <code>k</code> vértices da seguinte maneira. Se nosso grafo tem tamanho menor que <code>10^6</code>, sabemos que não precisamos subir mais do que <code>2^20</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>climb</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&gt;=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i)) {
</span></span><span style=display:flex><span>			node <span style=color:#f92672>=</span> p2k(node,i);
</span></span><span style=display:flex><span>			k <span style=color:#f92672>-=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade dessa função depende do número que colocamos no for, que não precisa ser maior do que o <code>log</code> do tamanho do grafo(não faz sentido subir mais nós do que o grafo possui), então conseguimos obter o k-ésimo ancestral de um vértice arbitrário em complexidade <code>O(log) * X</code> aonde X é a complexidade de p2k.</p><p>Mostramos agora que podemos preprocessar todos os valores possíveis de p2k em <code>O(n log n)</code>. Precisamos saber os valores dos ancestrais para todos os <code>n</code> vértices e para cada vértice só faz sentido saber <code>log</code> ancestrais. Podemos obter todos os valores de uma vez usando programação dinâmica, com uma recorrência muito elegante.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>p2k</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> p2k(p2k(node, k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=versão-recursiva>Versão recursiva</h3><p>Usamos então memoização para computarmos cada estado em <code>O(1)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> memo[SIZE][log2(GRAPHSIZE)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>p2k</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(memo[node][k] <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> memo[node][k];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> memo[node][k] <span style=color:#f92672>=</span> p2k(p2k(node, k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=versão-iterativa>Versão iterativa</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> p2k[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	p2k[node][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pai[node];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		p2k[node][k] <span style=color:#f92672>=</span> p2k[p2k[node][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Dessa forma então temos o seguinte procedimento para acharmos o LCA, fazemos uma busca binária, em cada iteração obtemos o k-ésimo ancestral, e checamos se ele satisfaz as propriedades, tendo então complexidade <code>O(log n * log n) = O(log^2 n)</code>, já que fazemos <code>log</code> iterações e em cada iteração demoramos <code>log</code> para obter o k-ésimo ancestral. Isso funciona, mas podemos melhorar um pouco mais.</p><p>Ao invés de usarmos busca binária vamos usar uma técnica conhecida como <code>binary lifting</code> ou escalada binária, basicamente vamos percorrer bit a bit vendo se esse bit está na resposta ou não.</p><p>A ideia é a seguinte, vamos supor que a resposta da busca binária de o quanto eu tenho que subir a partir de um vértice para satisfazer uma propriedade seja 6(o primeiro ancestral que satisfaz a propriedade é o sexto pai). Podemos usar escala binária para procurar pelo último vértice que ainda não satisfaz a propriedade (no caso então seria o 5).</p><p>Usando nossa função p2k, podemos começar vendo se o oitavo pai já satisfaz a propriedade e sim satisfaz, então como estamos buscando o último que ainda satisfaz, não subimos para o oitavo pai. Depois verificamos que o quarto pai que ainda não satisfaz, então subimos para ele. Depois verificamos o segundo pai do quarto pai, isto é, o sexto pai do vértice original, que já satisfaz, então não subimos para ele, e por último, verificamos o pai do quarto pai (quinto pai do vértice original), que não satisfaz, então subimos pra ele e sabemos o último vértice que ainda não satisfaz a propriedade.</p><p>A escalada binária pode ser usada nas mesmas situações aonde a busca binária pode ser usada, mas algumas vezes (como essa), podemos obter uma complexidades assintóticas melhores.</p><p>Cada checagem para ver se um dos (2^k)-ésimos pais satisfazem a propriedade é constante, e checamos os pais <code>(2^k), 2^(k-1), 2^(k-2),..., 1</code> sempre dividindo por 2, então passamos por no máximo <code>log</code> vezes nessa checagem, portanto com essa ideia podemos obter o <code>lca</code> em <code>O(log n)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) swap(u,v);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(depth[p2k[u][i]] <span style=color:#f92672>&gt;=</span> depth[v])
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(u <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(p2k[v][i] <span style=color:#f92672>!=</span> p2k[u][i]) {
</span></span><span style=display:flex><span>			v <span style=color:#f92672>=</span> p2k[v][i];
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pai[v];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Perceba que estamos fazendo exatamente a ideia primeiramente apresentada na solução naive. Primeiro pegamos o vértice que está mais embaixo e subimos ele até o nível do outro, e após isso, subimos em ambos os vértices procurando o primeiro ancestral comum, mas em vez de fazermos busca linear, fazemos escalada binária.</p><p>A escala binária desempenha melhor nessa situação(em relação a busca binária) porque quando vamos construir o (n-ésimo) pai para fazer a checagem (somando vários (2^k)-ésimos pais) na busca binária, estaríamos colocando os mesmos vértices todas as vezes, por exemplo, tome o exemplo aonde o último vértice que satisfaz uma propridade é o 26.</p><pre tabindex=0><code>l = 0, r = 32, mid = 16(16), checagem passa.
l = 16, r = 32, mid = 24(16 + 8), checagem passa.
l = 24, r = 32, mid = 28(16 + 8 + 4), checagem falha
l = 24, r = 28, mid = 26(16 + 8 + 2), checagem passa
l = 26, r = 28, mid = 27(16 + 8 + 2 + 1), checagem falha
</code></pre><p>Quando a checagem passou para mid = 16, podíamos ter certeza que tinhamos que subir pelo menos até o décimo sexto pai, mas aí nos checks subsequentes perdemos tempo reconstruindo a resposta que já conhecemos. Então o que a escala binária faz é tomar vantagem disso.</p><h3 id=versão-final-do-código>Versão final do código</h3><p>Agora como mencionado podemos obter rapidamente a distância entre quaisquer 2 nós na árvore.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dist</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> depth[u] <span style=color:#f92672>+</span> depth[v] <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>depth[lca(u,v)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=versão-final-do-código-1>Versão final do código</h3><p>Apesar de não fazermos a busca binária que usava a função climb no final, é possível que essa implementação seja útil em alguns problemas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> depth[SIZE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pre_process_depth</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>	depth[u] <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> adj : graph[u]) {
</span></span><span style=display:flex><span>		pre_process_depth(adj, d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> p2k[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) swap(u,v);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(depth[p2k[u][i]] <span style=color:#f92672>&gt;=</span> depth[v])
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(u <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(p2k[v][i] <span style=color:#f92672>!=</span> p2k[u][i]) {
</span></span><span style=display:flex><span>			v <span style=color:#f92672>=</span> p2k[v][i];
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pai[v];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>climb</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&gt;=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i)) {
</span></span><span style=display:flex><span>			node <span style=color:#f92672>=</span> p2k[node][i];
</span></span><span style=display:flex><span>			k <span style=color:#f92672>-=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dist</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> depth[u] <span style=color:#f92672>+</span> depth[v] <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>depth[lca(u,v)];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// codigo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// le os pais e monta o grafo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pai[raiz] <span style=color:#f92672>=</span> raiz;
</span></span><span style=display:flex><span>	pre_proccess_depth(raiz); <span style=color:#75715e>// tipicamente qual vertice é a raiz nao importa
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>		p2k[node][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>			p2k[node][k] <span style=color:#f92672>=</span> p2k[p2k[node][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// resolve problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=conclusão>Conclusão</h3><p>Com essa abordagem, com preprocessamento <code>O(n log n)</code>, podemos responder queries de LCA (e climb, e dist) em <code>O(log n)</code>, além disso, podemos modificar a DP do LCA para guardar mais informações além de qual o (2^k)-ésimo pai, por exemplo a aresta mínima(ou máxima) nesse caminho, a soma dos custos das arestas(caso hajam pesos), máximo divisor comum, etc.</p><h2 id=abordagem-2>Abordagem 2</h2><p>A segunda abordagem usa uma ideia diferente, mas que também é muito top. Com preprocessamento <code>O(n log n)</code> podemos fazer queries de LCA em <code>O(1)</code>. Parando pra pensar nisso, é muito poderoso, não importa o quanto seja o tamanho do grafo, teremos a resposta em tempo constante! A ideia para atingir essa complexidade é a seguinte. Sabemos que usando uma Sparse Table(Vide aula de Sparse Table) podemos resolver problemas de RMQ (range minimum query) em <code>O(1)</code>, com preprocessamento <code>O(n log n)</code> a ideia é construir um vetor de forma que a RMQ nele representa a query de LCA.</p><h2 id=materiais-complementares>Materiais complementares</h2><p><a href="https://www.youtube.com/watch?v=EKcQt-74bNw">https://www.youtube.com/watch?v=EKcQt-74bNw</a></p><h2 id=exercícios-recomendados>Exercícios recomendados</h2><ul><li><a href=https://codeforces.com/problemset/problem/208/e>https://codeforces.com/problemset/problem/208/e</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2470>https://www.urionlinejudge.com.br/judge/pt/problems/view/2470</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1135>https://www.urionlinejudge.com.br/judge/pt/problems/view/1135</a></li><li><a href=https://www.spoj.com/problems/QTREE2/>https://www.spoj.com/problems/QTREE2/</a> - queries de distancia e obter k-ésimo vértice no caminho, Só da pra obter késimo vértice com LCA log.</li></ul><footer class=footline></footer></article></div></main></div><aside id=sidebar class="default-animation showVisitedLinks"><div id=header-wrapper class=default-animation><div id=header class=default-animation><img src=/images/logo.png alt=UnBalloon></div><div class="searchbox default-animation"><label class=a11y-only for=search-by>Procurar</label>
<i class="fas fa-search"></i>
<input data-search-input id=search-by type=search placeholder=Procurar...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["pt"]</script><script src=/js/auto-complete.js?1682198470 defer></script>
<script src=/js/lunr.min.js?1682198470 defer></script>
<script src=/js/lunr.stemmer.support.min.js?1682198470 defer></script>
<script src=/js/lunr.multi.min.js?1682198470 defer></script>
<script src=/js/lunr.pt.min.js?1682198470 defer></script>
<script src=/js/search.js?1682198470 defer></script></div><div id=homelinks class=default-animation><ul><li><a class=padding href=/><i class='fas fa-home'></i> Início</a></li></ul></div><div id=content-wrapper class=highlightable><ul class="topics collapsible-menu"><li data-nav-id=/sobre/ class="dd-item alwaysopen"><input type=checkbox id=section-6ddbbbfc94aba0359e47bedbb5c0bf1e aria-controls=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e class=toggle checked><label class="a11y-only toggle" for=section-6ddbbbfc94aba0359e47bedbb5c0bf1e>Submenu Sobre</label><a href=/sobre/>Sobre<i class="fas fa-check read-icon"></i></a><ul id=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e><li data-nav-id=/sobre/dicas/ class=dd-item><a href=/sobre/dicas/>Dicas para Iniciantes<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/unb/ class=dd-item><a href=/sobre/unb/>UnB na Competitiva<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/eventos/ class=dd-item><a href=/sobre/eventos/>Eventos Anteriores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/competicoes/ class=dd-item><a href=/sobre/competicoes/>Competições<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/referencias/ class=dd-item><a href=/sobre/referencias/>Referências<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/ class="dd-item parent alwaysopen"><input type=checkbox id=section-cd3c658ea9d6611734f640a99ed351e7 aria-controls=subsections-cd3c658ea9d6611734f640a99ed351e7 class=toggle checked><label class="a11y-only toggle" for=section-cd3c658ea9d6611734f640a99ed351e7>Submenu Materiais</label><a href=/materiais/>Materiais<i class="fas fa-check read-icon"></i></a><ul id=subsections-cd3c658ea9d6611734f640a99ed351e7><li data-nav-id=/materiais/fundamentos/ class=dd-item><input type=checkbox id=section-fbd8681c1cd813fd274363752298e387 aria-controls=subsections-fbd8681c1cd813fd274363752298e387 class=toggle><label class="a11y-only toggle" for=section-fbd8681c1cd813fd274363752298e387>Submenu Fundamentos do C++</label><a href=/materiais/fundamentos/>Fundamentos do C++<i class="fas fa-check read-icon"></i></a><ul id=subsections-fbd8681c1cd813fd274363752298e387><li data-nav-id=/materiais/fundamentos/complexidade/ class=dd-item><a href=/materiais/fundamentos/complexidade/>Complexidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/input-output/ class=dd-item><a href=/materiais/fundamentos/input-output/>Entrada/Saída<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/ class=dd-item><input type=checkbox id=section-a42839fe6a6dc82d6acb542625c12ea3 aria-controls=subsections-a42839fe6a6dc82d6acb542625c12ea3 class=toggle><label class="a11y-only toggle" for=section-a42839fe6a6dc82d6acb542625c12ea3>Submenu Declarações</label><a href=/materiais/fundamentos/declaracoes/>Declarações<i class="fas fa-check read-icon"></i></a><ul id=subsections-a42839fe6a6dc82d6acb542625c12ea3><li data-nav-id=/materiais/fundamentos/declaracoes/string/ class=dd-item><a href=/materiais/fundamentos/declaracoes/string/>Strings<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/vector/ class=dd-item><a href=/materiais/fundamentos/declaracoes/vector/>Vector<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/pair/ class=dd-item><a href=/materiais/fundamentos/declaracoes/pair/>Pairs<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/iterators/ class=dd-item><a href=/materiais/fundamentos/declaracoes/iterators/>Iterators<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ class=dd-item><input type=checkbox id=section-0f35d6b01e259d59953ce71b0a1b869a aria-controls=subsections-0f35d6b01e259d59953ce71b0a1b869a class=toggle><label class="a11y-only toggle" for=section-0f35d6b01e259d59953ce71b0a1b869a>Submenu Estrutura de Dados</label><a href=/materiais/fundamentos/eds/>Estrutura de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-0f35d6b01e259d59953ce71b0a1b869a><li data-nav-id=/materiais/fundamentos/eds/ed_linear/ class=dd-item><input type=checkbox id=section-647945f1e1a23f4847ff7712e174196b aria-controls=subsections-647945f1e1a23f4847ff7712e174196b class=toggle><label class="a11y-only toggle" for=section-647945f1e1a23f4847ff7712e174196b>Submenu ED Linear</label><a href=/materiais/fundamentos/eds/ed_linear/>ED Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-647945f1e1a23f4847ff7712e174196b><li data-nav-id=/materiais/fundamentos/eds/ed_linear/pilha/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/pilha/>Pilha<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila/>Fila<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila_prioridade/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila_prioridade/>Fila de Prioridade<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/ class=dd-item><input type=checkbox id=section-b42c90bc6b6a5f5588c9a9bab5cef1a6 aria-controls=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6 class=toggle><label class="a11y-only toggle" for=section-b42c90bc6b6a5f5588c9a9bab5cef1a6>Submenu ED Não Linear</label><a href=/materiais/fundamentos/eds/ed_n_linear/>ED Não Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/map/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/map/>Map<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/set/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/set/>Set<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul></li><li data-nav-id=/materiais/ed/ class=dd-item><input type=checkbox id=section-b37842fb4120c27b31481184fc126654 aria-controls=subsections-b37842fb4120c27b31481184fc126654 class=toggle><label class="a11y-only toggle" for=section-b37842fb4120c27b31481184fc126654>Submenu Estruturas de Dados</label><a href=/materiais/ed/>Estruturas de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-b37842fb4120c27b31481184fc126654><li data-nav-id=/materiais/ed/delta_encoding/ class=dd-item><a href=/materiais/ed/delta_encoding/>Delta Encoding<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/psum/ class=dd-item><a href=/materiais/ed/psum/>Soma de Prefixos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/segtree/ class=dd-item><a href=/materiais/ed/segtree/>Segment Trees<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/sparse_table/ class=dd-item><a href=/materiais/ed/sparse_table/>Sparse Table<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/algoritmos/ class=dd-item><input type=checkbox id=section-586ba47d0e40b9c87415f456840d3d8a aria-controls=subsections-586ba47d0e40b9c87415f456840d3d8a class=toggle><label class="a11y-only toggle" for=section-586ba47d0e40b9c87415f456840d3d8a>Submenu Algoritmos</label><a href=/materiais/algoritmos/>Algoritmos<i class="fas fa-check read-icon"></i></a><ul id=subsections-586ba47d0e40b9c87415f456840d3d8a><li data-nav-id=/materiais/algoritmos/busca_binaria/ class=dd-item><a href=/materiais/algoritmos/busca_binaria/>Busca Binária<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/grafos/ class=dd-item><input type=checkbox id=section-2b03d3e4a9450bb4c9d2399c7f4c7068 aria-controls=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068 class=toggle><label class="a11y-only toggle" for=section-2b03d3e4a9450bb4c9d2399c7f4c7068>Submenu Grafos</label><a href=/materiais/grafos/>Grafos<i class="fas fa-check read-icon"></i></a><ul id=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068><li data-nav-id=/materiais/grafos/representacao/ class=dd-item><a href=/materiais/grafos/representacao/>Representação de Grafos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_largura/ class=dd-item><a href=/materiais/grafos/busca_largura/>Busca em Largura<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_profundidade/ class=dd-item><a href=/materiais/grafos/busca_profundidade/>Busca em Profundidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/dijkstra/ class=dd-item><a href=/materiais/grafos/dijkstra/>Dijkstra<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/bitwise/ class=dd-item><a href=/materiais/bitwise/>Bitwise<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/ class=dd-item><input type=checkbox id=section-99efeb3b1634e5d2f1c17337d707c814 aria-controls=subsections-99efeb3b1634e5d2f1c17337d707c814 class=toggle><label class="a11y-only toggle" for=section-99efeb3b1634e5d2f1c17337d707c814>Submenu Matematica</label><a href=/materiais/matematica/>Matematica<i class="fas fa-check read-icon"></i></a><ul id=subsections-99efeb3b1634e5d2f1c17337d707c814><li data-nav-id=/materiais/matematica/modulo/ class=dd-item><a href=/materiais/matematica/modulo/>Módulo<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/divisores/ class=dd-item><a href=/materiais/matematica/divisores/>Divisores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/primos/ class=dd-item><a href=/materiais/matematica/primos/>Números Primos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/fatoracao/ class=dd-item><a href=/materiais/matematica/fatoracao/>Fatoração<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/avancados/ class="dd-item parent"><input type=checkbox id=section-57c0233d0cea835299bcd9b57157a588 aria-controls=subsections-57c0233d0cea835299bcd9b57157a588 class=toggle checked><label class="a11y-only toggle" for=section-57c0233d0cea835299bcd9b57157a588>Submenu Tópicos Avançados</label><a href=/materiais/avancados/>Tópicos Avançados<i class="fas fa-check read-icon"></i></a><ul id=subsections-57c0233d0cea835299bcd9b57157a588><li data-nav-id=/materiais/avancados/lca/ class="dd-item active"><a href=/materiais/avancados/lca/>Lowest Common Ancestor<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul><div id=shortcuts><div class=nav-title>Mais</div><ul><li><a class=padding href=https://github.com/UnBalloon/unballoon.github.io><i class='fab fa-fw fa-github'></i> Repositório GitHub</a></li><li><a class=padding href=https://codeforces.com/group/nituVTsHQX><i class='fa fa-code'></i> CodeForces</a></li><li><a class=padding href=https://t.me/unballoon><i class='fab fa-fw fa-telegram'></i> Telegram</a></li><li><a class=padding href=https://discord.gg/uc4htcV7fD><i class='fab fa-fw fa-discord'></i> Discord</a></li><li><a class=padding href=/more/credits/><i class='fas fa-fw fa-bullhorn'></i> Créditos</a></li><li><a class=padding href=/tags/><i class='fas fa-fw fa-tags'></i> Tags</a></li></ul></div><div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"></div><hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch showVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><div class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-language>Idioma</label>
<select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></div></li><li id=select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-variant>Tema</label>
<select id=select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=relearn-dark value=relearn-dark selected>Relearn Dark</option><option id=relearn-light value=relearn-light>Relearn Light</option><option id=neon value=neon>Neon</option><option id=learn value=learn>Learn</option><option id=blue value=blue>Blue</option><option id=green value=green>Green</option><option id=red value=red>Red</option></select></div><div class=select-clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><a class=padding onclick=clearHistory()><i class="fas fa-history fa-fw"></i> Limpar Histórico</a></li></ul></div><div id=footer class="footerFooter showFooter"><style>#footer{font-size:13px;height:100px;margin-left:auto;margin-right:auto;padding:2rem 1rem;text-align:center;min-width:230px;max-width:300px}#footer p{margin:0}</style><a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/archive/main.zip data-icon=octicon-cloud-download aria-label="Download UnBalloon/unballoon.github.io on GitHub">Download</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io data-icon=octicon-star data-show-count=true aria-label="Star UnBalloon/unballoon.github.io on GitHub">Star</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/fork data-icon=octicon-repo-forked data-show-count=true aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a><p>2023 - <a href=https://github.com/BrunoVarg>Bruno Vargas</a></p><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p><script asy unballoon procurar início submenu sobre sobre dicas para iniciantes unb na competitiva eventos anteriores competições referências submenu materiais materiais submenu fundamentos do c++ fundamentos do c++ submenu estruturas de dados estruturas de dados submenu algoritmos algoritmos submenu grafos grafos bitwise submenu matematica matematica submenu tópicos avançados tópicos avançados mais repositório github codeforces telegram discord créditos tags tema limpar histórico 2023 - bruno vargas built with by hugo nc src=/js/buttons.js?1682198470></script></div></div></aside><script src=/js/clipboard.min.js?1682198470 defer></script>
<script src=/js/perfect-scrollbar.min.js?1682198470 defer></script>
<script src=/js/featherlight.min.js?1682198470 defer></script>
<script src=/js/theme.js?1682198470 defer></script></body></html>