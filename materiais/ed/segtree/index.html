<!doctype html><html lang=pt dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.111.3"><meta name=generator content="Relearn 5.4.0+tip"><meta name=description content="Repositorio do UnBalloon"><meta name=author content="Bruno Vargas"><title>Segment Trees :: UnBalloon</title><link href=/materiais/ed/segtree/index.xml rel=alternate type=application/rss+xml title=UnBalloon><link href=/materiais/ed/segtree/index.print.html rel=alternate type=text/html title=UnBalloon><link href=/images/favicon.png?1682184136 rel=icon type=image/png><link href=/css/fontawesome-all.min.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css?1682184136 rel=stylesheet></noscript><link href=/css/featherlight.min.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/featherlight.min.css?1682184136 rel=stylesheet></noscript><link href=/css/auto-complete.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/auto-complete.css?1682184136 rel=stylesheet></noscript><link href=/css/perfect-scrollbar.min.css?1682184136 rel=stylesheet><link href=/css/nucleus.css?1682184136 rel=stylesheet><link href=/css/fonts.css?1682184136 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css?1682184136 rel=stylesheet></noscript><link href=/css/theme.css?1682184136 rel=stylesheet><link href=/css/theme-neon.css?1682184136 rel=stylesheet id=variant-style><link href=/css/ie.css?1682184136 rel=stylesheet><link href=/css/variant.css?1682184136 rel=stylesheet><link href=/css/print.css?1682184136 rel=stylesheet media=print><script src=/js/variant.js?1682184136></script>
<script>window.index_js_url="/index.search.js";var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copiar para a área de transferência",window.T_Copied_to_clipboard="Copiado para a área de transferência!",window.T_Copy_link_to_clipboard="Link de cópia para a área de transferência",window.T_Link_copied_to_clipboard="Link copiado para a área de transferência!",baseUriFull="https://unballoon.github.io/",window.variants&&variants.init(["neon","relearn-dark","relearn-light","learn","blue","green","red"])</script><script src=/js/jquery.min.js?1682184136 defer></script></head><body class="mobile-support html" data-url=/materiais/ed/segtree/><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div class=navigation><a class="nav nav-next" href=/materiais/ed/sparse_table/ title="Sparse Table (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a></div><div class=navigation><a class="nav nav-prev" href=/materiais/ed/psum/ title="Soma de Prefixos (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a></div><div id=top-print-link><a class=print-link title='Imprimir capítulo inteiro (CTRL+ALT+p)' href=/materiais/ed/segtree/index.print.html><i class="fas fa-print fa-fw"></i></a></div><div id=top-github-link><a class=github-link title='Editar (CTRL+ALT+w)' href=https://github.com/UnBalloon/unballoon.github.io/edit/main/content/materiais/ed/segtree/_index.md target=blank><i class="fas fa-pen fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span>
<span id=toc-menu title='Índice (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/materiais/><span itemprop=name>Materiais</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/materiais/ed/><span itemprop=name>Estruturas de Dados</span></a><meta itemprop=position content="2">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Segment Trees</span><meta itemprop=position content="3"></li></ol></div><div class="default-animation progress"><div class=toc-wrapper dir=ltr><nav id=TableOfContents><ul><li><a href=#representação>Representação</a></li><li><a href=#operação>Operação</a></li><li><a href=#elemento-neutro>Elemento neutro</a></li><li><a href=#consulta>Consulta</a></li><li><a href=#atualização>Atualização</a></li><li><a href=#declaração>Declaração</a></li><li><a href=#interface>Interface</a><ul><li><a href=#segtree>SegTree</a></li><li><a href=#query>query</a></li><li><a href=#update>update</a></li></ul></li><li><a href=#construção>Construção</a></li><li><a href=#atualizações-em-intervalos>Atualizações em intervalos</a></li></ul><ul><li><a href=#a-ideia>A ideia</a></li><li><a href=#vetor-de-lazy>vetor de lazy</a></li><li><a href=#a-propagação>A propagação</a></li><li><a href=#a-função-de-atualização-em-intervalo>A função de atualização em intervalo</a></li><li><a href=#versão-final>Versão final</a></li><li><a href=#problemas-recomendados>Problemas recomendados</a></li></ul></nav></div></div></div></nav><main id=body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><div id=head-tags><div class=tags dir=ltr><a class=tag-link href=/tags/intermediario/>intermediario</a></div></div><article class=chapter dir=ltr><div class=article-subheading>Capítulo 14</div><h1>Segment Trees</h1><p>Segment tree (Segtree) é outra estrutura de dados para lidar com problemas de consulta em intervalos. O que tornas as segtrees poderosas é sua capacidade de fazer atualização e consulta em intervalos em complexidade <code>O(log n)</code>, além do tipo da consulta ser bem abrangente.</p><p>A ideia é a seguinte: Criamos uma árvore, de forma que cada nodo representa a informação que desejamos saber a respeito de um segmento do vetor, e tem dois filhos, um filho representa a metade esquerda desse intervalo, e o outro, a metade direita. Esse processo recursa até que os intervalos atinjam tamanho 1.</p><p>Aqui há uma demonstação visual de como funciona: <a href=https://visualgo.net/en/segmenttree>https://visualgo.net/en/segmenttree</a></p><p>É interessante entender o funcionamento da segtree pois, por mais que tenhamos o código pronto, quando mudamos de operação ou precisamos inserir long longs, será necessário mexer na sua estrutura interna.</p><h2 id=representação>Representação</h2><p>Nossa segtree será representada como um vetor. Cada nodo terá um id nesse vetor, e o conteúdo dessa posição representa a informação que aquele nodo guarda. A raiz da segtree será o nodo 0, que guarda a informação sobre o vetor todo. A partir do índice <code>id</code> de um nodo, podemos obter os filhos sem colisões da seguinte forma: índice dos filhos esquerdo e direito são <code>(id*2 + 1,id*2 +2)</code>, respectivamente.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span></code></pre></div><h2 id=operação>Operação</h2><p>Essa função define que informação queremos saber a respeito dos elementos do vetor. Nese caso é uma segtree que computa o máximo de intervalos, mas poderia ser soma, mínimo, produto, xor, gcd, mmc(lcm), or e and lógicos etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(a,b);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=elemento-neutro>Elemento neutro</h2><p>O elemento neutro depende da operação. Como queremos saber os máximos, o elemento neutro dessa operação seria um número muito baixo, que nunca será o máximo.</p><p>Caso não saiba a definição de elemento neutro, a definição é a seguinte: <code>e</code> é um elemento neutro da operação f se <code>f(e,x) = x</code> para todo <code>x</code>.</p><p>Caso fosse uma soma, nosso elemento neutro seria 0, caso fosse um produto, seria 1, etc..</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>(<span style=color:#ae81ff>1e9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span></code></pre></div><h2 id=consulta>Consulta</h2><p>A função recursiva abaixo responde às consultas na segtree. Cada parâmetro tem o seguinte significado:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>l</code> : limite inferior do intervalo que queremos fazer a consulta</li><li><code>r</code> : limite superior do intervalo que queremos fazer a consulta</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//O nodo está fora do intervalo que estamos interessados, retorne o elemento neutro que não afeta a consulta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl) 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// O nodo está completamente incluído no intervalos que estamos interessados, retorne a informação contida naquele nodo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Se chegarmos aqui, é porque esse Nodo está parcialmente contido no intervalo que estamos interessados. Então, continuamos procurando nos filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=atualização>Atualização</h2><p>Essa função atualiza um elemento da segtree. Cada parâmetro tem o seguinte significado:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>i</code> : índice do <strong>vetor</strong> que queremos atualizar</li><li><code>amm</code>: novo valor daquele índice no vetor</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Chegamos no índice que queremos, vamos atualizar o valor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>==</span> i and str <span style=color:#f92672>==</span> i){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// O intervalo que estamos não contem o índice que queremos atualizar, retorne
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> i or str <span style=color:#f92672>&lt;</span> i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// O intervalo contém o índice, mas temos que chegar no nodo específico, recurse para os filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,i,amm);
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,i,amm);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Após os filhos mais em baixo, precisamos atualizar o valor desse nodo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=declaração>Declaração</h2><p>Essa é a classe com as funcionalidades implementadas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span>  <span style=color:#a6e22e>SegTree</span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>(<span style=color:#ae81ff>1e9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(a,b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>==</span> i and str <span style=color:#f92672>==</span> i){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>+=</span> amm;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> i or str <span style=color:#f92672>&lt;</span> i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,i,amm);
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,i,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){update(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,i,amm);}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=interface>Interface</h2><p>Os métodos que mostramos são todos internos da segtree, na hora de chama-los, não precisamos passar tantos parâmetros assim.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){update(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,i,amm);}
</span></span></code></pre></div><h3 id=segtree>SegTree</h3><p>Construtor, recebe o tamanho do vetor.</p><h3 id=query>query</h3><p>Executa uma consulta, recebe o intervalo(l,r) da consulta, retorna o resultado.</p><h3 id=update>update</h3><p>Atualiza um índice no vetor recebe o índice e o novo valor.</p><h2 id=construção>Construção</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>SegTree <span style=color:#a6e22e>st</span>(v.size());
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span> v.size();i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    st.update(i,v[i]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=atualizações-em-intervalos>Atualizações em intervalos</h2><p>A segtree que temos até agora faz atualização de uma posição no vetor e consulta de qualquer em intervalo, em <code>O(log n)</code>. Mas e se precisarmos atualizar um intervalo, por exemplo: &ldquo;Todos os elementos da posição 1 até 10 recebem 2&rdquo;. Assim, a melhor forma que teríamos de fazer isso seria</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SegTree <span style=color:#a6e22e>st</span>(n);
</span></span><span style=display:flex><span><span style=color:#75715e>// preenche segtree
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    st.update(i,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O que tem complexidade <code>O(n * log n)</code>. Precisamos fazer isso mais rápido.</p><h1 id=lazy-progapation>Lazy progapation</h1><p>Lazy propagation é uma alteração na segtree que nos permite fazer atualizações em intervalos em <code>O(log n)</code>.</p><h2 id=a-ideia>A ideia</h2><p>Em nossa abordagem anterior, o que tornava a execução lenta é que procurávamos o nodo responsável por cada elemento que precisava ser atualizado.</p><p>Para acelerar esse processo, podemos usar uma ideia parecida com a da consulta, em vez de atualizar individualmente os elementos, podemos atualizar a resposta nos intervalos que os contém, e postergar a atualização nos filhos.</p><p>Para implementar lazy propagation, cada configuração de segtree vai requerer uma implementação um pouco diferente, por isso, será necessário entender o que cada parte do código está fazendo.</p><p>O exemplo a seguir será de uma segtree de soma, aonde a atualização de intervalo vai setar todos os elementos para um qualquer.</p><h2 id=vetor-de-lazy>vetor de lazy</h2><p>A ideia é introduzir um vetor extra com o seguinte significado: Quando eu passar no nodo identificado por id, em uma consulta, ou outra atualização, preciso atualizar seu valor para <code>lazy[id]</code>. O vetor has indica se há uma atualização para ser feita naquele nodo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lazy;
</span></span><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> has;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> size;
</span></span></code></pre></div><h2 id=a-propagação>A propagação</h2><p>A função de propagação é a função que atualiza o valor de um nodo, e posterga a atualização para os filhos. Precisamos chamar essa função toda vez que passamos por algum nodo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>propagate</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str){
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Se há algo para atualizar, atualize()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>if</span>(has[sti])
</span></span><span style=display:flex><span>           <span style=color:#75715e>//O valor desse nodo da segtree será (número de elementos que esse intervalo representa vezes novo valor de cada elemento do intervalo)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           st[sti] <span style=color:#f92672>=</span> lazy[sti] <span style=color:#f92672>*</span> (str <span style=color:#f92672>-</span> stl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>           <span style=color:#75715e>// Se o nó representa um segmento de tamanho maior que 1, isto é, não é terminal, propague a atualização para os filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>!=</span> str){
</span></span><span style=display:flex><span>               lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>               lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>               has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>               has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>           <span style=color:#75715e>// agora não é mais necessário atualizar esse nodo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           has[sti] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><h2 id=a-função-de-atualização-em-intervalo>A função de atualização em intervalo</h2><p>Essa é a função que realiza a atualização de intervalos. O significado dos argumentos é:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>l</code>: limite inferior do intervalo que queremos atualizar no <strong>vetor</strong></li><li><code>r</code>: limite superior do intervalo que queremos atualizar no <strong>vetor</strong></li><li><code>amm</code>: novo valor dos elementos nesse intervalo</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l,<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r){
</span></span><span style=display:flex><span>            <span style=color:#75715e>// O valor que será atribuido a todo elemento no intervalo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            lazy[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            propagate(sti, stl, str);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> r  or str <span style=color:#f92672>&lt;</span> l)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r,amm);
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=versão-final>Versão final</h2><p>Essa é a versão final da nossa ED.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span>  <span style=color:#a6e22e>SegTree</span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lazy;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> has;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>propagate</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(has[sti]){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>=</span> lazy[sti] <span style=color:#f92672>*</span> (str <span style=color:#f92672>-</span> stl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>!=</span> str){
</span></span><span style=display:flex><span>                lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>                lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>        propagate(sti, stl, str);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l,<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r){
</span></span><span style=display:flex><span>            lazy[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            propagate(sti, stl, str);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> r  or str <span style=color:#f92672>&lt;</span> l)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r,amm);
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>), lazy(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>),has(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,false){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){update_range(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r,amm);}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=problemas-recomendados>Problemas recomendados</h2><ul><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2531>Compras em FdI</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1301>Produto do Intervalo</a></li><li><a href=https://codeforces.com/contest/1234/problem/D>Distinct Characthers</a></li><li><a href=https://codeforces.com/contest/830/problem/B>Cards Sorting</a></li><li><a href=https://codeforces.com/contest/474/problem/F>Ant Colony</a></li><li><a href=https://codeforces.com/contest/339/problem/D>Xenia and Bit Operations</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1500>Consultas Horríveis</a></li><li><a href=https://codeforces.com/contest/920/problem/F>SUM and REPLACE</a></li><li><a href=https://codeforces.com/contest/380/problem/C>Sereja and Brackets</a></li><li><a href=https://www.spoj.com/problems/KQUERY/>Kquery</a></li><li><a href=https://www.spoj.com/problems/DQUERY/>DQuery</a></li></ul><footer class=footline></footer></article></div></main></div><aside id=sidebar class="default-animation showVisitedLinks"><div id=header-wrapper class=default-animation><div id=header class=default-animation><img src=/images/logo.png alt=UnBalloon></div><div class="searchbox default-animation"><label class=a11y-only for=search-by>Procurar</label>
<i class="fas fa-search"></i>
<input data-search-input id=search-by type=search placeholder=Procurar...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["pt"]</script><script src=/js/auto-complete.js?1682184136 defer></script>
<script src=/js/lunr.min.js?1682184136 defer></script>
<script src=/js/lunr.stemmer.support.min.js?1682184136 defer></script>
<script src=/js/lunr.multi.min.js?1682184136 defer></script>
<script src=/js/lunr.pt.min.js?1682184136 defer></script>
<script src=/js/search.js?1682184136 defer></script></div><div id=homelinks class=default-animation><ul><li><a class=padding href=/><i class='fas fa-home'></i> Início</a></li></ul></div><div id=content-wrapper class=highlightable><ul class="topics collapsible-menu"><li data-nav-id=/sobre/ class="dd-item alwaysopen"><input type=checkbox id=section-6ddbbbfc94aba0359e47bedbb5c0bf1e aria-controls=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e class=toggle checked><label class="a11y-only toggle" for=section-6ddbbbfc94aba0359e47bedbb5c0bf1e>Submenu Sobre</label><a href=/sobre/>Sobre<i class="fas fa-check read-icon"></i></a><ul id=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e><li data-nav-id=/sobre/dicas/ class=dd-item><a href=/sobre/dicas/>Dicas para Iniciantes<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/unb/ class=dd-item><a href=/sobre/unb/>UnB na Competitiva<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/eventos/ class=dd-item><a href=/sobre/eventos/>Eventos Anteriores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/competicoes/ class=dd-item><a href=/sobre/competicoes/>Competições<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/referencias/ class=dd-item><a href=/sobre/referencias/>Referências<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/ class="dd-item parent alwaysopen"><input type=checkbox id=section-cd3c658ea9d6611734f640a99ed351e7 aria-controls=subsections-cd3c658ea9d6611734f640a99ed351e7 class=toggle checked><label class="a11y-only toggle" for=section-cd3c658ea9d6611734f640a99ed351e7>Submenu Materiais</label><a href=/materiais/>Materiais<i class="fas fa-check read-icon"></i></a><ul id=subsections-cd3c658ea9d6611734f640a99ed351e7><li data-nav-id=/materiais/fundamentos/ class=dd-item><input type=checkbox id=section-fbd8681c1cd813fd274363752298e387 aria-controls=subsections-fbd8681c1cd813fd274363752298e387 class=toggle><label class="a11y-only toggle" for=section-fbd8681c1cd813fd274363752298e387>Submenu Fundamentos do C++</label><a href=/materiais/fundamentos/>Fundamentos do C++<i class="fas fa-check read-icon"></i></a><ul id=subsections-fbd8681c1cd813fd274363752298e387><li data-nav-id=/materiais/fundamentos/complexidade/ class=dd-item><a href=/materiais/fundamentos/complexidade/>Complexidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/input-output/ class=dd-item><a href=/materiais/fundamentos/input-output/>Entrada/Saída<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/ class=dd-item><input type=checkbox id=section-a42839fe6a6dc82d6acb542625c12ea3 aria-controls=subsections-a42839fe6a6dc82d6acb542625c12ea3 class=toggle><label class="a11y-only toggle" for=section-a42839fe6a6dc82d6acb542625c12ea3>Submenu Declarações</label><a href=/materiais/fundamentos/declaracoes/>Declarações<i class="fas fa-check read-icon"></i></a><ul id=subsections-a42839fe6a6dc82d6acb542625c12ea3><li data-nav-id=/materiais/fundamentos/declaracoes/string/ class=dd-item><a href=/materiais/fundamentos/declaracoes/string/>Strings<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/vector/ class=dd-item><a href=/materiais/fundamentos/declaracoes/vector/>Vector<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/pair/ class=dd-item><a href=/materiais/fundamentos/declaracoes/pair/>Pairs<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/iterators/ class=dd-item><a href=/materiais/fundamentos/declaracoes/iterators/>Iterators<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ class=dd-item><input type=checkbox id=section-0f35d6b01e259d59953ce71b0a1b869a aria-controls=subsections-0f35d6b01e259d59953ce71b0a1b869a class=toggle><label class="a11y-only toggle" for=section-0f35d6b01e259d59953ce71b0a1b869a>Submenu Estrutura de Dados</label><a href=/materiais/fundamentos/eds/>Estrutura de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-0f35d6b01e259d59953ce71b0a1b869a><li data-nav-id=/materiais/fundamentos/eds/ed_linear/ class=dd-item><input type=checkbox id=section-647945f1e1a23f4847ff7712e174196b aria-controls=subsections-647945f1e1a23f4847ff7712e174196b class=toggle><label class="a11y-only toggle" for=section-647945f1e1a23f4847ff7712e174196b>Submenu ED Linear</label><a href=/materiais/fundamentos/eds/ed_linear/>ED Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-647945f1e1a23f4847ff7712e174196b><li data-nav-id=/materiais/fundamentos/eds/ed_linear/pilha/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/pilha/>Pilha<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila/>Fila<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila_prioridade/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila_prioridade/>Fila de Prioridade<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/ class=dd-item><input type=checkbox id=section-b42c90bc6b6a5f5588c9a9bab5cef1a6 aria-controls=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6 class=toggle><label class="a11y-only toggle" for=section-b42c90bc6b6a5f5588c9a9bab5cef1a6>Submenu ED Não Linear</label><a href=/materiais/fundamentos/eds/ed_n_linear/>ED Não Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/map/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/map/>Map<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/set/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/set/>Set<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul></li><li data-nav-id=/materiais/ed/ class="dd-item parent"><input type=checkbox id=section-b37842fb4120c27b31481184fc126654 aria-controls=subsections-b37842fb4120c27b31481184fc126654 class=toggle checked><label class="a11y-only toggle" for=section-b37842fb4120c27b31481184fc126654>Submenu Estruturas de Dados</label><a href=/materiais/ed/>Estruturas de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-b37842fb4120c27b31481184fc126654><li data-nav-id=/materiais/ed/delta_encoding/ class=dd-item><a href=/materiais/ed/delta_encoding/>Delta Encoding<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/psum/ class=dd-item><a href=/materiais/ed/psum/>Soma de Prefixos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/segtree/ class="dd-item active"><a href=/materiais/ed/segtree/>Segment Trees<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/sparse_table/ class=dd-item><a href=/materiais/ed/sparse_table/>Sparse Table<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/algoritmos/ class=dd-item><input type=checkbox id=section-586ba47d0e40b9c87415f456840d3d8a aria-controls=subsections-586ba47d0e40b9c87415f456840d3d8a class=toggle><label class="a11y-only toggle" for=section-586ba47d0e40b9c87415f456840d3d8a>Submenu Algoritmos</label><a href=/materiais/algoritmos/>Algoritmos<i class="fas fa-check read-icon"></i></a><ul id=subsections-586ba47d0e40b9c87415f456840d3d8a><li data-nav-id=/materiais/algoritmos/busca_binaria/ class=dd-item><a href=/materiais/algoritmos/busca_binaria/>Busca Binária<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/grafos/ class=dd-item><input type=checkbox id=section-2b03d3e4a9450bb4c9d2399c7f4c7068 aria-controls=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068 class=toggle><label class="a11y-only toggle" for=section-2b03d3e4a9450bb4c9d2399c7f4c7068>Submenu Grafos</label><a href=/materiais/grafos/>Grafos<i class="fas fa-check read-icon"></i></a><ul id=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068><li data-nav-id=/materiais/grafos/representacao/ class=dd-item><a href=/materiais/grafos/representacao/>Representação de Grafos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_largura/ class=dd-item><a href=/materiais/grafos/busca_largura/>Busca em Largura<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_profundidade/ class=dd-item><a href=/materiais/grafos/busca_profundidade/>Busca em Profundidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/dijkstra/ class=dd-item><a href=/materiais/grafos/dijkstra/>Dijkstra<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/bitwise/ class=dd-item><a href=/materiais/bitwise/>Bitwise<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/ class=dd-item><input type=checkbox id=section-99efeb3b1634e5d2f1c17337d707c814 aria-controls=subsections-99efeb3b1634e5d2f1c17337d707c814 class=toggle><label class="a11y-only toggle" for=section-99efeb3b1634e5d2f1c17337d707c814>Submenu Matematica</label><a href=/materiais/matematica/>Matematica<i class="fas fa-check read-icon"></i></a><ul id=subsections-99efeb3b1634e5d2f1c17337d707c814><li data-nav-id=/materiais/matematica/modulo/ class=dd-item><a href=/materiais/matematica/modulo/>Módulo<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/divisores/ class=dd-item><a href=/materiais/matematica/divisores/>Divisores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/primos/ class=dd-item><a href=/materiais/matematica/primos/>Números Primos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/fatoracao/ class=dd-item><a href=/materiais/matematica/fatoracao/>Fatoração<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/avancados/ class=dd-item><input type=checkbox id=section-57c0233d0cea835299bcd9b57157a588 aria-controls=subsections-57c0233d0cea835299bcd9b57157a588 class=toggle><label class="a11y-only toggle" for=section-57c0233d0cea835299bcd9b57157a588>Submenu Tópicos Avançados</label><a href=/materiais/avancados/>Tópicos Avançados<i class="fas fa-check read-icon"></i></a><ul id=subsections-57c0233d0cea835299bcd9b57157a588><li data-nav-id=/materiais/avancados/lca/ class=dd-item><a href=/materiais/avancados/lca/>Lowest Common Ancestor<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul><div id=shortcuts><div class=nav-title>Mais</div><ul><li><a class=padding href=https://github.com/UnBalloon/unballoon.github.io><i class='fab fa-fw fa-github'></i> Repositório GitHub</a></li><li><a class=padding href=https://codeforces.com/group/nituVTsHQX><i class='fa fa-code'></i> CodeForces</a></li><li><a class=padding href=https://t.me/unballoon><i class='fab fa-fw fa-telegram'></i> Telegram</a></li><li><a class=padding href=https://discord.gg/uc4htcV7fD><i class='fab fa-fw fa-discord'></i> Discord</a></li><li><a class=padding href=/more/credits/><i class='fas fa-fw fa-bullhorn'></i> Créditos</a></li><li><a class=padding href=/tags/><i class='fas fa-fw fa-tags'></i> Tags</a></li></ul></div><div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"></div><hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch showVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><div class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-language>Idioma</label>
<select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></div></li><li id=select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-variant>Tema</label>
<select id=select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=neon value=neon selected>Neon</option><option id=relearn-dark value=relearn-dark>Relearn Dark</option><option id=relearn-light value=relearn-light>Relearn Light</option><option id=learn value=learn>Learn</option><option id=blue value=blue>Blue</option><option id=green value=green>Green</option><option id=red value=red>Red</option></select></div><div class=select-clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><a class=padding onclick=clearHistory()><i class="fas fa-history fa-fw"></i> Limpar Histórico</a></li></ul></div><div id=footer class="footerFooter showFooter"><style>#footer{font-size:13px;height:100px;margin-left:auto;margin-right:auto;padding:2rem 1rem;text-align:center;min-width:230px;max-width:300px}#footer p{margin:0}</style><a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/archive/main.zip data-icon=octicon-cloud-download aria-label="Download UnBalloon/unballoon.github.io on GitHub">Download</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io data-icon=octicon-star data-show-count=true aria-label="Star UnBalloon/unballoon.github.io on GitHub">Star</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/fork data-icon=octicon-repo-forked data-show-count=true aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a><p>2023 - <a href=https://github.com/BrunoVarg>Bruno Vargas</a></p><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p><script asy unballoon procurar início submenu sobre sobre dicas para iniciantes unb na competitiva eventos anteriores competições referências submenu materiais materiais submenu fundamentos do c++ fundamentos do c++ submenu estruturas de dados estruturas de dados submenu algoritmos algoritmos submenu grafos grafos bitwise submenu matematica matematica submenu tópicos avançados tópicos avançados mais repositório github codeforces telegram discord créditos tags tema limpar histórico 2023 - bruno vargas built with by hugo nc src=/js/buttons.js?1682184136></script></div></div></aside><script src=/js/clipboard.min.js?1682184136 defer></script>
<script src=/js/perfect-scrollbar.min.js?1682184136 defer></script>
<script src=/js/featherlight.min.js?1682184136 defer></script>
<script src=/js/theme.js?1682184136 defer></script></body></html>