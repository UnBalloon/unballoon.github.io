<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Estruturas de Dados on UnBalloon</title><link>https://unballoon.github.io/materiais/ed/</link><description>Recent content in Estruturas de Dados on UnBalloon</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><atom:link href="https://unballoon.github.io/materiais/ed/index.xml" rel="self" type="application/rss+xml"/><item><title>Delta Encoding</title><link>https://unballoon.github.io/materiais/ed/delta_encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/ed/delta_encoding/</guid><description>Problemas de atualização em intervalos Suponha que você se depare com um problema do seguinte tipo:
Você recebe um vetor v , inicialmente com todos seus números zerados, e q queries. cada query virá representada por 3 inteiros (l,r,x). Ao receber cada query, a mudança esperada é: &amp;ldquo;Para cada número no vetor, seja i o seu índice. Se l &amp;lt;= i &amp;lt;= r, v[i] deve ter x adicionado ao seu valor.</description></item><item><title>Soma de Prefixos</title><link>https://unballoon.github.io/materiais/ed/psum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/ed/psum/</guid><description>Problemas de consulta em intervalos Suponha que você se depare com o seguinte problema:
É dado um vetor V, com n números inteiros, em seguida, um número q de consultas que serão feitas nesse vetor. Cada consulta consiste de um par de inteiros (l,r), representando um intervalo, a resposta para cada consulta é a soma dos inteiros nesse intervalo(inclusivo).
Até agora, em qual complexidade sabemos resolver esse problema?
A solução simples seria:</description></item><item><title>Segment Trees</title><link>https://unballoon.github.io/materiais/ed/segtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/ed/segtree/</guid><description>Segment tree (Segtree) é outra estrutura de dados para lidar com problemas de consulta em intervalos. O que tornas as segtrees poderosas é sua capacidade de fazer atualização e consulta em intervalos em complexidade O(log n), além do tipo da consulta ser bem abrangente.
A ideia é a seguinte: Criamos uma árvore, de forma que cada nodo representa a informação que desejamos saber a respeito de um segmento do vetor, e tem dois filhos, um filho representa a metade esquerda desse intervalo, e o outro, a metade direita.</description></item><item><title>Sparse Table</title><link>https://unballoon.github.io/materiais/ed/sparse_table/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://unballoon.github.io/materiais/ed/sparse_table/</guid><description>Nesse tutorial vamos falar sobre uma estrutura de dados chamada Sparse Table, que é uma estrutura de dados poderosa para resolvermos range queries de algumas operações específicas em complexidades superiores as de uma Segment Tree por exemplo.
Por exemplo, uma Sparse Table conseque resolver range minimum(ou maximum) query em O(1), enquanto numa segment tree precisaríamos de O(log n). Outro exemplo poderia ser range query de gcd, numa Segment Tree podemos resolver range queries de GCD em O(log^2 n), já na sparse table conseguimos isso em O(log n).</description></item></channel></rss>