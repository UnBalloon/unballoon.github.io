<!doctype html><html lang=pt dir=ltr><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.111.3"><meta name=generator content="Relearn 5.4.0+tip"><meta name=description content="Repositorio do UnBalloon"><meta name=author content="Bruno Vargas"><title>Materiais :: UnBalloon</title><link href=/materiais/ rel=canonical type=text/html title=UnBalloon><link href=/materiais/index.xml rel=alternate type=application/rss+xml title=UnBalloon><link href=/images/favicon.png?1682198716 rel=icon type=image/png><link href=/css/fontawesome-all.min.css?1682198716 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fontawesome-all.min.css?1682198716 rel=stylesheet></noscript><link href=/css/featherlight.min.css?1682198716 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/featherlight.min.css?1682198716 rel=stylesheet></noscript><link href=/css/auto-complete.css?1682198716 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/auto-complete.css?1682198716 rel=stylesheet></noscript><link href=/css/perfect-scrollbar.min.css?1682198716 rel=stylesheet><link href=/css/nucleus.css?1682198716 rel=stylesheet><link href=/css/fonts.css?1682198716 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/css/fonts.css?1682198716 rel=stylesheet></noscript><link href=/css/theme.css?1682198716 rel=stylesheet><link href=/css/theme-relearn-dark.css?1682198716 rel=stylesheet id=variant-style><link href=/css/ie.css?1682198716 rel=stylesheet><link href=/css/variant.css?1682198716 rel=stylesheet><link href=/css/print.css?1682198716 rel=stylesheet media=print><link href=/css/format-print.css?1682198716 rel=stylesheet><script src=/js/variant.js?1682198716></script>
<script>window.index_js_url="/index.search.js";var root_url="/",baseUriFull,baseUri=root_url.replace(/\/$/,"");window.T_Copy_to_clipboard="Copiar para a área de transferência",window.T_Copied_to_clipboard="Copiado para a área de transferência!",window.T_Copy_link_to_clipboard="Link de cópia para a área de transferência",window.T_Link_copied_to_clipboard="Link copiado para a área de transferência!",baseUriFull="https://unballoon.github.io/",window.variants&&variants.init(["relearn-dark","relearn-light","neon","learn","blue","green","red"])</script><script src=/js/jquery.min.js?1682198716 defer></script></head><body class="mobile-support print" data-url=/materiais/><div id=body class=default-animation><div id=sidebar-overlay></div><div id=toc-overlay></div><nav id=topbar class=highlightable><div><div class=navigation><a class="nav nav-next" href=/materiais/fundamentos/ title="Fundamentos do C++ (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a></div><div class=navigation><a class="nav nav-prev" href=/sobre/referencias/ title="Referências (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a></div><div id=top-print-link><a class=print-link title='Imprimir capítulo inteiro (CTRL+ALT+p)' href=/materiais/index.print.html><i class="fas fa-print fa-fw"></i></a></div><div id=top-github-link><a class=github-link title='Editar (CTRL+ALT+w)' href=https://github.com/UnBalloon/unballoon.github.io/edit/main/content/materiais/_index.md target=blank><i class="fas fa-pen fa-fw"></i></a></div><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a></span>
<span id=toc-menu title='Índice (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/><span itemprop=name>UnBalloon</span></a><meta itemprop=position content="1">></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Materiais</span><meta itemprop=position content="2"></li></ol></div><div class="default-animation progress"><div class=toc-wrapper dir=ltr><nav id=TableOfContents><ul><li><a href=#conteúdos-de-programação-competitiva>Conteúdos de Programação Competitiva</a></li><li><a href=#subpáginas>Subpáginas</a></li></ul></nav></div></div></div></nav><main id=body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><div id=head-tags></div><article class=default dir=ltr><h1>Materiais</h1><h2 id=conteúdos-de-programação-competitiva>Conteúdos de Programação Competitiva</h2><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/>Fundamentos do C++</a></li><li><a href=/materiais/ed/>Estruturas de Dados</a></li><li><a href=/materiais/algoritmos/>Algoritmos</a></li><li><a href=/materiais/grafos/>Grafos</a></li><li><a href=/materiais/bitwise/>Bitwise</a></li><li><a href=/materiais/matematica/>Matematica</a></li><li><a href=/materiais/avancados/>Tópicos Avançados</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Materiais</h1><article class=default dir=ltr><h1>Fundamentos do C++</h1><h2 id=tudo-o-que-você-precisa-saber-sobre-c>Tudo o que você precisa saber sobre C++</h2><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/complexidade/>Complexidade</a></li><li><a href=/materiais/fundamentos/input-output/>Entrada/Saída</a></li><li><a href=/materiais/fundamentos/declaracoes/>Declarações</a></li><li><a href=/materiais/fundamentos/eds/>Estrutura de Dados</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Fundamentos do C++</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 1</div><h1>Complexidade</h1><h2 id=o-que-é-complexidade>O que é Complexidade?</h2><hr><p>Em linhas gerais, a complexidade de tempo de um algoritmo é o quanto as variáveis de entrada impactam no seu tempo de execução.</p><p>Para se referir a complexidade de um algoritmo, se usa a notação Big O, denotada por <code>O(N)</code>. A notação Big O tem o seguinte significado: No pior caso da execução deste algoritmo, o número de operações realizado será proporcional a <code>N</code>, e por simplicidade, eliminamos constantes e fatores não dominantes. A quantidade de operações que os computadores atuais executam em um segundo é por volta de 10^8, portanto podemos estimar o tempo de execução de um programa usando análise de complexidade. Basta fazer o cálculo de complexidade e dividir por 10^8, e a resposta será aproximadamente o tempo de execução em segundos. Esse mesmo conceito se extende a memória utilizada por um programa, podemos fazer o cálculo de complexidade e dividir o resultado por 10^6, e saberemos quantos MegaBytes serão utilizados pelo programa no pior caso.</p><p>Exemplos:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Hello World</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><p>Esse código tem complexidade <code>O(1)</code> (também chamado de complexidade constante), porque nenhuma variável de entrada impacta no seu tempo de execução. A complexidade de memória também é <code>O(1)</code>.</p><h1 id=loops>Loops</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Esse código tem complexidade <code>O(n)</code>, pois o seu tempo tempo de execução cresce linearmente dependendo da variável <code>n</code>. A memória necessária não depende de nenhuma variável de entrada então é <code>O(1)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span><span style=color:#f92672>*</span>n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Esse código também tem complexidade <code>O(n)</code>, porque eliminamos os fatores constantes para manter a simplicidade. Complexidade de memória <code>O(1)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n,m;
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>,<span style=color:#f92672>&amp;</span>n,<span style=color:#f92672>&amp;</span>m);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Muitas vezes, a complexidade depende de mais de uma variável de entrada. Como não temos nenhuma informação sobre o significado das variáveis, a complexidade é <code>O(n+m)</code>. Se soubéssemos por exemplo que m fosse sempre muito maior que m, poderíamos dizer <code>O(m)</code>. Mais uma vez a memória utilizada não depende de nenhuma variável de entrada.</p><h2 id=multiplicação-de-matrizes>Multiplicação de matrizes</h2><hr><p>O código abaixo computa C = A * B, onde A é uma matriz n por p e B é uma matriz p por m.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> m; j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        C[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> p; k<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            C[i][j] <span style=color:#f92672>+=</span> A[i][k] <span style=color:#f92672>*</span> B[k][j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}	
</span></span></code></pre></div><p>Como os fors estão aninhados a complexidade do código é a multiplicação das complexidades de cada for, sendo então, <code>O(n*m*p)</code>. A multiplicação produz a matriz C como resultado, que tem dimenções <code>n</code> por <code>m</code>, Como é necessário alocar esse espaço, a complexidade de memória é <code>O(n*m)</code>.</p><h2 id=ordenação>Ordenação</h2><hr><p>Um problema bastante estudado é o de ordenação. Existem vários algoritmos resolvem o problema eficientemente, não será mostrado um desses. O código a seguir ordena um vetor <code>v</code> de tamanho <code>n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&lt;</span> n; j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(v[i] <span style=color:#f92672>&gt;</span> v[j]){
</span></span><span style=display:flex><span>            tmp <span style=color:#f92672>=</span> v[i];
</span></span><span style=display:flex><span>            v[i] <span style=color:#f92672>=</span> v[j];
</span></span><span style=display:flex><span>            v[j] <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A quantidade de vezes que o segundo loop executa depende do i, então é um pouco mais difícil de analisar a complexidade.</p><p>Ao longo das iterações do primeiro loop, a quantidade de iterações do segundo é <code>n + (n-1) + (n-2) + (n-3) + ... + 1</code>, ou seja, é soma de <a href=https://educacao.uol.com.br/disciplinas/matematica/progressao-artimetica-pa-formula-da-soma-e-do-termo-geral.htm>PA</a> e podemos resolver para <code>O((n+1)*n/2)</code>. Em análise de complexidade só nos importamos com quando as variáveis são muito grandes(tendem a infinito), de um modo bem bruto infinito e infinito/2 dá no mesmo, então podemos escrever a complexidade como <code>O((n+1)*n)</code>. Novamente quando pensamos em números bem altos <code>n</code> e <code>n+1</code> se tornam praticamente a mesma coisa e podemos concluir que a complexidade é <code>O(n^2)</code>.</p><p>Portanto podemos dizer que a complexidade do código acima é <code>O((n+1)*n/2)</code>, <code>O((n+1)*n)</code> ou <code>O(n^2)</code>. Mas geralmente optamos pela forma mais simples que é <code>O(n^2)</code>.</p><p>A intuição sobre a complexidade de memória pode acabar te enganando nesse exemplo. O motivo é o seguinte: o código apenas troca os valores de lugar dentro do vetor, não sendo necessário alocar um novo vetor com a resposta(Ao contrário da multiplicação de matrizes), então a complexidade de memória é <code>O(1)</code>.</p><h1 id=recursão>Recursão</h1><p>Também é possível analisar a complexidade de funções recursivas.</p><h2 id=exponenciação>Exponenciação</h2><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>slow_exp</span>(<span style=color:#66d9ef>int</span> base, <span style=color:#66d9ef>int</span> e){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(e <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> base <span style=color:#f92672>*</span> slow_exp(base,e<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nessa função, em cada chamada, o expoente decresce em um, atingindo o caso base quando se iguala a 0. Então são feitas <code>O(n)</code> chamadas. Quando avaliamos complexidade de memória de funções recursivas, temos que levar em conta a pilha de execução também. São empilhadas n chamadas na pilha, então a complexidade de memória é <code>O(n)</code>.</p><h2 id=exponenciação-rápida>Exponenciação rápida</h2><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fast_exp</span>(<span style=color:#66d9ef>int</span> base, <span style=color:#66d9ef>int</span> e){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(e <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(e <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> base <span style=color:#f92672>*</span> fast_exp(base <span style=color:#f92672>*</span> base,e<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> fast_exp(base <span style=color:#f92672>*</span> base, e<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essa é uma função que também computa uma exponenciação. É um bom exemplo de como problemas abordados de forma diferente ou usando propriedades matemáticas podem ser resolvidos de forma mas eficiente. Em cada chamada na recursão, o expoente é dividido por 2, atingindo o caso base quando se iguala a 0. É fácil ver que o número <code>2^k</code> levaria <code>k</code> chamadas para atingir o caso base, isso ocorre porque <code>log2 (2^k) = k</code>, então a complexidade é <code>O(log N)</code>. A complexidade de memória é justificada da mesma forma que no caso anterior, a memória utilizada será o número de chamadas recursivas, então, <code>O(log n)</code>.</p><h2 id=fibonacci>Fibonacci</h2><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>fibonacci</span>(<span style=color:#66d9ef>int</span> n){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fibonacci(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> fibonacci(n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A famosa função de fibonacci. Essa função recursiva é bem bonita de se ver declarada, mas não é nada eficiente.</p><p>Pense que queremos Calcular Fibonacci(7)</p><p><img src=/images/fib.png alt=Fibonacci></p><p>Essa a árvore formada pelas chamadas recursivas, olhe quantas vezes recomputamos as mesmas coisas. A complexidade dessa função é <code>O(2^n)</code>, pois para cada chamada de fibonacci recursiva, fazemos outras duas, e acabamos recomputando várias vezes as mesmas coisas. Implemente essa função em sua máquina e faça uma chamada de fibonacci(40), já deve ser possível sentir o tempo que o programa leva para processar isso.</p><p>A complexidade de memória dessa função pode ser um pouco mais complicada de analisar vamos por partes. No total, serão feitos <code>O(2^n)</code> chamadas recursivas, e todas elas precisaram de um espaço na pilha de execução, no entanto, as <code>2^n</code> chamadas não coexistirão na pilha de execução. Olhando bem atentamente e seguindo o fluxo das chamadas recursivas, é possível ver que no máximo um &lsquo;ramo&rsquo; da árvore estará na pilha por vez, o ramo mais longo tem comprimento <code>n</code> portanto, complexidade de memória <code>O(n)</code>.</p><h2 id=videoaulas-complementares>VideoAulas Complementares</h2><hr><p><a href="https://www.youtube.com/watch?v=YoZPTyGL2IQ">https://www.youtube.com/watch?v=YoZPTyGL2IQ</a> (12 min.)</p><p><a href="https://www.youtube.com/watch?v=moPtwq_cVH8">https://www.youtube.com/watch?v=moPtwq_cVH8</a> (51 min. MIT)</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 2</div><h1>Entrada/Saída</h1><h2 id=entrada>Entrada</h2><p>O objeto &ldquo;cin&rdquo; representa o stream de entrada no C++. Ele realiza a leitura de um sequência de dados, sem espaços e sem tabulações, vindas do teclado.
Para coletar estes dados armazenados, usa-se o &ldquo;operador de extração&rdquo; que &ldquo;extrai&rdquo; dados do stream.</p><h3 id=lendo-um-input>Lendo um Input</h3><p>A primeira linha terá N que é a quantidade de números a serem lidos.</p><p>A segunda linha será os N números.</p><pre tabindex=0><code>input:
4
1 5 2 3
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    cin<span style=color:#f92672>&gt;&gt;</span>n;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numero;
</span></span><span style=display:flex><span>        cin<span style=color:#f92672>&gt;&gt;</span>numero;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=saída>Saída</h2><p>O objeto &ldquo;cout&rdquo; representa o stream de saída no C++. Este stream é uma espécie de sequência (fluxo) de dados a serem impressos na tela.
Para realizar a impressão, usa-se o &ldquo;operador de inserção&rdquo; que &ldquo;insere&rdquo; dados dentro do stream.</p><p>Printando o famoso &ldquo;Hello World&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Hello World&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informação</div><div class=box-content><p>O &ldquo;endl&rdquo; é usado para fazer quebra de linha, porém, pode ser mais lento que o &ldquo;\n&rdquo;.</p></div></div><h3 id=casas-decimais>Casas Decimais</h3><p>Para printar as casas decimais, precisamos usar o &ldquo;fixed&rdquo; que é uma função do C++ usada para formatar a saída, juntamente com o &ldquo;setprecision&rdquo;, que diz quantas casas será printada.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> pi <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.141592653</span>;
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>fixed;
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>setprecision(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>pi<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3.1415
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=fast-cin>Fast Cin</h2><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informação</div><div class=box-content><p>O <strong>printf</strong> e o <strong>scanf</strong> do C são mais rápidos do que o <strong>cin</strong> e o <strong>cout</strong> do C++.</p></div></div><p>Isso ocorre porque o C++ usa a sincronização do output, ou seja, enquanto ele está lendo o input, o programa pode responder ao mesmo tempo.</p><p>A resolução para que o cin e o cout fique mais rápido (próximo à velocidade do scanf e do printf), é desabilitar a sincronização no C++.</p><p>Segue o exemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>ios_base<span style=color:#f92672>::</span>sync_with_stdio(false);
</span></span><span style=display:flex><span>cin.tie(NULL);
</span></span></code></pre></div><h2 id=exemplo>Exemplo</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    ios_base<span style=color:#f92672>::</span>sync_with_stdio(false);
</span></span><span style=display:flex><span>    cin.tie(NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=default dir=ltr><h1>Declarações</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/declaracoes/string/>Strings</a></li><li><a href=/materiais/fundamentos/declaracoes/vector/>Vector</a></li><li><a href=/materiais/fundamentos/declaracoes/pair/>Pairs</a></li><li><a href=/materiais/fundamentos/declaracoes/iterators/>Iterators</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Declarações</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 3</div><h1>Strings</h1><p>No C++ representa uma sequência de caracteres</p><p>Podemos declarar uma string como:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>string nomevar;
</span></span><span style=display:flex><span>string nomevar <span style=color:#f92672>=</span> constante;
</span></span><span style=display:flex><span>string nomevar <span style=color:#f92672>=</span> <span style=color:#66d9ef>char</span> <span style=color:#960050;background-color:#1e0010>∗</span> variavel;
</span></span><span style=display:flex><span>string <span style=color:#a6e22e>nomevar</span>(<span style=color:#66d9ef>char</span> <span style=color:#960050;background-color:#1e0010>∗</span> variavel);
</span></span><span style=display:flex><span>string <span style=color:#a6e22e>nomevar</span>(tamanho, constante <span style=color:#66d9ef>char</span>);
</span></span></code></pre></div><h2 id=concatenação>Concatenação</h2><p>Podemos usar o operador &ldquo;+&rdquo; para concatenar duas strings</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    string a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abc&#34;</span>;
</span></span><span style=display:flex><span>    string b <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;def&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    string c <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>c<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// abcdef
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=transformando-um-inteiro-em-string>Transformando um inteiro em string</h2><p>Podemos transformar um inteiro em uma string usando a função &ldquo;to_string()&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>;
</span></span><span style=display:flex><span>    string s <span style=color:#f92672>=</span> to_string(x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span>s<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 4</div><h1>Vector</h1><p><strong>Vector</strong> pode ser entendido como uma estruturas de dados
similar a um <strong>array</strong> de tamanho expansível.</p><p>A diferença principal entre vector e array é a alocação:
no array adota-se alocação estática, enquanto que no
vector a alocaçãao é dinâmica.</p><h2 id=inicializar>Inicializar</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// inicializando vetores vazios
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> vd;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;&gt;</span> vid;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> vs;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// vector&lt;int&gt; v(tamanho, valor)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// {0, 0, 0, 0} vetor de 4 posições com valor 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(<span style=color:#ae81ff>4</span>); <span style=color:#75715e>// {0, 0, 0, 0} por default, inicializa como 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    v.push_back(<span style=color:#ae81ff>5</span>); <span style=color:#75715e>// Adiciona o elemento 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {0, 0, 0, 0, 5}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    v.pop_back();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {0, 0, 0, 0}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=iterar>Iterar</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// printa um elemento em cada linha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>v.size(); i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> v[i] <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informação</div><div class=box-content><p>O método size() retorna a quantidade de elementos
existentes em um vector.
Complexidade: O(1)</p></div></div><h2 id=ordenar>Ordenar</h2><div class="box notices cstyle secondary"><div class=box-label><i class="fa-fw fas fa-stopwatch"></i> Complexidade</div><div class=box-content><p><em>O(N*log(N))</em></p></div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sort(v.begin(), v.end()); <span style=color:#75715e>// ordena o vetor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {1, 2, 3, 4, 5}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=inverter>Inverter</h2><div class="box notices cstyle secondary"><div class=box-label><i class="fa-fw fas fa-stopwatch"></i> Complexidade</div><div class=box-content><p><em>O(N)</em></p></div></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    reverse(v.begin(), v.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v = {5, 4, 3, 2, 1}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=vector-de-pair>Vector de Pair</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> v <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}, {<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}, {<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// v[0].first = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// v[0].second = 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 5</div><h1>Pairs</h1><p>O pair é muito importante quando precisamos guardar duas informações juntas.</p><ul><li><p>Um &ldquo;pair&rdquo; é um contêiner que consiste de dois tipos de dados ou objetos.</p></li><li><p>Declaramos um pair como:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span>tipodado1, tipodado2<span style=color:#f92672>&gt;</span> variavel;
</span></span></code></pre></div><p>Podemos inicializá-lo usando o make_pair ou diretamente:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>variavel <span style=color:#f92672>=</span> make_pair(dado1, dado2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>variavel <span style=color:#f92672>=</span> {dado1, dado2};
</span></span></code></pre></div><ul><li>O primeiro elemento é acessado usando o &ldquo;first&rdquo; e o segundo usando &ldquo;second&rdquo;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>variavel.first;
</span></span><span style=display:flex><span>variavel.second;
</span></span></code></pre></div><h2 id=exemplo-1>Exemplo 1:</h2><ul><li>Um Pair que armazena 2 inteiros</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pii;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pii <span style=color:#f92672>=</span> {<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>10</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> pii.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pii.second<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=exemplo-2>Exemplo 2:</h2><ul><li>Um Pair que armazena 1 inteiro e 1 double</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> pii;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pii <span style=color:#f92672>=</span> {<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1.5365</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> pii.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pii.second<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2 1.5365
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=comparando-variáveis>Comparando Variáveis:</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1, v2;
</span></span><span style=display:flex><span>    v1 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>    v2 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(v1 <span style=color:#f92672>&gt;</span> v2) cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;v1 é maior que v2&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;v1 é menor ou igual a v2&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 6</div><h1>Iterators</h1><p>Iterators são tipos específicos de ponteiros que referenciam
endereçoos de memória de objetos e contêiners STL.</p><h2 id=exemplo-1>Exemplo 1</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator ptr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Elementos do Vetor&#34;</span><span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(ptr <span style=color:#f92672>=</span> v.begin(); ptr <span style=color:#f92672>!=</span> v.end(); ptr<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>(<span style=color:#f92672>*</span>ptr)<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Dica</div><div class=box-content><p>Você pode usar o <strong>auto</strong> no lugar de <code>vector&lt;int>::iterator</code>, para facilitar</p></div></div><h2 id=exemplo-2>Exemplo 2</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ar <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Declaring iterators to a vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator ptr <span style=color:#f92672>=</span> ar.begin();
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator ftr <span style=color:#f92672>=</span> ar.end();
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Using next() to return new iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// points to 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> next(ptr, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Using prev() to return new iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// points to 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> it1 <span style=color:#f92672>=</span> prev(ftr, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Displaying iterator position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;The position of new iterator using next() is : &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>it <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Displaying iterator position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;The position of new iterator using prev()  is : &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>it1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The position of new iterator using next() is : 4 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// The position of new iterator using prev()  is : 3 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Estrutura de Dados</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/eds/ed_linear/>ED Linear</a></li><li><a href=/materiais/fundamentos/eds/ed_n_linear/>ED Não Linear</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Estrutura de Dados</h1><article class=default dir=ltr><h1>ED Linear</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/eds/ed_linear/pilha/>Pilha</a></li><li><a href=/materiais/fundamentos/eds/ed_linear/fila/>Fila</a></li><li><a href=/materiais/fundamentos/eds/ed_linear/fila_prioridade/>Fila de Prioridade</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de ED Linear</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 7</div><h1>Pilha</h1><p>A <strong>pilha</strong> é uma estrutura que, como o nome sugere, permite inserção e remoção apenas do &ldquo;topo&rdquo;. Isto significa que, ao remover um elemento da pilha, o elemento a ser removido é o último que foi inserido. Também é conhecido como <em><strong>LIFO (last-in first-out)</strong></em>.</p><p><img src=/images/pilha.png alt=Pilha></p><h2 id=métodos>Métodos:</h2><ul><li><code>push</code> - Insere um elemento na pilha.</li><li><code>pop</code> - Remove o elemento do topo da pilha.</li><li><code>top</code> - Retorna o elemento do topo da pilha.</li><li><code>size</code> - Retorna o tamanho da pilha.</li><li><code>empty</code> - Retorna true se estiver vazia, se não, retorna falso.</li></ul><h2 id=exemplo>Exemplo</h2><ul><li>Programa simples que vai inserir elementos na pilha e depois conforme for removendo, printa cada elemento</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pilha; <span style=color:#75715e>// construtor, entre &lt;&gt; deve ser inserido o tipo de dado que será armazenado
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pilha.push(<span style=color:#ae81ff>2</span>); <span style=color:#75715e>// o metodo push insere o elemento no topo da pilha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pilha.push(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>    pilha.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    pilha.push(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> pilha.size() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// tamanho da pilha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// enquanto não estiver vazia, remove o elemento do topo e printa ele
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>pilha.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> pilha.top();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pilha.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Saída</p><pre tabindex=0><code>4 8 7 2
</code></pre><h1 id=pilha-de-mínimo>Pilha de Mínimo</h1><p>E se quisermos o seguinte problema:</p><ul><li>Dado N números em uma pilha, para os últimos Q números na pilha, printe o menor número em toda pilha até então.</li></ul><p>Podemos fazer um código que para cada Q últimos números na pilha, podemos ir percorrendo toda a pilha restante, salvando os menores, sem alterar a pilha atual.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    st.push(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st_aux;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// para os 4 últimos números, printe o menor número de toda a pilha até ele
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> q<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; q<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span>; q<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// menor = infinito
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> menor <span style=color:#f92672>=</span> LLINF;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// empilha na stack auxiliar
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>st.empty()){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> st.top();
</span></span><span style=display:flex><span>            menor <span style=color:#f92672>=</span> min(x, menor);
</span></span><span style=display:flex><span>            st.pop();
</span></span><span style=display:flex><span>            st_aux.push(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>menor<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// desempilha na stack original
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>st_aux.empty()){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> st_aux.top();
</span></span><span style=display:flex><span>            st_aux.pop();
</span></span><span style=display:flex><span>            st.push(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>st.empty()){
</span></span><span style=display:flex><span>          st.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Porém, é claro, a complexidade do código não é boa. ficaria aproximadamente <em>O(Q*N)</em>, se o Q e o N forem grandes, certamente levaríamos TLE (Time Limit Exceeded).</p><p><em><em>A solução para esse problema então, seríamos usar a pilha de mínimo.</em></em></p><h2 id=como-funciona>Como funciona?</h2><p>A pilha de mínimo usa um valor auxiliar para armazenar o menor elemento até a inserção atual, podemos usar um <code>stack&lt;pair&lt;int,int>></code> ou duas <code>stack&lt;int></code>.</p><p>O algoritmo então inicia a inserção de N elementos, e para cada inserção de elemento, vamos verificar se o elemento da stack auxiliar é menor ou maior que o da original, e guardaremos o de menor valor na stack auxiliar.</p><p><img src=/images/min-stack.gif alt=Pilha-Min></p><h2 id=implementação>Implementação</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n; cin<span style=color:#f92672>&gt;&gt;</span>n;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// recebemos n números
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> num;
</span></span><span style=display:flex><span>      cin<span style=color:#f92672>&gt;&gt;</span>num;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(st.empty()){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// num sera o menor valor da pilha.second
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        st.push({num,num});
</span></span><span style=display:flex><span>      }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        <span style=color:#75715e>// armazenamos o menor valor entre 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// o que esta na pilha.second e o num atual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> menor <span style=color:#f92672>=</span> st.top().second;
</span></span><span style=display:flex><span>        menor <span style=color:#f92672>=</span> min(menor, num);
</span></span><span style=display:flex><span>        st.push({num, menor});
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Para Q consultas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> q; cin<span style=color:#f92672>&gt;&gt;</span>q;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>st.empty()){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pega o menor valor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> st.top().second;
</span></span><span style=display:flex><span>        st.pop();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>val<span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>E a complexidade fica somente O(N+Q), pois agora conseguimos responder em O(1) cada query.</p><p>Referências:</p><ul><li><p><a href="https://youtu.be/lFghsipaZhc?t=4593">https://youtu.be/lFghsipaZhc?t=4593</a> (Aula muito boa)</p></li><li><p><a href=https://cp-algorithms.com/data_structures/stack_queue_modification.html>https://cp-algorithms.com/data_structures/stack_queue_modification.html</a></p></li></ul><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 8</div><h1>Fila</h1><p>A <strong>fila</strong> segue o padrão de <em><strong>FIFO (first-in first-out)</strong></em>, ao contrário da pilha, o primeiro elemento inserido será o primeiro a ser removido. Ela é muito útil para problemas que precisamos manter os elementos na ordem em que lhes foram dados.</p><p><img src=/images/fila.png alt=Fila></p><h2 id=métodos>Métodos</h2><ul><li><code>push</code> - Adiciona um elemento no fim da fila.</li><li><code>front</code> - Retorna o elemento do início da fila.</li><li><code>back</code> - Retorna o elemento do final da fila.</li><li><code>pop</code> - Remove o elemento do início da fila.</li><li><code>empty</code> - Retorna true se estiver vazia, e false caso contrário.</li><li><code>size</code> - Retorna quantos elementos tem na fila.</li></ul><h2 id=exemplo>Exemplo</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> q.size() <span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Saída</p><pre tabindex=0><code>9 5 6 1 8
</code></pre><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 9</div><h1>Fila de Prioridade</h1><p>Uma <strong>fila de prioridade</strong> tem como principal característica a <em>ordenação</em>, ela mantém o elemento do topo como sempre sendo o maior (ou o menor) elemento sempre.</p><p>Caso esteja fixado para o elemento do topo ser o maior, a fila de prioridade estará em ordem descrescente do topo para baixo. Caso contrário, a ordem será crescente.</p><p>Por padrão, ela estará fixado para o elemento do topo ser o maior, logo, estará em ordem decrescente os elementos na fila de prioridade.</p><p>As filas de prioridades são muito úteis quando precisamos que nossos elementos sempre estejam ordenados conforme vamos inserindo elementos.</p><h2 id=métodos>Métodos</h2><ul><li><code>push</code> - Adiciona um elemento na fila de prioridade.</li><li><code>pop</code> - Remove o elemento do topo da fila de prioridade.</li><li><code>top</code> - Retorna o valor do topo</li><li><code>empty</code> - Retorna true se a fila estiver vazia, caso contrário, retorna false</li><li><code>size</code> - Retorna o tamanho da fila de prioridade.</li></ul><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informação</div><div class=box-content><p>A complexidade de inserção e remoção é O(log(n)), e a de olhar o topo do heap é O(1).</p></div></div><h2 id=exemplo>Exemplo</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> q.size() <span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> q.top();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Saída</p><pre tabindex=0><code>9 8 6 5 1
</code></pre><h2 id=ordenação-pelo-menor-valor>Ordenação pelo menor valor</h2><p>Para ordenar pelo menor valor usamos a seguinte sintaxe na declaração:
<code>priority_queue &lt;int, vector&lt;int>, greater&lt;int>> q</code></p><h2 id=exemplo-2>Exemplo 2</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    priority_queue <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    q.push(<span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cout<span style=color:#f92672>&lt;&lt;</span> q.size() <span style=color:#f92672>&lt;&lt;</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> elemento <span style=color:#f92672>=</span> q.top();
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span>elemento<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Saída</p><pre tabindex=0><code>1 5 6 8 9
</code></pre><footer class=footline></footer></article></section><article class=default dir=ltr><h1>ED Não Linear</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/fundamentos/eds/ed_n_linear/map/>Map</a></li><li><a href=/materiais/fundamentos/eds/ed_n_linear/set/>Set</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de ED Não Linear</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 10</div><h1>Map</h1><p>O <strong>map</strong> é uma estrutura interessante pois permite <em>&ldquo;mapear&rdquo;</em> chaves à valores, e dado uma chave encontrar o seu valor rapidamente (complexidade depende da implementação). Por exemplo, podemos fazer um map com strings de chave e int de valor, sendo possível recuperar o valor inteiro associado a aquela string rapidamente.</p><p>Deve-se ter cuidado com o uso de map pois ele é implementado em c++ como um set de pairs, isto é, vai ter complexidade <em>O(log n)</em> para inserir e modificar dados.</p><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informação</div><div class=box-content><p>Existe também o <strong>unordered_map</strong>, que é uma estrutura que usa hash. No pior caso é linear, mas em média tem complexidade constante. O seu funcionamento é similar ao do map, com a diferença de que seus elementos não estão ordenados.</p></div></div><h2 id=métodos>Métodos</h2><ul><li><code>insert({key, element})</code> - Insere uma chave e um valor no map</li><li><code>erase()</code> - Remove uma key ou um iterator</li><li><code>find(element)</code> - Retorna um iterator da posição do element</li><li><code>count</code> - Retorna a quantidade de elementos de uma chave específica</li><li><code>size</code> - Retorna o tamanho do map</li><li><code>clear</code> - Limpa todo o conteúdo do Map</li><li><code>begin</code> - Retorna um iterator para o início do map</li><li><code>end</code> - Retorna um iterator para o final do map</li></ul><h2 id=inicialização>Inicialização</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// map chave, valor de inteiros
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m; <span style=color:#75715e>// Inicialização de map vazio
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}}; <span style=color:#75715e>// Inicialização de map com valor 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    m[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    m[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>++</span>; <span style=color:#75715e>// 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=iteração>Iteração</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iterando por métodos iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Printa a chave e o valor em cada linha
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> m.begin(); it <span style=color:#f92672>!=</span> m.end(); it<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> it.first <span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>&lt;&lt;</span> it.second<span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// tambem pode ser escrito como:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it: m){
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> it.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>&lt;&lt;</span> it.second<span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Saída</p><pre tabindex=0><code>2 3
4 6
</code></pre><h2 id=apagando-elemento>Apagando elemento</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iterando por métodos iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    m.erase(m.find(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    m.erase(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informação</div><div class=box-content><p>Da primeira maneira, ele apaga em tempo constante, pois está passando um iterator.
Da segunda maneira, ele apaga em log(N), pois ele faz uma busca no elemento.</p></div></div><h2 id=verificar-um-elemento>Verificar um elemento</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// iterando por métodos iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}, {<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>( m.count(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> ){ <span style=color:#75715e>// existe uma chave {2}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Elemento existe&#34;</span>;
</span></span><span style=display:flex><span>    }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        cout<span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Elemento não existe&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Saída</p><pre tabindex=0><code>Elemento existe
</code></pre><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 11</div><h1>Set</h1><p>A estrutura <strong>set</strong> é bem parecida com o que conhecemos de conjuntos da matemática; não existem elementos repetidos e a ordem não importa.</p><p>A implementação do set, porém, é feita com uma árvore binária de busca, sendo assim permitido inserir, remover e acessar um elemento em <em>O(log n)</em>.</p><p>A vantagem do set em relação ao vector é que, caso queira inserir um elemento em um vector ordenado e preservar a ordenação, você terá que procurar o lugar que ele deve ser inserido, fazer a inserção e modificar a posição dos elementos à direita dele. Modificar todas as posições à direita tem uma complexidade ruim <em>O(n)</em>, então este algoritmo será mais eficiente com o set.</p><p>Além da vantagem de eficiência, essas operações com set são feitas com alguns simples métodos!</p><h2 id=métodos>Métodos</h2><ul><li><code>insert(element)</code> - Insere um elemento no Set</li><li><code>erase()</code> - Remove uma key ou um iterator</li><li><code>find(element)</code> - Retorna um iterator da posição do element</li><li><code>count</code> - Retorna a quantidade de elementos de uma chave específica</li><li><code>size</code> - Retorna o tamanho do set</li><li><code>clear</code> - Limpa todo o conteúdo do set</li><li><code>begin</code> - Retorna um iterator para o início do set</li><li><code>end</code> - Retorna um iterator para o final do set</li><li><code>lower_bound(element)</code> - Retorna um iterator para o primeiro valor >= element</li><li><code>upper_bound(element)</code> - Retorna um iterator para o primeiro valor > element</li></ul><h2 id=exemplo-1>Exemplo 1</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// insere elemento no set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> s.size() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// tamanho do set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// para verificar se um elemento está contido no set ou nao podemos utilizar
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// o metodo find; caso nao esteja presente ele retornará o iterator para
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// o fim do set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(s.find(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 2 nao esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 2 esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(s.find(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 nao esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    s.erase(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// apaga elemento 3 do set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(s.find(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 nao esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;O numero 3 esta no set&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Outro método extremamente útil é o lower_bound (e o upper_bound). O lower_bound recebe um inteiro x como argumento e retorna o menor inteiro maior ou igual a x. Caso não exista, ele retorna um iterator para o fim do set (set.end()).</p><h2 id=exemplo-2>Exemplo 2</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>3</span>); <span style=color:#75715e>// insere elemento no set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s.insert(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    s.insert(<span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> iterator1 <span style=color:#f92672>=</span> s.lower_bound(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// se iterator eh igual a s.end() entao nao existe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(iterator1 <span style=color:#f92672>!=</span> s.end()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numero <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>iterator1;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;menor inteiro maior ou igual a 6 eh &#34;</span> <span style=color:#f92672>&lt;&lt;</span> numero <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;nao existe inteiro numero maior ou igual a 6&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> iterator2 <span style=color:#f92672>=</span> s.lower_bound(<span style=color:#ae81ff>9</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// se iterator eh igual a s.end() entao nao existe
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(iterator2 <span style=color:#f92672>!=</span> s.end()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numero <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>iterator2;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;menor inteiro maior ou igual a 9 eh &#34;</span> <span style=color:#f92672>&lt;&lt;</span> numero <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;nao existe inteiro numero maior ou igual a 9&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Informação</div><div class=box-content><p>Na verdade, você pode utilizar o lower_bound para qualquer tipo que implemente a operação &ldquo;&lt;&rdquo;, como por exemplo o pair&lt;int, int>.</p></div></div><footer class=footline></footer></article></section></section></section><article class=default dir=ltr><h1>Estruturas de Dados</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Estruturas de Dados</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 12</div><h1>Delta Encoding</h1><h2 id=problemas-de-atualização-em-intervalos>Problemas de atualização em intervalos</h2><p>Suponha que você se depare com um problema do seguinte tipo:</p><p>Você recebe um vetor <code>v</code> , inicialmente com todos seus números zerados, e <code>q</code> queries. cada query virá representada por 3 inteiros (l,r,x). Ao receber cada query, a mudança esperada é: &ldquo;Para cada número no vetor, seja <code>i</code> o seu índice. Se <code>l &lt;= i &lt;= r</code>, v[i] deve ter x adicionado ao seu valor. Ao final do programa, deve-se imprimir o vetor todo com seus valores atualizados.</p><p>A primeira solução que já vem a cabeça é a seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n,q;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>,<span style=color:#f92672>&amp;</span>n,<span style=color:#f92672>&amp;</span>q);
</span></span><span style=display:flex><span>vi <span style=color:#a6e22e>v</span>(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; <span style=color:#f92672>++</span>i){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l,r,x;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r,<span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> l; j <span style=color:#f92672>&lt;=</span> r; <span style=color:#f92672>++</span>j){
</span></span><span style=display:flex><span>        v[j] <span style=color:#f92672>+=</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nessa solução, para cada uma das <code>q</code> queries, o pior caso seria <code>l = 0</code> e <code>r = n-1</code>, que faz o laço interno iterar <code>n</code> vezes, o que nos dá uma complexidade <code>O(n*q)</code>. Precisamos ser mais rápidos.</p><h2 id=definição>Definição</h2><p>Delta encoding é uma técnica para resolver problemas desse tipo. Precisamos fazer atualizações em intervalos, mas como o vetor só precisa ser visualizado no final, o que fazemos é fazer todas de uma vez só no final. A ideia por trás dessa solução funciona da seguinte forma: Vamos criar um vetor auxiliar <code>delta</code>, que é o vetor que vai acumular as atualizações.</p><h2 id=atualização-do-intervalo-lr>Atualização do intervalo (l,r)</h2><p>Dessa forma, quando estivermos lendo uma query (l,r,x), faremos o seguinte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> delta(n,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l,r,x;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r,<span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>    delta[l] <span style=color:#f92672>+=</span> x;
</span></span><span style=display:flex><span>    delta[r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-=</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O trecho de código acima é o delta encoding por si só, o nome é esse porque estamos codificando a informação de que precisamos atualizar aquele intervalo. A parte interessante, é que nesse laço, nossa atualização funciona em <code>O(1)</code>.</p><h2 id=obtendo-os-valores-após-várias-atualizações>Obtendo os valores após várias atualizações</h2><p>Tendo as informações organizadas dessa forma, isso nos permite percorrer o vetor <code>delta</code> da esquerda pra direita obtendo os valores finais do vetor, em <code>O(n)</code>.</p><p>Isso é feito criando uma variável <code>atual</code>, inicializada com 0. Então, enquanto percorremos o vetor, na i-ésima iteração, sempre somamos a essa variável <code>delta[i]</code>, após isso, a configuração final de <code>v[i]</code> será o valor de <code>atual</code>.</p><p>Então, é por esse motivo que guardamos a informação daquela forma no vetor. Como vamos percorrer da esquerda pra direita, quando fazemos <code>v[l] += x</code>, estamos dizendo, quando você passar no índice <code>l</code>, você deve adicionar mais <code>x</code> a resposta. E quando fazemos <code>v[r+1] -= x</code>, dizemos: quando seu índice for maior que <code>r</code>, pare de considerar x no resultado.</p><p>Dessa forma, a versão final:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> delta(n<span style=color:#f92672>+</span><span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l,r,x;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r,<span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>    delta[l] <span style=color:#f92672>+=</span> x;
</span></span><span style=display:flex><span>    delta[r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-=</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> atual <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    atual <span style=color:#f92672>+=</span> delta[i];
</span></span><span style=display:flex><span>    v[i] <span style=color:#f92672>=</span> atual;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d &#34;</span>,v[i]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span></code></pre></div><h2 id=ressalvas>Ressalvas</h2><p>Análogo as somas prefixas, mas de forma inversa, essa ED processa atualizações em intervalo muito rapidamente <code>O(1)</code>, porém, quando é necessário saber os valores do vetor, e há atualizações pendentes, é necessário percorrer novamente o vetor todo <code>O(n)</code>, então essa ED funciona melhor com muitas atualizações e poucas consultas.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 13</div><h1>Soma de Prefixos</h1><h2 id=problemas-de-consulta-em-intervalos>Problemas de consulta em intervalos</h2><p>Suponha que você se depare com o seguinte problema:</p><p>É dado um vetor V, com n números inteiros, em seguida, um número q de consultas que serão feitas nesse vetor. Cada consulta consiste de um par de inteiros (l,r), representando um intervalo, a resposta para cada consulta é a soma dos inteiros nesse intervalo(inclusivo).</p><p>Até agora, em qual complexidade sabemos resolver esse problema?</p><p>A solução simples seria:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> q;
</span></span><span style=display:flex><span>cin <span style=color:#f92672>&gt;&gt;</span> n;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(n);
</span></span><span style=display:flex><span><span style=color:#75715e>// leitura dos elementos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,v<span style=color:#f92672>+</span>i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>cin <span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span><span style=color:#75715e>// respondendo as consultas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l, r;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>,<span style=color:#f92672>&amp;</span>l,<span style=color:#f92672>&amp;</span>r);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> soma <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> l; j <span style=color:#f92672>&lt;=</span> r; j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        soma <span style=color:#f92672>+=</span> v[j];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> soma <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essa solução teria complexidade <code>O(q*n)</code> aonde <code>q</code> é o número de consultas, e <code>n</code> o tamanho do vetor.</p><h2 id=definição>Definição</h2><p>O vetor de somas prefixas é uma ED que podemos usar para resolver esse tipo de problema de forma mais eficiente. A ideia é construir um vetor P tal que <code>P[i]</code> representa a soma do índice 0 até o índice i.</p><p>Tendo essas informações, para responder uma consulta (l,r) podemos usar a seguinte ideia: sabe-se que em <code>P[r]</code> temos a resposta para a consulta (0,r), com isso, podemos agora subtrair a parte que não nos interessa, (0,l-1) ou <code>P[l-1]</code>.</p><h2 id=construção>Construção</h2><p>A construção do vetor de somas prefixas em <code>v</code> tem complexidade <code>O(n)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> psum(v.size(), v[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> v.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    psum[i] <span style=color:#f92672>=</span> v[i] <span style=color:#f92672>+</span> psum[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=resposta-de-consulta-lr>Resposta de consulta (l,r)</h2><p>A resposta às consultas tem complexidade constante, já que são só acessos ao vetor. Apenas tem-se que tomar cuidado quando <code>l = 0</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(l <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> psum[r];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> psum[r] <span style=color:#f92672>-</span> psum[l<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ressalvas>Ressalvas</h2><p>Vale lembrar que essa ED é mais interessante de ser usada quando não há (ou há poucas) atualizações nos valores do vetor, caso haja, é necessário recomputar as somas prefixas do vetor todo em <code>O(n)</code>, o que não é uma complexidade atrativa.</p><p>Além disso, esse raciocínio não precisa se extender apenas a somas, funciona para operações como xor, por exemplo.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 14</div><h1>Segment Trees</h1><p>Segment tree (Segtree) é outra estrutura de dados para lidar com problemas de consulta em intervalos. O que tornas as segtrees poderosas é sua capacidade de fazer atualização e consulta em intervalos em complexidade <code>O(log n)</code>, além do tipo da consulta ser bem abrangente.</p><p>A ideia é a seguinte: Criamos uma árvore, de forma que cada nodo representa a informação que desejamos saber a respeito de um segmento do vetor, e tem dois filhos, um filho representa a metade esquerda desse intervalo, e o outro, a metade direita. Esse processo recursa até que os intervalos atinjam tamanho 1.</p><p>Aqui há uma demonstação visual de como funciona: <a href=https://visualgo.net/en/segmenttree>https://visualgo.net/en/segmenttree</a></p><p>É interessante entender o funcionamento da segtree pois, por mais que tenhamos o código pronto, quando mudamos de operação ou precisamos inserir long longs, será necessário mexer na sua estrutura interna.</p><h2 id=representação>Representação</h2><p>Nossa segtree será representada como um vetor. Cada nodo terá um id nesse vetor, e o conteúdo dessa posição representa a informação que aquele nodo guarda. A raiz da segtree será o nodo 0, que guarda a informação sobre o vetor todo. A partir do índice <code>id</code> de um nodo, podemos obter os filhos sem colisões da seguinte forma: índice dos filhos esquerdo e direito são <code>(id*2 + 1,id*2 +2)</code>, respectivamente.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span></code></pre></div><h2 id=operação>Operação</h2><p>Essa função define que informação queremos saber a respeito dos elementos do vetor. Nese caso é uma segtree que computa o máximo de intervalos, mas poderia ser soma, mínimo, produto, xor, gcd, mmc(lcm), or e and lógicos etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(a,b);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=elemento-neutro>Elemento neutro</h2><p>O elemento neutro depende da operação. Como queremos saber os máximos, o elemento neutro dessa operação seria um número muito baixo, que nunca será o máximo.</p><p>Caso não saiba a definição de elemento neutro, a definição é a seguinte: <code>e</code> é um elemento neutro da operação f se <code>f(e,x) = x</code> para todo <code>x</code>.</p><p>Caso fosse uma soma, nosso elemento neutro seria 0, caso fosse um produto, seria 1, etc..</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>(<span style=color:#ae81ff>1e9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span></code></pre></div><h2 id=consulta>Consulta</h2><p>A função recursiva abaixo responde às consultas na segtree. Cada parâmetro tem o seguinte significado:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>l</code> : limite inferior do intervalo que queremos fazer a consulta</li><li><code>r</code> : limite superior do intervalo que queremos fazer a consulta</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//O nodo está fora do intervalo que estamos interessados, retorne o elemento neutro que não afeta a consulta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl) 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// O nodo está completamente incluído no intervalos que estamos interessados, retorne a informação contida naquele nodo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Se chegarmos aqui, é porque esse Nodo está parcialmente contido no intervalo que estamos interessados. Então, continuamos procurando nos filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=atualização>Atualização</h2><p>Essa função atualiza um elemento da segtree. Cada parâmetro tem o seguinte significado:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>i</code> : índice do <strong>vetor</strong> que queremos atualizar</li><li><code>amm</code>: novo valor daquele índice no vetor</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Chegamos no índice que queremos, vamos atualizar o valor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>==</span> i and str <span style=color:#f92672>==</span> i){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// O intervalo que estamos não contem o índice que queremos atualizar, retorne
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> i or str <span style=color:#f92672>&lt;</span> i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// O intervalo contém o índice, mas temos que chegar no nodo específico, recurse para os filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,i,amm);
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,i,amm);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Após os filhos mais em baixo, precisamos atualizar o valor desse nodo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=declaração>Declaração</h2><p>Essa é a classe com as funcionalidades implementadas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span>  <span style=color:#a6e22e>SegTree</span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>(<span style=color:#ae81ff>1e9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(a,b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>==</span> i and str <span style=color:#f92672>==</span> i){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>+=</span> amm;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> i or str <span style=color:#f92672>&lt;</span> i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,i,amm);
</span></span><span style=display:flex><span>        update(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,i,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){update(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,i,amm);}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=interface>Interface</h2><p>Os métodos que mostramos são todos internos da segtree, na hora de chama-los, não precisamos passar tantos parâmetros assim.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> amm){update(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,i,amm);}
</span></span></code></pre></div><h3 id=segtree>SegTree</h3><p>Construtor, recebe o tamanho do vetor.</p><h3 id=query>query</h3><p>Executa uma consulta, recebe o intervalo(l,r) da consulta, retorna o resultado.</p><h3 id=update>update</h3><p>Atualiza um índice no vetor recebe o índice e o novo valor.</p><h2 id=construção>Construção</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>SegTree <span style=color:#a6e22e>st</span>(v.size());
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span> v.size();i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    st.update(i,v[i]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=atualizações-em-intervalos>Atualizações em intervalos</h2><p>A segtree que temos até agora faz atualização de uma posição no vetor e consulta de qualquer em intervalo, em <code>O(log n)</code>. Mas e se precisarmos atualizar um intervalo, por exemplo: &ldquo;Todos os elementos da posição 1 até 10 recebem 2&rdquo;. Assim, a melhor forma que teríamos de fazer isso seria</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SegTree <span style=color:#a6e22e>st</span>(n);
</span></span><span style=display:flex><span><span style=color:#75715e>// preenche segtree
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> ; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>    st.update(i,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O que tem complexidade <code>O(n * log n)</code>. Precisamos fazer isso mais rápido.</p><h1 id=lazy-progapation>Lazy progapation</h1><p>Lazy propagation é uma alteração na segtree que nos permite fazer atualizações em intervalos em <code>O(log n)</code>.</p><h2 id=a-ideia>A ideia</h2><p>Em nossa abordagem anterior, o que tornava a execução lenta é que procurávamos o nodo responsável por cada elemento que precisava ser atualizado.</p><p>Para acelerar esse processo, podemos usar uma ideia parecida com a da consulta, em vez de atualizar individualmente os elementos, podemos atualizar a resposta nos intervalos que os contém, e postergar a atualização nos filhos.</p><p>Para implementar lazy propagation, cada configuração de segtree vai requerer uma implementação um pouco diferente, por isso, será necessário entender o que cada parte do código está fazendo.</p><p>O exemplo a seguir será de uma segtree de soma, aonde a atualização de intervalo vai setar todos os elementos para um qualquer.</p><h2 id=vetor-de-lazy>vetor de lazy</h2><p>A ideia é introduzir um vetor extra com o seguinte significado: Quando eu passar no nodo identificado por id, em uma consulta, ou outra atualização, preciso atualizar seu valor para <code>lazy[id]</code>. O vetor has indica se há uma atualização para ser feita naquele nodo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lazy;
</span></span><span style=display:flex><span>   vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> has;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> size;
</span></span></code></pre></div><h2 id=a-propagação>A propagação</h2><p>A função de propagação é a função que atualiza o valor de um nodo, e posterga a atualização para os filhos. Precisamos chamar essa função toda vez que passamos por algum nodo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>propagate</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str){
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Se há algo para atualizar, atualize()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>if</span>(has[sti])
</span></span><span style=display:flex><span>           <span style=color:#75715e>//O valor desse nodo da segtree será (número de elementos que esse intervalo representa vezes novo valor de cada elemento do intervalo)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           st[sti] <span style=color:#f92672>=</span> lazy[sti] <span style=color:#f92672>*</span> (str <span style=color:#f92672>-</span> stl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>           <span style=color:#75715e>// Se o nó representa um segmento de tamanho maior que 1, isto é, não é terminal, propague a atualização para os filhos.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>!=</span> str){
</span></span><span style=display:flex><span>               lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>               lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>               has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>               has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>           <span style=color:#75715e>// agora não é mais necessário atualizar esse nodo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           has[sti] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><h2 id=a-função-de-atualização-em-intervalo>A função de atualização em intervalo</h2><p>Essa é a função que realiza a atualização de intervalos. O significado dos argumentos é:</p><ul><li><code>sti</code>: id do nodo que estamos na segment tree</li><li><code>stl</code>: limite inferior do intervalo que aquele nodo representa(inclusivo)</li><li><code>str</code>: limite superior do intervalo que aquele nodo representa(inclusivo)</li><li><code>l</code>: limite inferior do intervalo que queremos atualizar no <strong>vetor</strong></li><li><code>r</code>: limite superior do intervalo que queremos atualizar no <strong>vetor</strong></li><li><code>amm</code>: novo valor dos elementos nesse intervalo</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l,<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r){
</span></span><span style=display:flex><span>            <span style=color:#75715e>// O valor que será atribuido a todo elemento no intervalo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            lazy[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            propagate(sti, stl, str);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> r  or str <span style=color:#f92672>&lt;</span> l)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r,amm);
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=versão-final>Versão final</h2><p>Essa é a versão final da nossa ED.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span>  <span style=color:#a6e22e>SegTree</span>{
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lazy;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> has;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> el_neutro <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>propagate</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(has[sti]){
</span></span><span style=display:flex><span>            st[sti] <span style=color:#f92672>=</span> lazy[sti] <span style=color:#f92672>*</span> (str <span style=color:#f92672>-</span> stl <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>!=</span> str){
</span></span><span style=display:flex><span>                lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>                lazy[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> lazy[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>                has[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>        propagate(sti, stl, str);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(str <span style=color:#f92672>&lt;</span> l <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> stl)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> el_neutro;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> st[sti];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (str<span style=color:#f92672>+</span>stl)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f(query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r),query(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> sti, <span style=color:#66d9ef>int</span> stl, <span style=color:#66d9ef>int</span> str, <span style=color:#66d9ef>int</span> l,<span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;=</span> l and str <span style=color:#f92672>&lt;=</span> r){
</span></span><span style=display:flex><span>            lazy[sti] <span style=color:#f92672>=</span> amm;
</span></span><span style=display:flex><span>            has[sti] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            propagate(sti, stl, str);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(stl <span style=color:#f92672>&gt;</span> r  or str <span style=color:#f92672>&lt;</span> l)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (stl <span style=color:#f92672>+</span> str)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,stl,mid,l,r,amm);
</span></span><span style=display:flex><span>        update_range(sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>,mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,str,l,r,amm);
</span></span><span style=display:flex><span>        st[sti] <span style=color:#f92672>=</span> f(st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>],st[sti<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> n)<span style=color:#f92672>:</span>  st(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>), lazy(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,<span style=color:#ae81ff>0</span>),has(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>n,false){size <span style=color:#f92672>=</span> n;}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span>  r){<span style=color:#66d9ef>return</span> query(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r);}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update_range</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> amm){update_range(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,l,r,amm);}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=problemas-recomendados>Problemas recomendados</h2><ul><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2531>Compras em FdI</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1301>Produto do Intervalo</a></li><li><a href=https://codeforces.com/contest/1234/problem/D>Distinct Characthers</a></li><li><a href=https://codeforces.com/contest/830/problem/B>Cards Sorting</a></li><li><a href=https://codeforces.com/contest/474/problem/F>Ant Colony</a></li><li><a href=https://codeforces.com/contest/339/problem/D>Xenia and Bit Operations</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1500>Consultas Horríveis</a></li><li><a href=https://codeforces.com/contest/920/problem/F>SUM and REPLACE</a></li><li><a href=https://codeforces.com/contest/380/problem/C>Sereja and Brackets</a></li><li><a href=https://www.spoj.com/problems/KQUERY/>Kquery</a></li><li><a href=https://www.spoj.com/problems/DQUERY/>DQuery</a></li></ul><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 15</div><h1>Sparse Table</h1><p>Nesse tutorial vamos falar sobre uma estrutura de dados chamada Sparse Table, que é uma estrutura de dados poderosa para resolvermos range queries de algumas operações específicas em complexidades superiores as de uma Segment Tree por exemplo.</p><p>Por exemplo, uma Sparse Table conseque resolver range minimum(ou maximum) query em <code>O(1)</code>, enquanto numa segment tree precisaríamos de <code>O(log n)</code>. Outro exemplo poderia ser range query de gcd, numa Segment Tree podemos resolver range queries de GCD em <code>O(log^2 n)</code>, já na sparse table conseguimos isso em <code>O(log n)</code>. No geral, quando a operação da range query tem uma propriedade chamada idempotência, podemos tirar um log da complexidade usando a Sparse Table.</p><h2 id=idempotência>Idempotência</h2><p>A propriedade que uma operação precisa ter para que possamos ganhar tempo de execução usando a Sparse Table é a idempotência. Na definição que estamos levando em consideração, uma operação <code>op</code> (binária) é idempotente quando para todo <code>x</code> e todo <code>y</code>, <code>op(x,y) = op(x,op(x,y))</code>. Poderíamos dar uma definição mais precisa porém o que precisamos saber é que numa operação idempotente, aplicar a operação uma vez é o mesmo que aplicar 2,3,4,&mldr; qualquer número de vezes maior que 0.</p><p>A operação min possui essa propriedade, para qualquer <code>x,y</code>, <code>min(x,y) = min(x,min(x,y))</code>. Outro exemplo é o próprio gcd como mencionado acima. para qualquer <code>x,y</code>, <code>gcd(x,y) = gcd(x,gcd(x,y))</code>.</p><p>Mas essa propriedade não é verdade para a operação de soma, por exemplo, seja <code>sum(x,y) = x + y</code>, <code>sum(3,4) != sum(3,sum(3,4))</code>, aplicar a operação mais de uma vez com os mesmos argumentos a direita(ou a esquerda) resulta num resultado diferente, então soma não é idempotente. Na verdade as operações mais comuns vão ser GCD e min/max, mas é importante saber a propriedade para entender porque a ideia que vamos usar funciona e também caso haja uma operação meio maluca que seja idempotente saber se consegue montar a Sparse table sobre ela.</p><h2 id=o-pulo-do-gato>O pulo do gato</h2><p>Imagine que tenhamos uma função <code>mágica</code>, chamada <code>dp(n,k)</code>, que retorna a operação aplicada no intervalo [n, n + (2^k) - 1].</p><pre tabindex=0><code>k = 0, [n, n]
k = 1, [n, n + 1]
k = 2, [n, n + 3]
k = 3, [n, n + 7]
.
.
</code></pre><p>Então se a operação for <code>min</code>, vai ser o mínimo dos elementos nesse intervalo, se for <code>gcd</code> vai ser o gcd entre todos os número desse intervalo etc. Certo então com essa função, vamos fingir que recebemos uma min query para o intervalo [4, 17] em um vetor.</p><p>Como a operação é idempotente, podemos fazer o seguinte. A resposta vai ser min(dp(4,3), dp(10,3)),</p><pre tabindex=0><code>[0, 1, 2, 3, (4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)]
[1, 3, 2, 5, (9, 6, 8, 0, 1, 2, 40, 51,  2,  4, 63, 20,  2,  4)]
</code></pre><p>O intervalo que estamos interessados está demarcado com um parêntese. Bem, dp(4, 3) = 0, e dp(10,3) = 2, e min(0,2) = 0, que realmente é o mínimo do intervalo. Se a query fosse no intervalo [4,10] poderíamos fazer <code>min(dp(4,2), dp(7,2))</code>, e assim por diante.</p><p>Então o que nós estamos fazendo aqui é selecionando uma potencia de dois e duas posições aonde duas chamadas a essa função mágica vão ser suficientes para cobrir exatamente o intervalo que estamos interessados. E a operação precisa ser idempotente porque como estamos selecionando apenas intervalos que tem tamanhos de potências de dois, no caso geral não conseguimos selecionar dois intervalos que não tenham interseção, e caso a operação não seja idempotente, isso fará com que a interseção seja contada duas vezes, fazendo então com que essa ideia não funcione. Voltaremos mais tarde na implementação de como selecionar essas potências.</p><p>Então a complexidade que temos até então para resolver consultas é a seguinte: <code>O(k + 2*q)</code> aonde <code>k</code> é o custo da operação, e <code>q</code> é o custo da nossa função <code>mágica</code>. Veremos que conseguimos com programação dinâmica precomputar os valores pra essa função fazendo com que as chamadas a ela tenham tempo constante. Como <code>min()</code> tem tempo constante de <code>gcd()</code> tempo <code>log</code>, é assim que resultamos nas complexidades mencionadas no começo do texto.</p><h2 id=recorrência>Recorrência</h2><p>Esta é a recorrência da programação dinâmica, nessa recorrência, estamos apenas dizendo o seguinte: O resultado da operação em um intervalo é o resultado da primeira metade combinado com o resultado da segunda metade.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dp</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> op(dp(i,k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),dp(i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)). k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=versão-recursiva>Versão recursiva</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> memo[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(SIZE);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dp</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>&gt;=</span> SIZE) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(memo[i][k] <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> memo[i][k];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memo[i][k] <span style=color:#f92672>=</span> min(dp(i,k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),dp(i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)), k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=versão-iterativa>Versão iterativa</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> memo[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(SIZE);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    memo[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> v[i];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> k <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&gt;=</span> SIZE) {
</span></span><span style=display:flex><span>            memo[i][k] <span style=color:#f92672>=</span> memo[i][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            memo[i][k] <span style=color:#f92672>=</span> op(memo[i][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], memo[i <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> (k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Precisamos apenas computar para potências até log2(SIZE) + 1 porque potências maiores que essa com certeza já são maiores que o vetor.</p><p>Outro detalhe de implementação é que temos que tomar cuidado para não acessar fora do vetor, algumas alternativas que temos podem ser por exemplo adicionar um <code>if(i >= SIZE) return 0;</code> na versão recusiva. Na versão iterativa fazemos de maneira análoga.</p><p>Estamos preenchendo uma tabela de tamanho <code>O(n log n)</code> aonde <code>n</code> é o tamanho da árvore, para preencher cada célula dessa tabela fazemos operações constantes e uma chamada a <code>op</code>, então a complexidade de montarmos essa tabela para responder as queries é <code>O(n log n * K)</code>, aonde K é a complexidade de <code>op</code>.</p><h2 id=ajustando-a-consulta>Ajustando a consulta</h2><p>Acima demos alguns exemplos de como podemos usar a recorrência que definimos para computar intervalos específicos, por exemplo para <code>[4,17]</code>, escolhemos <code>(4,3) e (10,7)</code>. O intervalo em questão tem tamanho 14, então a menor potência de 2 que podemos usar para cobri-lo é 8(2^3). Em geral essa menor potência pode ser calculada pela expressão <code>log2(b-a)</code>, aonde log2(x) é o chão do logaritmo de x na base 2 e assumimos que <code>b > a</code>.</p><pre tabindex=0><code>log2(13) = 3
log2(14) = 3
log2(15) = 3
log2(16) = 4
.
.
.
</code></pre><p>E sobre as posições da query, a primeira sempre será no começo do intervalo, e a segunda temos que ajustar de forma que o último elemento levado em consideração seja o último.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> lg <span style=color:#f92672>=</span> log2(b<span style=color:#f92672>-</span>a);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> F(tb[a][lg],tb[<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> b<span style=color:#f92672>-</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> lg)][lg])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=conteúdo-complementar>Conteúdo complementar</h1><p><a href="https://www.youtube.com/watch?v=EKcQt-74bNw">https://www.youtube.com/watch?v=EKcQt-74bNw</a></p><h1 id=exercícios-recomendados>Exercícios recomendados</h1><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Algoritmos</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/algoritmos/busca_binaria/>Busca Binária</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Algoritmos</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 16</div><h1>Busca Binária</h1><p>Busca binária é um algoritmo de divisão e conquista usado em sua maior parte para minimizar o tempo de uma busca linear. Na busca binária sempre estamos procurando o &ldquo;o maior <code>x</code> valor que satisfaz uma condição <code>c(x)</code>&rdquo; ou &ldquo;o menor <code>x</code> valor que satisfaz uma condição <code>c(x)</code>&rdquo;, retornaremos nesse ponto depois no texto.</p><p>Imagine você com um livro de 1000 páginas em mãos no momento em que o professor pede para que o abra no começo do capitulo 6 seção 4. Existem várias maneiras de se alcançar a página certa. Uma delas é ir de uma em uma até que se alcance a página desejada. Outra maneira é ir pulando alguns blocos de páginas, se você está numa página depois do começo do capitulo 6 seção 4 pula algumas páginas para tras, se você está numa página antes, pula algumas páginas para frente.</p><p>Perceba que no exemplo acima uma busca linear (passar de página em página) demoraria muito mais do que ir pulando algumas partes do livro. E fazendo da segunda maneira involuntariamente você acaba aplicando uma versão primitiva do que chamamos de busca binária.</p><h2 id=o-algortimo>O algortimo</h2><p>Usando a mesma ideia do livro porém agora em uma linguagem mais computacional. No lugar de 1000 páginas podemos ter um vetor de 1000 posições onde a i-ésima tem um pair &lt;capitulo, seção> da pagina i, por exemplo, se a página 125 faz parte do capítulo 4 seção 2 então <code>v[125] = make_pair(4, 2);</code>. E digamos que o capítulo 6 seção 4 está na página 375(que não sabemos no começo da busca).</p><p>Primeiro podemos, por exemplo, para a página 400. A partir do pair daquela posição aprendemos que o que procuramos está antes de 400, então agora não precisamos procurar a resposta no intervalo [1, 1000] e sim no intervalo [1, 399]. Podemos fazer um segundo chute na posicao 300, por exemplo pois podemos chutar em qualquer posição do intervalo, e depois de olhar v[300] aprendemos que a resposta está no intervalo [301, 399]. Podemos então chutar na página 375 e encontrar que esta é a resposta que procuramos.</p><p>O único problema do que foi descrito acima é determinar como chutar o elemento dentro do intervalo já que os chutes foram meio aleatórios. O primeiro chute foi no elemento 400 num intervalo [1, 1000], depois de olhar o elemento poderíamos passar a ter que olhar o intervalo [1, 399](se o que procuramos está antes) ou [401, 1000](se o que procuramos está depois), tivemos sorte e caimos no primeiro caso mas no pior caso poderíamos cair no intervalo maior. O jeito de garantirmos de no pior caso sempre irmos para um intervalo de menor tamanho possivel é chutar de uma forma a dividir o intervalo em 2 intervalos de tamanhos (aproximadamente) iguais. Podemos fazer isso só chutando na metade do intervalo, assim é melhor fazer o primeiro chuta na posição 500 e nao 400.</p><h2 id=condições-para-aplicar-busca-binária>Condições para aplicar busca binária</h2><p>Nem sempre é possível aplicar busca binária para encontrar uma resposta: um exemplo seria um livro cujos capitulos e seçoes nao estão em ordem crescente. Nessa situação, não poderiamos mais ter certeza que um capitulo ou seção maior estaria a direita.</p><p>Como mencionamos acima, na busca binária estamos procurando o maior ou menor valor que satisfaz uma propriedade. Então por exemplo, no exemplo acima, estamos buscando pelo menor índice(página) do vetor(livro) que satisfaz a condição &ldquo;estar num (capítulo, seção) maior ou igual a (6,4)&rdquo;, porque a primeira página que satisfazer essa propriedade será o início do capítulo 6 seção 4. Considere agora o outro exemplo de aplicarmos busca binaria no vetor para descobrir se um elemento <code>x</code> esta lá ou não. Uma maneira de fazer isso seria procurar pelo menor elemento <code>y</code> que seja maior ou igual <code>x</code>, se y for igual a x, então x está no vetor, caso contrário x não está no vetor.</p><p>Dizemos que é possível aplicar busca binária em um problema quando a checagem se um valor satisfaz as condições apresenta <strong>monotonicidade</strong>. Formalmente, monotonicidade pode ser definida da seguinte forma. Seja <code>check(x)</code> uma função que verifica uma propriedade de <code>x</code> Se para todo <code>x</code>, <code>check(x) = true</code> implica <code>check(x+1) = true</code>, ou para todo x, <code>check(x) = false</code> implica <code>check(x+1) = false</code>, então a função <code>check</code> é monótona.</p><p>Então, se <code>x = 11</code> e o vetor <code>v = [1,2,3,5, 8, 11, 12, 14, 16]</code> observe o que acontece com o comportamento de uma função <code>check</code> que checa se um elemento é maior ou igual a x.</p><pre tabindex=0><code>bool check(int val) {
    return val &gt;= x;
}

[1,2,3,5,8,11,12,14,16]
[0,0,0,0,0,1,1,1,1,1]
</code></pre><p>Então se colocarmos graficamente os resultados de uma função <code>check</code> monotona, veremos exatamente isso, ou um monte de valores <code>0</code>s e a partir de certo ponto todos são <code>1</code>s, ou o contrário, um monte de <code>1</code>s e a partir de certo ponto todos são <code>0</code>s. No exemplo a cima é a primeira possibilidade.</p><p>Então a função check para essa situação é monótona, e isso é relevante porque se um valor do vetor satisfizer a condição, todos os valores a direita também vão satisfazê-la, e de forma análoga, todos os valores a esquerda de um índice que não satisfaz a condição, também não vão satisfazer, e é isso que nos permite aplicar busca binária. E a função check só se torna monótona nesse exemplo quando o vetor está ordenado, por isso busca binária só é feita em vetores ordenados : ).</p><p>Então o que faremos é chutar intervalo aonde a resposta com certeza estará no começo, fazemos então várias interações checando no meio, e dependendo da resposta, descartamos os elementos a direita ou a esquerda, mas sempre dividimos o tamanho do intervalo por 2, até que o intervalo tenha tamanho 1.</p><h2 id=complexidade>Complexidade</h2><p>Tudo muito massa, mas falta a complexidade! Depois de saber isso podemos começar a aplicar esse algoritmo nos problemas por ae :)</p><p>por enquanto nosso algoritmo de maneira abstrata é o seguinte</p><pre tabindex=0><code>while(tamanho do intervalo que a resposta pode estar != 1) {
    chuta no meio e descarta a metade da direita ou da esquerda(dependendo do resultado), dividindo o intervalo por 2;
}
</code></pre><p>Suponha um vetor ordenado de tamanho N onde vamos aplicar o algoritmo de busca binária e o valor procurado não está presente no vetor (pior caso). Na nossa primeira iteração iremos dividir o vetor em 2 partes ou seja teremos N/2 elementos restantes, na segunda iteração iremos dividir do que restou e teremos (N/2)/2 ou seja N/4, seguindo essa lógica na K-ésima iteração vamos dividir o tamanho do vetor K vezes por 2, ou seja, N/(2^K) e como estamos calculando complexidade temos que pensar no pior caso, quando chegarmos no ponto onde teremos um espaço de apenas 1 elemento(e verificamos que o elemento não está no vetor). O que estamos buscando para saber a complexidade é K (quantidade de passos) para o pior caso então temos que N/(2^K) = 1 daí temos que N = 2^K e tirando o log2 dos dois lados temos que K = log2(N). Então no pior caso nosso algortimo demora <code>O(log2(N))</code> passos, N sendo o tamanho do intervalo inicial. Se a função de checagem tiver uma complexidade <code>O(f(x))</code>, então teremos complexidade no total <code>O(log2(N) * f(x))*</code>.</p><h2 id=código-base-para-busca-binária>Código base para busca binária</h2><p>Há várias maneiras de se implementar busca binária, vamos apresentar várias delas. Vamos usar sempre a função check em separado, os jeitos de implementar diferente são apenas do corpo da busca binária.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// nessa função checamos se uma resposta satisfaz as condições para ser uma resposta válida, e retornamos um booleano dependendo disso.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=tipo-1>Tipo 1</h3><h4 id=valor-mínimo-menor-valor-que-torna-check-verdadeiro>Valor mínimo (Menor valor que torna check verdadeiro)</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;<span style=color:#75715e>// sei que a resposta não é menos que a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;<span style=color:#75715e>// sei que a resposta não é mais que b (as vezes esse chute tem que ser bom, para evitar overflow)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(r <span style=color:#f92672>&gt;</span> l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>){<span style=color:#75715e>// repita enquanto o intervalo tiver tamanho &gt; 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(check(mid)){ <span style=color:#75715e>// mid é válido
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        r <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// como queremos minimizar a resposta, e mid é uma resposta válida
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>//descartamos tudo a direita de mid (mas não mid)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        l <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Se mid não é válido, descartamos ele e tudo abaixo.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Ao final desse laço, a resposta pode estar em l ou r.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Queremos minimizar a resposta, então se l for válido, 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ficaremos com l, e caso contrário,  com r
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(check(l)){
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=valor-máximo-maior-valor-que-torna-check-verdadeiro>Valor máximo (Maior valor que torna check verdadeiro)</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(r <span style=color:#f92672>&gt;</span> l<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(check(mid)){<span style=color:#75715e>// mid é válido
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        l <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// como queremos maximizar a resposta, e mid é uma resposta válida
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>//descartamos tudo a esquerda de mid (mas não mid)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>        r <span style=color:#f92672>=</span> mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Se mid não é válido, descartamos ele e tudo acima.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(check(l)){
</span></span><span style=display:flex><span>    ans <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=tipo2>Tipo2</h3><h4 id=valor-mínimo>Valor mínimo</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (check(mid)) r <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// a resposta fica em l
</span></span></span></code></pre></div><h4 id=valor-máximo>Valor máximo</h4><p>É fácil alterar o código de valor mínimo para encontrar o valor máximo:
Imagine que uma função de check dê o resultado <code>[1,1,1,0,0]</code>. Veja que encontrar o último 1
nesse array é equivalente a encontrar o primeiro 0 e subtrair 1 da posição! Assim, podemos aplicar
a busca binária de valor mínimo <strong>no valor contrário</strong> do checker (<code>!check(mid)</code>) e subtrair 1 da resposta ao final.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>check(mid)) r <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// check vira !check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>else</span> l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// a resposta fica em l-1
</span></span></span></code></pre></div><p>Detalhe: como usamos <code>l-1</code> no final, a busca não inclui <code>b</code>, ou seja, buscamos no intervalo <code>[a, b)</code>.</p><h2 id=exemplos-de-aplicação>Exemplos de aplicação</h2><h3 id=implementação-de-lower_bound>Implementação de lower_bound</h3><p>Consideremos o problema de achar o indice do primeiro elemento maior ou igual um <code>x</code> num vetor <code>v</code> de tamanho <code>n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> v[MAXN], n; <span style=color:#75715e>// vetor global para facilitar o código
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// funcao que retorna se id é uma resposta válida pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> id, <span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v[id] <span style=color:#f92672>&gt;=</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// retorna o indice do primeiro elemento &gt;= x, considerando que o vetor v está ordenado
</span></span></span><span style=display:flex><span><span style=color:#75715e>// se todos os elementos sao menores que x, retorna -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lower_bound</span>(<span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> L, R, ans;
</span></span><span style=display:flex><span>    L <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// começo do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    R <span style=color:#f92672>=</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// fim do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ans <span style=color:#f92672>=</span> n; <span style=color:#75715e>// começamos a resposta com um valor fora do vetor, inválido para marcar se conseguimos achar alguma resposta ou nao
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(L <span style=color:#f92672>&lt;=</span> R){ <span style=color:#75715e>// enquanto tiver algum número no intervalo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (L<span style=color:#f92672>+</span>R)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(check(mid, x)){ <span style=color:#75715e>// se esse mid é uma resposta apropriada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans <span style=color:#f92672>=</span> mid; <span style=color:#75715e>// achamos uma nova resposta para o problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            R <span style=color:#f92672>=</span> mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se mid é uma resposta temos que tentar procurar uma resposta menor(nesse problema em especifico)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>{ <span style=color:#75715e>// se mid nao é uma resposta pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            L <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// precisamos procurar em indices maiores(neste problema)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(ans <span style=color:#f92672>==</span> n) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se ans ainda é n depois da busca binária, então nunca achamos resposta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Perceba que se quisermos achar o indice do último elemento maior ou igual um <code>x</code> num vetor <code>v</code> de tamanho <code>n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> v[MAXN], n; <span style=color:#75715e>// vetor global para facilitar o código
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// funcao que retorna se id é uma resposta válida pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> id, <span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v[id] <span style=color:#f92672>&gt;=</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// retorna o indice do primeiro elemento &gt;= x, considerando que o vetor v está ordenado
</span></span></span><span style=display:flex><span><span style=color:#75715e>// se todos os elementos sao menores que x, retorna -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lower_bound</span>(<span style=color:#66d9ef>int</span> x){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> L, R, ans;
</span></span><span style=display:flex><span>    L <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// começo do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    R <span style=color:#f92672>=</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// fim do intervalo que consideraremos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ans <span style=color:#f92672>=</span> n; <span style=color:#75715e>// começamos a resposta com um valor fora do vetor, inválido para marcar se conseguimos achar alguma resposta ou nao
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(L <span style=color:#f92672>&lt;=</span> R){ <span style=color:#75715e>// enquanto tiver algum número no intervalo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (L<span style=color:#f92672>+</span>R)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(check(mid, x)){ <span style=color:#75715e>// se esse mid é uma resposta apropriada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans <span style=color:#f92672>=</span> mid;  <span style=color:#75715e>// achamos uma nova resposta para o problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            L <span style=color:#f92672>=</span> mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se mid é uma resposta temos que tentar procurar uma resposta maior(nesse problema em especifico)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>{ <span style=color:#75715e>// se mid nao é uma resposta pro nosso problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            R <span style=color:#f92672>=</span> mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// precisamos procurar em indices menores(neste problema)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(ans <span style=color:#f92672>==</span> n) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// se ans ainda é n depois da busca binária, então nunca achamos resposta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Em ambos os exemplos a complexidade de checar se mid é uma resposta válida para o problema é <code>O(1)</code>. Portanto a complexidade total é <code>O(lg n)</code>.</p><p>Muitas pessoas ja viram o exemplo de realizar busca binária em vetores, mas quando se fala em busca binária na resposta, ficam confusas. Na verdade, busca binária em vetores é busca binária na resposta, mas a resposta é um índice.</p><h1 id=material-complementar>Material complementar</h1><h1 id=exercícios-recomendados>Exercícios recomendados</h1><p>Estes exercícios não estão necessariamente em ordem de dificuldade.</p><ul><li><a href=https://codeforces.com/contest/1234/problem/A>https://codeforces.com/contest/1234/problem/A</a> - Não é necessário busca binária mas é um exercício legal para aprender</li><li><a href=https://codeforces.com/problemset/problem/817/C>https://codeforces.com/problemset/problem/817/C</a> - Bem interessante, (se x é um numero realmente grande entao x+1 é realmente grande)</li><li><a href=https://codeforces.com/problemset/problem/760/B>https://codeforces.com/problemset/problem/760/B</a> - Se frodo não consegue ter x de altura então consegue ter x+1 de altura. Cuidado com overflows!</li><li><a href=https://codeforces.com/gym/102346/problem/M>https://codeforces.com/gym/102346/problem/M</a> - (Tente minimizar o quanto cada competidor come já que a resposta é em função do competidor que mais come)</li></ul><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Grafos</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/grafos/representacao/>Representação de Grafos</a></li><li><a href=/materiais/grafos/busca_largura/>Busca em Largura</a></li><li><a href=/materiais/grafos/busca_profundidade/>Busca em Profundidade</a></li><li><a href=/materiais/grafos/dijkstra/>Dijkstra</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Grafos</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 17</div><h1>Representação de Grafos</h1><p>Um dos assuntos mais frequentes são problemas relacionados a grafos, ou que podem ser representados como grafos, apesar de não ser óbvio à primeira vista.</p><h2 id=conceitos>Conceitos</h2><p>Há diversos tipos e atributos de um grafo:</p><h3 id=o-que-é-um-grafo>O que é um grafo?</h3><p>Um grafo é definido simplesmente por um conjunto de vértices, e outro conjunto de arestas. Essas arestas ligam dois vértices, e podem ter pesos atrelados à elas.</p><h3 id=grafo-simples>Grafo simples</h3><p>Grafo simples é um grafo que não cujas arestas não tem peso, não possui loops, e nem arestas múltiplas. Loops são arestas do tipo <code>(u,u)</code>, ou seja, que saem do vértice <code>u</code>, e vão para o vértice <code>u</code>. Um grafo com arestas múltiplas é um grafo que tem duas aresta iguais.</p><h3 id=grafos-direcionados>Grafos direcionados</h3><p>Existem grafos direcionados e não direcionados. No caso dos direcionados, significa que cada aresta tem uma direção, ou seja, se é possível chegar de a em b, não significa que é possível chegar de b em a.</p><h3 id=ciclos>Ciclos</h3><p>A definição de ciclo é um pouco diferente dependendo se o grafo é direcionado ou não.</p><p>Caso o grafo não seja direcionado, e hajam dois caminhos diferentes de um vértice <code>a</code> para um vértice <code>b</code>, então há um ciclo.</p><p>Caso contrário, ou seja, caso o grafo seja direcionado, para que haja um ciclo é necessário que exista um vértice <code>a</code> tal que seja possível voltar a <code>a</code> partindo dele mesmo.</p><h3 id=conexo>Conexo</h3><p>Um grafo conexo é um grafo tal que para dois vértices quaisquer u e w, sempre existe um caminho de u para w.</p><h3 id=componentes-conexas>Componentes conexas</h3><p>Um grafo que não é conexo pode ter várias componentes conexas (grafos conexos tem somente uma componente). Essencialmente, uma componente conexa é um pedaço conexo do grafo. Esse conceito é usado no caso de grafos não-direcionados.</p><h3 id=componentes-fortemente-conexas>Componentes fortemente conexas</h3><p>Já nos casos do grafos direcionados, o termo usado é esse, também chamados por SCCs(Strongly Connectec Components). A definição mais &lsquo;formal&rsquo; é a seguinte: dentro de uma componente conexa de um grafo direcionado, para todo vértice <code>a</code> e <code>b</code>, deve ser possível de chegar de <code>b</code> partindo de <code>a</code> e em <code>a</code> partindo de <code>b</code>.</p><p>Basicamente o que a definição acima está dizendo é: uma componente fortemente conexa é um ciclo, mas é importante lembrar que se dois ciclos se juntam, formam um ciclo maior, logo, uma componente maior.</p><h3 id=árvore>Árvore</h3><p>Uma árvore é um tipo de grafo. Para ser uma árvore, o grafo precisa ser conexo, não ter ciclos e ter <code>n-1</code> arestas, aonde n é o número de vértices.</p><h3 id=dag>DAG</h3><p>DAG é uma sigla para <code>Directed Acyclic Graph</code>, ou seja, um grafo acíclico e direcionado. É um termo bastante usado.</p><h3 id=grafos-bipartidos>Grafos bipartidos</h3><p>Um grafo bipartido é um grafo tal que é possível dividir seus vértices em dois grupos, de forma que só hajam arestas ligando vértices do primeiro ao segundo grupo.</p><h2 id=representação-de-um-grafo>Representação de um grafo</h2><p>Mas como representar um grafo em código?</p><p>Na verdade é bem mais simples do que parece. Para cada vértice, temos que manter apenas uma lista das arestas que saem daquele vértice.</p><p>Nessa representação, a i-ésima posição no vector de fora <code>vector&lt;int></code>, esse vector representam as arestas que saem daquele vértice. Então, cada vértice tem um número associado a ele.</p><h3 id=exemplo>Exemplo</h3><p><img src=http://danielamaral.wikidot.com/local--files/agmmo/Grafo.png alt=Grafo></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[<span style=color:#ae81ff>7</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>6</span>].push_back(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>5</span>].push_back(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>3</span>].push_back(<span style=color:#ae81ff>4</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>2</span>].push_back(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>3</span>].push_back(<span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>2</span>].push_back(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>5</span>].push_back(<span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>4</span>].push_back(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>6</span>].push_back(<span style=color:#ae81ff>4</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>2</span>].push_back(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>graph[<span style=color:#ae81ff>1</span>].push_back(<span style=color:#ae81ff>2</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// lembrando que no caso de grafos não direcionados, quando adicionamos (a,b) precisamos sempre adicionar (b,a) junto.
</span></span></span></code></pre></div><h2 id=representação-da-grafos-implícitos>Representação da grafos implícitos</h2><p>Considere o seguinte problema para guiar a explicação: <a href=http://codeforces.com/problemset/problem/520/B>http://codeforces.com/problemset/problem/520/B</a></p><p>A principio, nao parece exatamente muito fácil relacionar esse problema com grafos. Onde estão os vértices e as arestas? Na verdade nesse problema há o que chamamos de grafo implícito.</p><p>Podemos considerar os vértices como o número mostrado pelo display, e as arestas como os vértices que consigo alcançar apertando os botões, a partir do vértice que estou. Mas nós não vamos criar uma estrutura de lista de adjacências em memória igual ao caso anterior, não precisamos. A única coisa que precisamos é saber quais vértices podemos atingir a partir de um vértice <code>x</code>, então quando formos percorrer esse grafo implícito, como todos os vértices seguem essa regra, não precisamos criar as arestas propriamente ditas. Apenas sabemos que é possível atingir os vértices <code>x-1</code> e <code>2x</code>.</p><p>O mesmo ocorre pra representação de jogos de turno, por exemplo jogo da velha ou damas. Podemos considerar uma configuração do tabuleiro como um vértice, e as arestas ligando para todas as configurações possíveis de atingir segundo as regras de jogada.</p><h2 id=videoaulas-complementares>VideoAulas complementares</h2><p><a href="https://www.youtube.com/watch?v=zaBhtODEL0w">https://www.youtube.com/watch?v=zaBhtODEL0w</a></p><h2 id=exercícios-recomendados>Exercícios recomendados</h2><ul><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1910>https://www.urionlinejudge.com.br/judge/pt/problems/view/1910</a> - Caminho mínimo em grafo implícito sem pesos.</li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1907>https://www.urionlinejudge.com.br/judge/pt/problems/view/1907</a> - Contagem de componentes conexas em grafo que é um grid (implícito).</li><li><a href=https://codeforces.com/gym/102346/problem/A>https://codeforces.com/gym/102346/problem/A</a> - Se considerarmos as paredes e sensores vértices, vendo se alguns vértices estão na mesma componente conexa podemos ver se há um caminho que bloqueia o ladrão.</li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2194>https://www.urionlinejudge.com.br/judge/pt/problems/view/2194</a> - (implementação mais difícil), resolver o reconhecimento por meio da contagem das componentes conexas de cada hieróglifo.</li></ul><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 18</div><h1>Busca em Largura</h1><p>Podemos chamá-la também de <strong>BFS (Breadth-First Search)</strong>.</p><p>Uma das formas de percorrer um grafo é fazer um percorrimento em largura. Começamos a explorar os vértices do grafo a partir de um certo vértice <code>a</code>. E a ordem que vamos navegando entre os vértices é de forma que os mais próximos a <code>a</code> sempre serão visitados antes. Então, primeiro <code>a</code> será visitado, depois os vértices que são adjacentes a <code>a</code>(distância 1), depois os vértices que estão a duas arestas de distância, e assim por diante. Como os vértices mais próximos são sempre visitados antes, esse algoritmo serve para, por exemplo, dizer qual a distância mínima entre dois vértices no grafo.</p><p>Esse comportamento é implementado usando-se uma fila. Primeiro insere-se na fila o vértice inicial, e começa-se a desenfileirar da fila enquando houver algum nodo. Quando um vértice <code>a</code> é desenfileirado, enfileram-se todos os vértice adjacentes a <code>a</code> que não foram visitados. Caso não marquemos os visitados, e o grafo tiver ciclos, nosso programa não terminará.</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Breadth-First-Search-Algorithm.gif/250px-Breadth-First-Search-Algorithm.gif alt=BFS></p><p>O algoritmo abaixo é uma BFS que simplesmente percorre o grafo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// globais
</span></span></span><span style=display:flex><span><span style=color:#75715e>// inicializa visited como false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> visited[MAX_SIZE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[MAX_SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bfs</span>(<span style=color:#66d9ef>int</span> start){
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>    q.push(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    visited[start] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){<span style=color:#75715e>//Enquanto não estiver vazia
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Retire o vértice da frente
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> w: graph[u]){ <span style=color:#75715e>// Para cada vértice adjacente a u
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[w]){
</span></span><span style=display:flex><span>                q.push(w);
</span></span><span style=display:flex><span>                visited[w] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade desse código é <code>O(n+m)</code>, temos no máximo n vértices enfileirados, e no loop interno, cada iteração é considerar uma aresta, como não estamos voltando no grafo, não passaremos por uma aresta mais que duas vezes naquele loop. Então, em todas as chamadas, aquele loop iterará no pior caso m vezes.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 19</div><h1>Busca em Profundidade</h1><p>Outra forma de percorrer um grafo é fazer percorrimento em profundidade, também de chamado de <strong>DFS(Depth-first search)</strong>. O algoritmo se chama assim porque funciona de uma forma que sempre vamos &lsquo;mergulhar&rsquo; no grafo o mais fundo que pudermos. Quando não for mais possível ir mais fundo no grafo, voltamos até que seja ir mais fundo novamente, sem repetir vértices já visitados.</p><p>A implementação da DFS mais comum é recursiva, por ser mais intuitiva. Assim como o exemplo anterior, esse programa simplesmente percorre o grafo, mas na ordem que um DFS percorre.</p><h2 id=visualização>Visualização</h2><p><img src=http://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif alt=DFS></p><h2 id=implementação>Implementação</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[MAX_SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> visited[MAX_SIZE];     <span style=color:#75715e>// globais, inicializados na main.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> vertex){ <span style=color:#75715e>// na main chamamos dfs(start), aonde start é o vértice que começamos o dfs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    visited[vertex] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> w: graph[vertex]){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>visited[w]){
</span></span><span style=display:flex><span>            dfs(w);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade desse código é <code>O(n+m)</code>, temos no máximo <code>n</code> chamadas recursivas, e no loop interno às chamadas, assim como no BFS, estaremos considerando uma aresta e não passaremos nela mais de uma vez. Então no máximo <code>m</code> iterações ao longo de todas as chamadas.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 20</div><h1>Dijkstra</h1><div class="box notices cstyle secondary"><div class=box-label><i class="fa-fw fas fa-stopwatch"></i> Complexidade</div><div class=box-content><p>O(E*log(V))</p><p><code>E = Edges</code>
<code>V = Vertex</code></p></div></div><p>O algoritmo de Dijkstra é um algoritmo muito conhecido para percorrimento de grafos cujas arestas tem pesos, ele nos permite percorrer os vértices na ordem de distância para um vértice fonte. E efetivamente descobrir essas distâncias.</p><p>Mais especificamente, de uma forma tal que considerando o vértice fonte como <code>s</code>, se o menor caminho de <code>s</code> para um vértice <code>u</code> é estritamente menor que o menor caminho de <code>s</code> para um outro vértice <code>v</code>, com certeza visitaremos <code>u</code> antes de <code>v</code>.</p><p>A forma como o algoritmo opera é muito parecida com o BFS, mas em vez de usarmos uma fila, usamos uma fila de prioridades(priorizando menores valores). O motivo de usarmos essa outra estrutura de dados é que usar uma fila não gera mais o mesmo comportamento que desejamos quando as arestas passam a ter pesos.</p><p>Como as arestas tem pesos, nosso grafo será um <code>vector&lt;pair&lt;int,int>> grafo[n]</code> ao invés de um <code>vector&lt;int> grafo[n]</code>.</p><h3 id=a-ideia>A ideia</h3><p>Assim como no BFS, teremos essa fila que ditará a ordem com que os nodos serão desenfileirados (visitados). Mas agora Nossa Fila é de prioridades abriga pares ao invés de apenas um inteiro.</p><p>Pra qualquer par <code>p</code> na fila, <code>(p.first,p.second)</code> significa: Consigo chegar no vértice <code>p.second</code> por um caminho de custo <code>p.first</code>. Por isso no começo da execução enfileiramos o par <code>(0, s)</code>, dizendo: consigo chegar no vértice fonte pagando 0, afinal já estamos nele no começo do percorrimento.</p><p>Quando desinfileiramos um vértice, assim como no BFS, consideramos seguir por todas as arestas que partem dele, agora com pesos.</p><p>Bem, para cada aresta, sabemos seu destino e seu peso, então, a informação que podemos tirar disso é que podemos ir para aquele destino com o custo da aresta somado com o custo para chegar no vértice que acabamos de desinfileirar.</p><p>Na implementação do BFS, na hora de verificar se devíamos enfileirar algo, verificavamos apenas se aquele destino já tinha sido enfileirado antes, usando um vetor pra armazenar essa informação.</p><p>Na nossa implementação, ao invés de um vetor marcando quais já foram enfileirados, usaremos um vetor indicando o melhor custo conhecido para se atingir cada vértice.</p><p>O motivo disso é que não há mais garantia que na primeira vez que enfileiramos um vértice já obtivemos o melhor custo para chegar nele. Pode ser que posteriormente enfileiremos um custo menor pra chegar nesse vértice.</p><p>Então, na hora de enfileirarmos, verificaremos se aquele enfileiramento é vantajoso, isto é, se ele melhora o melhor custo que já conhecíamos para chegar em algum vértice. De começo assumimos o custo infinito para chegar em todos.</p><h3 id=visualização>Visualização</h3><p><img src=https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif alt=Dijkstra></p><h3 id=implementação>Implementação</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ll;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>100005</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> ll oo <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e18</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ll d[N]; <span style=color:#75715e>// vetor onde guardamos as distancias
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n; <span style=color:#75715e>// numeros de vertices
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// lista de adjacencias guarda
</span></span></span><span style=display:flex><span><span style=color:#75715e>// pair &lt;vertice para onde a aresta vai, peso da aresta&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, ll<span style=color:#f92672>&gt;&gt;</span> g[N];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dijkstra</span>(<span style=color:#66d9ef>int</span> start){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// inicialmente a distancia do vertice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// start para todo os outros é infinita
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; u <span style=color:#f92672>&lt;=</span> n; u<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>		d[u] <span style=color:#f92672>=</span> oo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// fila de prioridade de pair&lt;ll, int&gt;, mas que o
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// menor pair fica no topo da fila
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// guardamos um pair &lt;distancia ate o vertice, vertice&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// assim o topo da fila sempre é o vertice com menor distancia
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	priority_queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>ll, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>ll, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>		greater<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>ll, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	d[start] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	pq.emplace(d[start], start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ll dt, w;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> u, v;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>pq.empty()){
</span></span><span style=display:flex><span>		tie(dt, u) <span style=color:#f92672>=</span> pq.top(); pq.pop();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(dt <span style=color:#f92672>&gt;</span> d[u]) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> edge : g[u]){
</span></span><span style=display:flex><span>			tie(v, w) <span style=color:#f92672>=</span> edge;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// se a distancia ate o u somado com o peso
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// da aresta é menor do que a distancia ate o v que
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// tinhamos antes, melhoramos a distancia ate o v
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span>(d[v] <span style=color:#f92672>&gt;</span> d[u] <span style=color:#f92672>+</span> w){
</span></span><span style=display:flex><span>				d[v] <span style=color:#f92672>=</span> d[u] <span style=color:#f92672>+</span> w;
</span></span><span style=display:flex><span>				pq.emplace(d[v], v);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// lê o input, qnt de vertices, arestas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// e vertice inicial(start)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	dijkstra(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; u <span style=color:#f92672>&lt;=</span> n; u<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>		printf(<span style=color:#e6db74>&#34;Distancia de %d para %d: %lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, start, u, d[u]);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Assim como no BFS, podemos facilmente adicionar um vetor indicando os predecessores de cada vértice, dessa forma podemos obter não só a informação dos custos, mas também a sequência de vértices que a origina.</p><footer class=footline></footer></article></section><article class=chapter dir=ltr><div class=article-subheading>Capítulo 21</div><h1>Bitwise</h1><h2 id=representação-binária>Representação binária</h2><hr><p>Qualquer tipo de dado, seja um número inteiro, número racional ou um caracter, pode ser representado por bits.
Exemplos de representação binária de números inteiros (sem sinal):<br><strong>1)</strong> 14 = {1110}2 = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 = 14.<br><strong>2)</strong> 20 = {10100}2 = 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 20.</p><h2 id=operadores-bit-a-bit>Operadores bit-a-bit</h2><hr><p><strong>NOT ( ~ )</strong>: Bitwise NOT é um operador unário que flipa os bits de um número (se o bit é 0, vira 1 e vice-versa). Bitwise NOT é apenas o complemento de 1 de um número.<br>N = 5 = (101)2<br>~N = ~5 = ~(101)2 = (010)2 = 2</p><p><strong>AND ( & )</strong>: Bitwise AND é um operador binário que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posição comparada das palavras forem 1, então o valor do bit resultante nessa posição na palavra final será 1, qualquer outro caso o bit resultante será 0.
A = 5 = (101)2<br>B = 3 = (011)2<br>A & B = (101)2 & (011)2= (001)2 = 1</p><p><strong>OR ( | )</strong>: Bitwise OR, similarmente ao bitwise AND, é um operador binário que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posição comparada forem 0, o valor do bit resultante nessa posição na palavra final será 0, qualquer outro caso o bit resultante será 1.<br>A = 5 = (101)2<br>B = 3 = (011)2<br>A | B = (101)2 | (011)2 = (111)2 = 7</p><p><strong>XOR ( ^ )</strong>: Bitwise XOR também é um operador binário que opera em duas palavras de bits de mesmo tamanho. Se ambos os bits na posição comparada forem iguais (0 ou 1), o valor do bit resultante nessa posição na palavra final será 0, se os bits forem diferentes (um 0 e outro 1), o bit resultante será 1.<br>A = 5 = (101)2<br>B = 3 = (011)2<br>A ^ B = (101)2 ^ (011)2 = (110)2 = 6</p><p><strong>Left Shift ( &#171; )</strong>: Existem dois operadores de deslocamento (left shift e righr shift). O left shift operator é um operador binário que desloca os bits de uma palavra X vezes para a esquerda e preenche a palavra com X 0s à direita. <strong>Left shift de X bits em um número inteiro é equivalente a multuplicá-lo por 2^X.</strong><br>1 &#171; 1 = 2<br>1 &#171; 2 = 4<br>2 &#171; 2 = {00010}2 &#171; 2 = {01000}2 = 8<br>1 &#171; n = 2^n</p><p><strong>Right Shift ( &#187; )</strong>: O right shift operator é um operador binário que desloca os bits de uma palavra X vezes para a direita e preenche a palavra com X 0s à esquerda. <strong>Right shift de X bits em um número inteiro é equivalente a dividi-lo por 2^X.</strong><br>4 &#187; 1 = 2<br>6 &#187; 1 = 3<br>5 &#187; 1 = 2<br>16 &#187; 4 = 1</p><h4 id=tabela-verdade>Tabela-verdade</h4><table><thead><tr><th>X</th><th>Y</th><th>X&amp;Y</th><th>X|Y</th><th>X^Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id=manipulando-bits>Manipulando bits</h2><hr><h4 id=checando-se-um-determinado-bit-está-ligado>Checando se um determinado bit está ligado</h4><p>Para checarmos de um jeito eficiente se o i-ésimo bit de um número N está ligado, basta apenas checar se o AND de 2^i e N é diferente de 0. Como vimos anteriormente, o número 2^i é simplesmente o número 1 shiftado de i bits (1 &#171; i).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isSet</span>(<span style=color:#66d9ef>int</span> bitPosition, <span style=color:#66d9ef>int</span> number) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> ((number <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPosition)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=ligando-um-determinado-bit-em-um-número>Ligando um determinado bit em um número</h4><p>Para ligar o i-ésimo bit de um número N, basta apenas fazermos o OR de 2^i com N.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>setBit</span>(<span style=color:#66d9ef>int</span> bitPosition, <span style=color:#66d9ef>int</span> number) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (number <span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPosition) );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=representando-conjunto-com-bits---bitmasks>Representando conjunto com bits - bitmasks</h2><hr><p>Suponha que tenhamos conjunto universo com 8 elementos, U = {a,b,c,d,e,f,g,h}.<br>Vamos associar cada elemento de U a um bit:</p><p>a -> bit 7<br>b -> bit 6<br>c -> bit 5<br>d -> bit 4<br>e -> bit 3<br>f -> bit 2<br>g -> bit 1<br>h -> bit 0</p><p>Com essa associação, podemos representar qualquer subconjunto de U como uma máscara de 8 bits. Exemplo:</p><table><thead><tr><th>Conjunto</th><th>Bitmask</th></tr></thead><tbody><tr><td>{b,c,f,h}</td><td>01100101</td></tr><tr><td>{a}</td><td>10000000</td></tr><tr><td>{}</td><td>00000000</td></tr></tbody></table><h4 id=adicionar-um-elemento-ao-conjunto>Adicionar um elemento ao conjunto</h4><p>Para adicionarmos um elemento a um conjunto que está representado como uma bitmask é simples. Basta apenas setarmos o bit correspondente ao elemento na bitmask do conjunto.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>addElement</span>(<span style=color:#66d9ef>int</span> bitmask, <span style=color:#66d9ef>int</span> elementPosition) {
</span></span><span style=display:flex><span>  bitmask <span style=color:#f92672>=</span> bitmsak <span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> elementPosition);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> bitmask;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=checar-se-um-conjunto-contem-um-elemento>Checar se um conjunto contem um elemento</h4><p>Essa operação é a mesma de checar se um dado bit está setado na bitmask.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasElement</span>(<span style=color:#66d9ef>int</span> bitmask, <span style=color:#66d9ef>int</span> elementPosition){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ret <span style=color:#f92672>=</span> ((bitmask <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> elementPosition)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=união-de-2-conjuntos>União de 2 conjuntos</h4><p>Um elemento estará presente na união de 2 conjuntos se e somente se pelo menos um dos conjuntos contiver este elemento. Com base nisso e na tabela-verdade, podemos ver que a máscara que representa a união de duas máscaras é o OR delas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>union</span>(<span style=color:#66d9ef>int</span> bitmaskA, <span style=color:#66d9ef>int</span> bitmaskB){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (bitmaskA <span style=color:#f92672>|</span> bitmaskB);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=interseção-de-2-conjuntos>Interseção de 2 conjuntos</h4><p>Um elemento estará presente na interseção de 2 conjuntos se e somente se os 2 conjuntos contiverem este elemento. Logo, a máscara que representa a interseção de duas máscaras é o AND delas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>intersection</span>(<span style=color:#66d9ef>int</span> bitmaskA, <span style=color:#66d9ef>int</span> bitmaskB){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (bitmaskA <span style=color:#f92672>&amp;</span> bitmaskB);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=gerando-todos-os-subconjuntos-de-um-conjunto>Gerando todos os subconjuntos de um conjunto</h4><p>Suponha que você tenha um conjunto S = {p,q,r}.<br>Para formar um subconjunto de S, podemos escolher ou não o elemento <strong>p</strong> (2 opções), escolher ou não o elemento <strong>q</strong> (2 opções de novo) e escolher ou não o elemento <strong>r</strong> (2 opções novamente). Logo, podemos formar um subconjunto de S de 2*2*2 maneiras diferentes.
Um conjunto de N elementos possui 2^N subconjuntos. S possui 2^3 = 8 subconjuntos.</p><p>Ok, agora vamos representar cada elemento do conjunto S com um bit, como S tem 3 elementos, precisamos de 3 bits para isso:<br><strong>p</strong> = bit 2,<br><strong>q</strong> = bit 1,<br><strong>r</strong> = bit 0</p><p>Com esta associação de elementos e bits, podemos representar todos os subconjuntos de S como uma palavra de 3 bits. Veja:</p><p>0 = (000)2 = {}<br>1 = (001)2 = {r}<br>2 = (010)2 = {q}<br>3 = (011)2 = {q, r}<br>4 = (100)2 = {p}<br>5 = (101)2 = {p, r}<br>6 = (110)2 = {p, q}<br>7 = (111)2 = {p, q, r}</p><p>Como temos 2^N subconjuntos em um conjunto de N elementos, passando por todos os números de [0, 2^N - 1] é possível representar todos os subconjuntos de um conjunto.<br>Código para printar todos os subconjuntos de um conjunto:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>possibleSubsets</span>(<span style=color:#66d9ef>char</span> S[], <span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> N); <span style=color:#f92672>++</span>i) {  <span style=color:#75715e>// i = [0, 2^N - 1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> N;<span style=color:#f92672>++</span>j)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> j))  <span style=color:#75715e>// se o j-ésimo bit de i está setado, printamos S[j]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                cout <span style=color:#f92672>&lt;&lt;</span> S[j] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=default dir=ltr><h1>Matematica</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/matematica/modulo/>Módulo</a></li><li><a href=/materiais/matematica/divisores/>Divisores</a></li><li><a href=/materiais/matematica/primos/>Números Primos</a></li><li><a href=/materiais/matematica/fatoracao/>Fatoração</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Matematica</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 23</div><h1>Módulo</h1><p>Diversos problemas em juízes online (e competições) costumam pedir a resposta módulo algum primo alto (bastante comum 10^9 + 7). O motivo disso é evitar overflow. Por exemplo: finja que você tem o seguinte problema:</p><p>Imprimir o resultado de 3^<code>x</code> (0 &lt;= <code>x</code> &lt;= 100), por exemplo. Esse resultado claramente excede 2^64 (limite de long long), então não faz muito sentido pedir o resultado por si só (na verdade, alguns problemas realmente pedem coisas do tipo, nesses casos, o recomendado é usar python, que não tem overflow).</p><p>Então pedem o resultado módulo 10^9 + 7, ou algum primo muito alto, para que não force as pessoas a usarem uma linguagem ou outra.</p><p>O motivo de ser um número alto é minimizar a chance de seu programa a computar a resposta errada (e por sorte ser igual em módulo a resposta correta) e o juíz aceitá-la.</p><p>O motivo de ser um número primo é que adicionam algumas propriedades a mais que podemos usar para calcular a resposta, como o inverso multiplicativo, mas não abordaremos isso aqui.</p><p>As seguintes propriedades valem no cálculo do módulo:</p><p><code>(a + b) % c = ((a % c) + (b % c)) % c</code></p><p><code>(a * b) % c = ((a % c) * (b % c)) % c</code></p><p>O que isso quer dizer é que se a resposta está sendo computada por meio de adições e multiplicações, e no final você precisa tirar o módulo dela, você pode tirar módulo em todas as operações intermediárias que isso não afetará a resposta.</p><p>Então, por exemplo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>exp</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3ll</span> <span style=color:#f92672>*</span> exp(p<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>  scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, exp(n) <span style=color:#f92672>%</span> mod);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O código acima gera overflow, a resposta vai estourar o limite de long long (já terá se tornado negativa) quando tirarmos o mod. No entanto, conceitualmente, ele está correto.</p><p>Então, usando as propriedades vistas em cima, podemos fazer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>exp</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (<span style=color:#ae81ff>3ll</span> <span style=color:#f92672>*</span> exp(p<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) <span style=color:#f92672>%</span> mod;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>  scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>n);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, exp(n));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>De forma que o código acima imprime (3^n) % (1000000007), sem causar overflow.</p><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 24</div><h1>Divisores</h1><p>Um problema recorrente é o de encontrar divisores de um número positivo. A maneira mais simples de resolvê-lo seria passar por todos os números e testar se o resto da divisão é 0, ou seja, se é divisível.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      ans.push_back(i);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>é fácil ver que a complexidade do código acima é <code>O(n)</code>, podemos fazer melhor que isso com algumas observações.</p><p>Se <code>a</code> é um divisor <code>n</code> então o resto da divisão de <code>n</code> por <code>a</code> é 0 assim <code>b = n/a</code> é um inteiro. Sabemos então que <code>a*b = n</code>, ou seja, <code>a = n/b</code> e assim <code>b</code> também é um divisor de <code>n</code>. Se fixarmos que <code>a &lt;= b</code>, qual o valor máximo de <code>a</code>? Como <code>a</code> é no máximo <code>b</code>, consideremos o caso em que <code>a = b</code> temos que <code>a*a = n</code>, ou seja, <code>a = sqrt(n)</code>.</p><p>Agora é possivel modificar o código passando por todos os valores possíveis de <code>a</code> e computar o respectivo <code>b</code> para encontrar todos os divisores.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, a &lt;= sqrt(n) é o mesmo que a*a &lt;= n, ja que a e n sao positivos
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> a;
</span></span><span style=display:flex><span>      ans.push_back(a);
</span></span><span style=display:flex><span>      ans.push_back(b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sort(ans.begin(), ans.end()); <span style=color:#75715e>// frescura para retornar os divisores ordenados como na primeira implementação
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Só há um problema com a implementação acima. Assumimos que <code>a &lt;= b</code>, caso <code>a = b</code> inserimos o divisor 2 vezes na resposta, por exemplo, para 36 podemos ter <code>a = 6</code> e <code>b = 6</code>. Assim a versão final do código fica:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> all_divisors(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, a &lt;= sqrt(n) é o mesmo que a*a &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> a;
</span></span><span style=display:flex><span>      ans.push_back(a);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span>(a <span style=color:#f92672>!=</span> b) ans.push_back(b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sort(ans.begin(), ans.end()); <span style=color:#75715e>// frescura para retornar os divisores ordenados como na primeira implementação
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>com complexidade <code>O(sqrt(n))</code>.</p><h3 id=observações>Observações</h3><p>Um número primo tem somente dois divisores positivos, assim podemos checar se um numero <code>x</code> é primo usando <code>all_divisors(x).size() == 2</code> ou modificando um pouco a rotina e ter uma melhor constante na complexidade</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> is_prime(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; a<span style=color:#f92672>*</span>a <span style=color:#f92672>&lt;=</span> n; a<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, a &lt;= sqrt(n) é o mesmo que a*a &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=passar-por-todos-os-múltiplos-de-x-até-n>Passar por todos os múltiplos de x até N</h2><p>Consideramos multiplos de <code>x</code> os números: <code>x, 2*x, 3*x, 4*x, ...</code> ou, escrevendo de outra forma, <code>x, x+x, x+x+x, x+x+x+x, ...</code></p><p>Caso queiramos fazer algo com todos os múltiplos de <code>x</code> até um limite <code>N</code> podemos usar a simples rotina</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) { <span style=color:#75715e>// m é sempre multiplo de x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Que é executada em <code>O(N/x)</code>.</p><h2 id=passar-por-todos-os-múltiplos-de-todos-os-números-até-n>Passar por todos os múltiplos de todos os números até N</h2><p>Se passarmos por todos os números <code>x</code> entre 1 e <code>N</code> e para cada um deles achar todos os múltiplos <code>m</code>.</p><p>O código ficaria algo como</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) { <span style=color:#75715e>// m é sempre multiplo de x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O código acima parece ser executado em <code>O(N^2)</code>, mas podemos definir uma cota bem menor, com algumas observações. O código é executado em <code>N/1 + N/2 + ... + N/(N-1) + N/N</code> passos. Podemos botar o <code>N</code> em evidencia <code>N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N)</code>. A soma dentro dos parenteses é menor que a área abaixo da curva da função <code>1/x</code>, a integral é <code>ln(x)</code>(mas relaxa que não precisa lembrar das coisas de cálculo 1). Portanto <code>O(N*(1/1 + 1/2 + 1/3 + ... + 1/(N-1) + 1/N)) = O(N*lg N)</code>.</p><p>Podemos resolver vários problemas usando isso pois <code>x</code> será divisor de <code>m</code> e assim para todo <code>m</code> também passaremos por todos os divisores deles.</p><h2 id=contando-os-divisores-de-vários-números>Contando os divisores de vários números</h2><p>Por exemplo, usando essa abordagem, poderíamos usar esses 2 laços aninhados para gerar um vetor <code>div</code> que informa quantos divisores todos os números até <code>n</code> tem.</p><p>Perceba que esses dois laços executam em <code>O(n * log n)</code>, enquanto repetir o algoritmo de contar os divisores de cada número individualmente teria complexidade <code>sqrt(1) + sqrt(2) + ... + sqrt(n)</code> = O(n * sqrt(n)), ou seja, tem complexidade melhor.</p><p>A abordagem abaixo funciona porque sempre que chegamos em um número <code>m</code> no laço mais interno, significa que temos um divisor a mais.</p><p>Na primeira iteração passamos por todos os números, já que começamos e 1 e estamos incrementando de 1 em 1, todos os números são divisíveis por 1, então todos ganham um divisor a mais no vetor.</p><p>Na segunda iteração, passamos apenas pelos números múltiplos de 2, em todos os números que chegarmos, significa que esse número é divisível por 2 (ou seja, sabemos que ele tem um divisor a mais). E repetimos esse raciocínio para todos os números.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> computa_divisores(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> qnt_div(N, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) {
</span></span><span style=display:flex><span>      qnt_div[m]<span style=color:#f92672>++</span>; <span style=color:#75715e>// aqui descobrimos que x é divisor de m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> qnt_div;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 25</div><h1>Números Primos</h1><p>Em particular, sabendo a quantidade de divisores de cada número, podemos varrer esse vetor vendo quais números são primos (tem 2 divisores).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos_ate_n(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(qnt_div[x] <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>      primos.push_back(x);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> primos;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=crivo-de-erastótenes>Crivo de erastótenes</h2><p>A abordagem acima tem uma complexidade aceitável, e passaria no tempo para a maioria dos problemas. No entanto, existe um algoritmo com uma ideia semelhante, mas que com algumas observações baixa essa complexidade de <code>O(n * log n)</code> para <code>O(n * log( log n))</code>. O log já abaixa muito um número, se aplicamos ele novamente, abaixamos mais ainda, ou seja, isso é quase linear.</p><p>A ideia usada é marcar inicialmente todos os números entre 1 e <code>N</code> como possiveis primos. Passando em ordem crescente e quando encontramos um primo marcamos os múltiplos do primo como não primos.</p><h3 id=visualização>Visualização</h3><p><img src=https://i.pinimg.com/originals/24/69/79/246979fd8d7bdf29a95cdb2e08cd2e89.gif alt=Crivo></p><h3 id=implementação>Implementação</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos_ate_n(<span style=color:#66d9ef>int</span> N) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> marcacao(N, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 1 = possivel primo, 0 = com certeza não primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primos;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>) <span style=color:#66d9ef>if</span>(marcacao[x] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    primos.push_back(x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x<span style=color:#f92672>+</span>x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) {
</span></span><span style=display:flex><span>      marcacao[m] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// aqui descobrimos que m não é primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> primos;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><footer class=footline></footer></article><article class=chapter dir=ltr><div class=article-subheading>Capítulo 26</div><h1>Fatoração</h1><p>Aprendemos na escola que todo número é composto por fatores primos, existindo uma única fatoração pra cada número.</p><p>Uma primeira abordagem possível seria passar por todos os números e ir dividindo sempre que possível.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// retorna vetor de pair&lt;primo, expoente&gt; da fatoração
</span></span></span><span style=display:flex><span><span style=color:#75715e>// fatora(36) = [{2, 2}, {3, 2}] ou seja, 36 = 2^2 + 3^2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; p <span style=color:#f92672>&lt;=</span> n; p<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> expoente <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> p;
</span></span><span style=display:flex><span>        expoente<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ans.emplace_back(p, expoente);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A primeira vista,como queremos decompor em fatores primos, parece que temos que testar se <code>p</code> é primo. Entretanto passamos por <code>p</code> de forma crescente e sempre que podemos dividimos <code>n</code> por <code>p</code> então a condição <code>(n % p == 0)</code> só será verdade para <code>p</code> primos.</p><p>Isso ocorre porque todos os fatores primos de um número são menores ou iguais a ele próprio, então quando chegamos em um número, é impossível que ele divida o número e não seja primo, pois se não for, os números primos que o compoem deveriam ter sido contabilizados numa iteração anterior.</p><p>Apesar do código acima rodar bem para vários exemplos, no pior caso <code>n</code> é primo e o código é executado em <code>O(n)</code>.</p><p>Podemos melhorar a complexidade com uma simples observação. É possivel ter <strong>apenas</strong> um primo maior que a <code>sqrt(n)</code>, por exemplo, 10 tem 5 como fator e <code>5 > sqrt(10)</code>, mas é impossível ter dois primos maiores que a raiz. Se tivermos <code>a > sqrt(n)</code> e <code>b > sqrt(n)</code>, quando multiplicamos temos que <code>a * b > sqrt(n) * sqrt(n)</code> e <code>a * b > n</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; p<span style=color:#f92672>*</span>p <span style=color:#f92672>&lt;=</span> n; p<span style=color:#f92672>++</span>) { <span style=color:#75715e>// comparação que evita o uso de doubles, p &lt;= sqrt(n) é o mesmo que p*p &lt;= n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> expoente <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span>(n <span style=color:#f92672>%</span> p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> p;
</span></span><span style=display:flex><span>        expoente<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ans.emplace_back(p, expoente);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) ans.emplace_back(n, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=fatoração-em-olg-n-para-números-até-n>Fatoração em O(lg n) para números até N</h2><p>É possível fatorar números ate um limite <code>N</code> em <code>O(lg n)</code> após preprocessamento <code>O(n log( log n))</code>. O que fazemos é uma pequena modificação no código do crivo, para que enquanto fazemos o crivo, preenchamos um vetor auxiliar <code>lp</code>, aonde <code>lp[x]</code> representa o maior número primo que divide <code>x</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> lp(N, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; x <span style=color:#f92672>&lt;</span> N; x<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(lp[x] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) { <span style=color:#75715e>// se x nao foi marcado antes, é primo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> x; m <span style=color:#f92672>&lt;</span> N; m <span style=color:#f92672>+=</span> x) <span style=color:#75715e>// todos os multiplos de i
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      lp[m] <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>Tendo este vetor podemos fatorar um numero <code>x</code> com o seguinte procedimento.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> fatora(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>  map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> expoentes;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>(x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    expoentes[ lp[x] ]<span style=color:#f92672>++</span>; <span style=color:#75715e>// aumentamos o expoente do primo lp[x] em 1 na resposta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    x <span style=color:#f92672>/=</span> lp[x];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span>(pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p : expoentes)
</span></span><span style=display:flex><span>    ans.emplace_back(p);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade do procedimento acima é <code>O(quantidade de fatores)</code>, que é limitado por <code>O(lg n)</code>, da para ver que no pior caso todos os fatores são 2(menor primo) e a complexidade é o <code>k</code> de <code>2^k = n</code>.</p><h2 id=número-de-divisores-dada-uma-fatoração>Número de divisores dada uma fatoração</h2><p>Vimos que todo inteiro N pode ser escrito de forma única como multiplicação de números primos. Assim,</p><span class="math align-center">$$N = {p_1}^{e_1}.{p_2}^{e_2}.{p_3}^{e_3}.{p_4}^{e_4}.{p_5}^{e_5}.{p_6}^{e_6} ... $$</span><p>onde pi é primo e 0 ei > 0.</p><p>Todo divisor de N só pode ter primos que aparecem na fatoração de N e expoente no máximo o do expoente no N. Por exemplo:
<span class="math align-center">$$36 = 2^2.3^2$$</span></p><span class="math align-left">$$1 = 2^0.3^0$$</span>
<span class="math align-left">$$2 = 2^1.3^0$$</span>
<span class="math align-left">$$3 = 2^0.3^1$$</span>
<span class="math align-left">$$4 = 2^2.3^0$$</span>
<span class="math align-left">$$6 = 2^1.3^1$$</span>
<span class="math align-left">$$9 = 2^0.3^2$$</span>
<span class="math align-left">$$12 = 2^2.3^1$$</span>
<span class="math align-left">$$18 = 2^1.3^2$$</span>
<span class="math align-left">$$36 = 2^2.3^2$$</span><p>Para construir um divisor podemos escolher dentre (ei+1) possibilidades para o primo pi. O número total de divisores é a multiplicação desses termos. Assim 36 tem (2+1)*(2+1) = 9 divisores.</p><p>Embora esta ideia não melhore a complexidade para encontrar o número de divisores em comparação com as ideias anteriores, ela pode ser uma ferramenta útil para analisar problemas. Por exemplo, os números com exatamente 9 divisores são da forma</p><span class="math align-left">$${p_1}^8={p_1}^2.{p_2}^2$$</span><p>Como por exemplo:</p><span class="math align-left">$$256 = 2^8$$</span>
<span class="math align-left">$$6561 = 3^8$$</span>
<span class="math align-left">$$36 = 2^2.3^2$$</span>
<span class="math align-left">$$100 = 2^2.5^2$$</span>
<span class="math align-left">$$255 = 3^2.5^2$$</span><p>etc&mldr;</p><footer class=footline></footer></article></section><article class=default dir=ltr><h1>Tópicos Avançados</h1><h2 id=subpáginas>Subpáginas</h2><ul class="children children-li children-sort-"><li><a href=/materiais/avancados/lca/>Lowest Common Ancestor</a></li></ul><footer class=footline></footer></article><section><h1 class=a11y-only>Subsecções de Tópicos Avançados</h1><article class=chapter dir=ltr><div class=article-subheading>Capítulo 27</div><h1>Lowest Common Ancestor</h1><p>Lowest Common ancestor (LCA) - ou ancestral comum mais baixo, é o nome típico dado para o seguinte problema: dado uma Árvore cuja raiz é um vértice arbitrário <code>e</code> dois vértices <code>u,v</code> que a pertencem, diga qual é o nó mais baixo(relativo a raiz) que é ancestral de <code>u,v</code>.</p><p><img src=https://i.imgur.com/OuGPlXf.png alt=a title=a></p><p>Por exemplo na imagem a cima, o LCA de 2 e 3 é 1, o LCA de 6 e 7 é 0, e o LCA de 1 e 2 é 1.</p><p>um jeito naive de se fazer isso seria o seguinte, para cada nó da árvore, pré-processamos sua profundidade com relação a raiz (raiz tem profundidade 0, filhos 1, e assim por diante). Agora, para determinarmos os LCA de dois vértices <code>u,v</code>, podemos fazer o seguinte procedimento. Escolhemos qual dos dois vértices está mais profundo, subimos nos seus pais até igualar as alturas de ambos, e após isso, vamos subindo em ambos os caminhos um a um até que os caminhos se encontrem, então saberemos o LCA.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> depth[<span style=color:#ae81ff>100005</span>];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[<span style=color:#ae81ff>100005</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pre_process_depth</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>	depth[u] <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> adj : graph[u]) {
</span></span><span style=display:flex><span>		pre_process_depth(adj, d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>slow_lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) {
</span></span><span style=display:flex><span>		swap(u, v);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(depth[u] <span style=color:#f92672>&gt;</span> depth[v]) {
</span></span><span style=display:flex><span>		u <span style=color:#f92672>=</span> pai[u];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span>(u <span style=color:#f92672>!=</span> v) {
</span></span><span style=display:flex><span>		u <span style=color:#f92672>=</span> pai[u];
</span></span><span style=display:flex><span>		v <span style=color:#f92672>=</span> pai[v];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Essa estratégia efetivamente funciona, então teríamos um pré-processamento que é um DFS e após isso conseguiríamos responder queries em <code>O(n)</code>, pois numa árvore com um ramo muito profundo teríamos no pior caso que subir todos os vértices, portando complexidade total de <code>O(n + Qn) = O(Qn)</code> onde <code>Q</code> é o número de queries e <code>n</code> a quantidade de nós na árvore.</p><p>O LCA é relevante porque como em uma árvore há um único caminho que liga dois vértices, se conseguimos obter o LCA rápido então uma das coisas que já ganhamos de quebra é conseguir responder as distâncias entre quaisquer par de vértices.</p><p>A distância vai ser a distância de um vértice para o LCA e do LCA para o outro, sendo que essas duas distâncias intermediárias são apenas a diferença de alturas na árvore.</p><p>Aqui nesse tutorial vamos mostrar duas ideias para computar LCA, uma que vai nos permitir responder Queries de LCA em <code>O(log n)</code> com preprocessamento <code>O(n log n)</code> e uma segunda abordagem que vai nos permitir responder queries de LCA em <code>O(1)</code> (isso mesmo, tempo constante!) com preprocessamento <code>O(n log n)</code> também.</p><p>Apesar de a complexidade da segunda abordagem para responder queries de LCA ser estritamente melhor que da primeira, veremos que a primeira carrega um pouco mais de informação, permitindo obter algumas outras informações fora o LCA, enquanto na segunda podemos obter apenas o LCA.</p><h1 id=abordagem-1>Abordagem 1</h1><p>O problema da solução naive é essa subida de um em um até que atinjamos o pai comum. Então faz sentido tentarmos atacarmos isso para ganhar um desempenho assintótico melhor. Uma coisa a se observar é que estamos fazendo duas buscas lineares. A primeira busca linear é pelo primeiro ancestral de <code>u</code> que iguala a altura a <code>v</code> e após isso outra busca linear para procurar o primeiro ancestral de ambos que é comum.</p><p>Podemos observar que há monotonicidade nessas buscas lineares, até certo ponto os ancestrais não satisfazem uma condição, e após certo ponto todos satisfazem. Na primeira estaríamos buscando o ancestral mais baixo de <code>u</code> que satisfaz a condição &ldquo;Ter altura menor ou igual a v&rdquo;, e na segunda &ldquo;Ser ancestral de <code>v</code>&rdquo;.</p><p>Aqui usaremos o conceito de &ldquo;k-ésimo pai&rdquo; que funciona assim: o primeiro pai é o pai do vértice, o segundo pai é o pai do pai do vértice, e assim por diante.</p><p>Se nós tivéssemos uma função <em>mágica</em> chamada por exemplo <code>climb(n,k)</code> que nos retornasse o k-ésimo pai do vértice <code>n</code>, poderíamos então usar buscas binárias na quantidade de vértices a subir para resolver esse problema, e restaria implementar essa função de maneira eficiente. Vamos seguir por essa linha de raciocínio então.</p><h2 id=o-pulo-do-gato>O pulo do gato</h2><p>Se nós tivéssemos uma outra função <code>mágica</code> chamada <code>p2k(n,k)</code> que retorna o (2^k)-ésimo pai de um vértice <code>n</code>, poderíamos implementar a função que sobe <code>k</code> vértices da seguinte maneira. Se nosso grafo tem tamanho menor que <code>10^6</code>, sabemos que não precisamos subir mais do que <code>2^20</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>climb</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&gt;=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i)) {
</span></span><span style=display:flex><span>			node <span style=color:#f92672>=</span> p2k(node,i);
</span></span><span style=display:flex><span>			k <span style=color:#f92672>-=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A complexidade dessa função depende do número que colocamos no for, que não precisa ser maior do que o <code>log</code> do tamanho do grafo(não faz sentido subir mais nós do que o grafo possui), então conseguimos obter o k-ésimo ancestral de um vértice arbitrário em complexidade <code>O(log) * X</code> aonde X é a complexidade de p2k.</p><p>Mostramos agora que podemos preprocessar todos os valores possíveis de p2k em <code>O(n log n)</code>. Precisamos saber os valores dos ancestrais para todos os <code>n</code> vértices e para cada vértice só faz sentido saber <code>log</code> ancestrais. Podemos obter todos os valores de uma vez usando programação dinâmica, com uma recorrência muito elegante.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>p2k</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> p2k(p2k(node, k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=versão-recursiva>Versão recursiva</h3><p>Usamos então memoização para computarmos cada estado em <code>O(1)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> memo[SIZE][log2(GRAPHSIZE)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>p2k</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(memo[node][k] <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> memo[node][k];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> memo[node][k] <span style=color:#f92672>=</span> p2k(p2k(node, k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=versão-iterativa>Versão iterativa</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> p2k[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	p2k[node][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pai[node];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		p2k[node][k] <span style=color:#f92672>=</span> p2k[p2k[node][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Dessa forma então temos o seguinte procedimento para acharmos o LCA, fazemos uma busca binária, em cada iteração obtemos o k-ésimo ancestral, e checamos se ele satisfaz as propriedades, tendo então complexidade <code>O(log n * log n) = O(log^2 n)</code>, já que fazemos <code>log</code> iterações e em cada iteração demoramos <code>log</code> para obter o k-ésimo ancestral. Isso funciona, mas podemos melhorar um pouco mais.</p><p>Ao invés de usarmos busca binária vamos usar uma técnica conhecida como <code>binary lifting</code> ou escalada binária, basicamente vamos percorrer bit a bit vendo se esse bit está na resposta ou não.</p><p>A ideia é a seguinte, vamos supor que a resposta da busca binária de o quanto eu tenho que subir a partir de um vértice para satisfazer uma propriedade seja 6(o primeiro ancestral que satisfaz a propriedade é o sexto pai). Podemos usar escala binária para procurar pelo último vértice que ainda não satisfaz a propriedade (no caso então seria o 5).</p><p>Usando nossa função p2k, podemos começar vendo se o oitavo pai já satisfaz a propriedade e sim satisfaz, então como estamos buscando o último que ainda satisfaz, não subimos para o oitavo pai. Depois verificamos que o quarto pai que ainda não satisfaz, então subimos para ele. Depois verificamos o segundo pai do quarto pai, isto é, o sexto pai do vértice original, que já satisfaz, então não subimos para ele, e por último, verificamos o pai do quarto pai (quinto pai do vértice original), que não satisfaz, então subimos pra ele e sabemos o último vértice que ainda não satisfaz a propriedade.</p><p>A escalada binária pode ser usada nas mesmas situações aonde a busca binária pode ser usada, mas algumas vezes (como essa), podemos obter uma complexidades assintóticas melhores.</p><p>Cada checagem para ver se um dos (2^k)-ésimos pais satisfazem a propriedade é constante, e checamos os pais <code>(2^k), 2^(k-1), 2^(k-2),..., 1</code> sempre dividindo por 2, então passamos por no máximo <code>log</code> vezes nessa checagem, portanto com essa ideia podemos obter o <code>lca</code> em <code>O(log n)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) swap(u,v);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(depth[p2k[u][i]] <span style=color:#f92672>&gt;=</span> depth[v])
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(u <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(p2k[v][i] <span style=color:#f92672>!=</span> p2k[u][i]) {
</span></span><span style=display:flex><span>			v <span style=color:#f92672>=</span> p2k[v][i];
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pai[v];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Perceba que estamos fazendo exatamente a ideia primeiramente apresentada na solução naive. Primeiro pegamos o vértice que está mais embaixo e subimos ele até o nível do outro, e após isso, subimos em ambos os vértices procurando o primeiro ancestral comum, mas em vez de fazermos busca linear, fazemos escalada binária.</p><p>A escala binária desempenha melhor nessa situação(em relação a busca binária) porque quando vamos construir o (n-ésimo) pai para fazer a checagem (somando vários (2^k)-ésimos pais) na busca binária, estaríamos colocando os mesmos vértices todas as vezes, por exemplo, tome o exemplo aonde o último vértice que satisfaz uma propridade é o 26.</p><pre tabindex=0><code>l = 0, r = 32, mid = 16(16), checagem passa.
l = 16, r = 32, mid = 24(16 + 8), checagem passa.
l = 24, r = 32, mid = 28(16 + 8 + 4), checagem falha
l = 24, r = 28, mid = 26(16 + 8 + 2), checagem passa
l = 26, r = 28, mid = 27(16 + 8 + 2 + 1), checagem falha
</code></pre><p>Quando a checagem passou para mid = 16, podíamos ter certeza que tinhamos que subir pelo menos até o décimo sexto pai, mas aí nos checks subsequentes perdemos tempo reconstruindo a resposta que já conhecemos. Então o que a escala binária faz é tomar vantagem disso.</p><h3 id=versão-final-do-código>Versão final do código</h3><p>Agora como mencionado podemos obter rapidamente a distância entre quaisquer 2 nós na árvore.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dist</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> depth[u] <span style=color:#f92672>+</span> depth[v] <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>depth[lca(u,v)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=versão-final-do-código-1>Versão final do código</h3><p>Apesar de não fazermos a busca binária que usava a função climb no final, é possível que essa implementação seja útil em alguns problemas.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> depth[SIZE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> graph[SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pre_process_depth</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>	depth[u] <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> adj : graph[u]) {
</span></span><span style=display:flex><span>		pre_process_depth(adj, d <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> p2k[SIZE][log2(SIZE)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lca</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(depth[u] <span style=color:#f92672>&lt;</span> depth[v]) swap(u,v);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(depth[p2k[u][i]] <span style=color:#f92672>&gt;=</span> depth[v])
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(u <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>return</span> u;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(p2k[v][i] <span style=color:#f92672>!=</span> p2k[u][i]) {
</span></span><span style=display:flex><span>			v <span style=color:#f92672>=</span> p2k[v][i];
</span></span><span style=display:flex><span>			u <span style=color:#f92672>=</span> p2k[u][i];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pai[v];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>climb</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> k){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(k <span style=color:#f92672>&gt;=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i)) {
</span></span><span style=display:flex><span>			node <span style=color:#f92672>=</span> p2k[node][i];
</span></span><span style=display:flex><span>			k <span style=color:#f92672>-=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> i);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dist</span>(<span style=color:#66d9ef>int</span> u, <span style=color:#66d9ef>int</span> v){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> depth[u] <span style=color:#f92672>+</span> depth[v] <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>depth[lca(u,v)];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// codigo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// le os pais e monta o grafo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pai[raiz] <span style=color:#f92672>=</span> raiz;
</span></span><span style=display:flex><span>	pre_proccess_depth(raiz); <span style=color:#75715e>// tipicamente qual vertice é a raiz nao importa
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>		p2k[node][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pai[node];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> node <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; node <span style=color:#f92672>&lt;</span> SIZE; node<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> log2(SIZE); k<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>			p2k[node][k] <span style=color:#f92672>=</span> p2k[p2k[node][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]][k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// resolve problema
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=conclusão>Conclusão</h3><p>Com essa abordagem, com preprocessamento <code>O(n log n)</code>, podemos responder queries de LCA (e climb, e dist) em <code>O(log n)</code>, além disso, podemos modificar a DP do LCA para guardar mais informações além de qual o (2^k)-ésimo pai, por exemplo a aresta mínima(ou máxima) nesse caminho, a soma dos custos das arestas(caso hajam pesos), máximo divisor comum, etc.</p><h2 id=abordagem-2>Abordagem 2</h2><p>A segunda abordagem usa uma ideia diferente, mas que também é muito top. Com preprocessamento <code>O(n log n)</code> podemos fazer queries de LCA em <code>O(1)</code>. Parando pra pensar nisso, é muito poderoso, não importa o quanto seja o tamanho do grafo, teremos a resposta em tempo constante! A ideia para atingir essa complexidade é a seguinte. Sabemos que usando uma Sparse Table(Vide aula de Sparse Table) podemos resolver problemas de RMQ (range minimum query) em <code>O(1)</code>, com preprocessamento <code>O(n log n)</code> a ideia é construir um vetor de forma que a RMQ nele representa a query de LCA.</p><h2 id=materiais-complementares>Materiais complementares</h2><p><a href="https://www.youtube.com/watch?v=EKcQt-74bNw">https://www.youtube.com/watch?v=EKcQt-74bNw</a></p><h2 id=exercícios-recomendados>Exercícios recomendados</h2><ul><li><a href=https://codeforces.com/problemset/problem/208/e>https://codeforces.com/problemset/problem/208/e</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/2470>https://www.urionlinejudge.com.br/judge/pt/problems/view/2470</a></li><li><a href=https://www.urionlinejudge.com.br/judge/pt/problems/view/1135>https://www.urionlinejudge.com.br/judge/pt/problems/view/1135</a></li><li><a href=https://www.spoj.com/problems/QTREE2/>https://www.spoj.com/problems/QTREE2/</a> - queries de distancia e obter k-ésimo vértice no caminho, Só da pra obter késimo vértice com LCA log.</li></ul><footer class=footline></footer></article></section></section></div></main></div><aside id=sidebar class="default-animation showVisitedLinks"><div id=header-wrapper class=default-animation><div id=header class=default-animation><img src=/images/logo.png alt=UnBalloon></div><div class="searchbox default-animation"><label class=a11y-only for=search-by>Procurar</label>
<i class="fas fa-search"></i>
<input data-search-input id=search-by type=search placeholder=Procurar...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script>var contentLangs=["pt"]</script><script src=/js/auto-complete.js?1682198716 defer></script>
<script src=/js/lunr.min.js?1682198716 defer></script>
<script src=/js/lunr.stemmer.support.min.js?1682198716 defer></script>
<script src=/js/lunr.multi.min.js?1682198716 defer></script>
<script src=/js/lunr.pt.min.js?1682198716 defer></script>
<script src=/js/search.js?1682198716 defer></script></div><div id=homelinks class=default-animation><ul><li><a class=padding href=/><i class='fas fa-home'></i> Início</a></li></ul></div><div id=content-wrapper class=highlightable><ul class="topics collapsible-menu"><li data-nav-id=/sobre/ class="dd-item alwaysopen"><input type=checkbox id=section-6ddbbbfc94aba0359e47bedbb5c0bf1e aria-controls=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e class=toggle checked><label class="a11y-only toggle" for=section-6ddbbbfc94aba0359e47bedbb5c0bf1e>Submenu Sobre</label><a href=/sobre/>Sobre<i class="fas fa-check read-icon"></i></a><ul id=subsections-6ddbbbfc94aba0359e47bedbb5c0bf1e><li data-nav-id=/sobre/dicas/ class=dd-item><a href=/sobre/dicas/>Dicas para Iniciantes<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/unb/ class=dd-item><a href=/sobre/unb/>UnB na Competitiva<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/eventos/ class=dd-item><a href=/sobre/eventos/>Eventos Anteriores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/competicoes/ class=dd-item><a href=/sobre/competicoes/>Competições<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/sobre/referencias/ class=dd-item><a href=/sobre/referencias/>Referências<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/ class="dd-item active parent alwaysopen"><input type=checkbox id=section-cd3c658ea9d6611734f640a99ed351e7 aria-controls=subsections-cd3c658ea9d6611734f640a99ed351e7 class=toggle checked><label class="a11y-only toggle" for=section-cd3c658ea9d6611734f640a99ed351e7>Submenu Materiais</label><a href=/materiais/>Materiais<i class="fas fa-check read-icon"></i></a><ul id=subsections-cd3c658ea9d6611734f640a99ed351e7><li data-nav-id=/materiais/fundamentos/ class=dd-item><input type=checkbox id=section-fbd8681c1cd813fd274363752298e387 aria-controls=subsections-fbd8681c1cd813fd274363752298e387 class=toggle><label class="a11y-only toggle" for=section-fbd8681c1cd813fd274363752298e387>Submenu Fundamentos do C++</label><a href=/materiais/fundamentos/>Fundamentos do C++<i class="fas fa-check read-icon"></i></a><ul id=subsections-fbd8681c1cd813fd274363752298e387><li data-nav-id=/materiais/fundamentos/complexidade/ class=dd-item><a href=/materiais/fundamentos/complexidade/>Complexidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/input-output/ class=dd-item><a href=/materiais/fundamentos/input-output/>Entrada/Saída<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/ class=dd-item><input type=checkbox id=section-a42839fe6a6dc82d6acb542625c12ea3 aria-controls=subsections-a42839fe6a6dc82d6acb542625c12ea3 class=toggle><label class="a11y-only toggle" for=section-a42839fe6a6dc82d6acb542625c12ea3>Submenu Declarações</label><a href=/materiais/fundamentos/declaracoes/>Declarações<i class="fas fa-check read-icon"></i></a><ul id=subsections-a42839fe6a6dc82d6acb542625c12ea3><li data-nav-id=/materiais/fundamentos/declaracoes/string/ class=dd-item><a href=/materiais/fundamentos/declaracoes/string/>Strings<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/vector/ class=dd-item><a href=/materiais/fundamentos/declaracoes/vector/>Vector<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/pair/ class=dd-item><a href=/materiais/fundamentos/declaracoes/pair/>Pairs<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/declaracoes/iterators/ class=dd-item><a href=/materiais/fundamentos/declaracoes/iterators/>Iterators<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ class=dd-item><input type=checkbox id=section-0f35d6b01e259d59953ce71b0a1b869a aria-controls=subsections-0f35d6b01e259d59953ce71b0a1b869a class=toggle><label class="a11y-only toggle" for=section-0f35d6b01e259d59953ce71b0a1b869a>Submenu Estrutura de Dados</label><a href=/materiais/fundamentos/eds/>Estrutura de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-0f35d6b01e259d59953ce71b0a1b869a><li data-nav-id=/materiais/fundamentos/eds/ed_linear/ class=dd-item><input type=checkbox id=section-647945f1e1a23f4847ff7712e174196b aria-controls=subsections-647945f1e1a23f4847ff7712e174196b class=toggle><label class="a11y-only toggle" for=section-647945f1e1a23f4847ff7712e174196b>Submenu ED Linear</label><a href=/materiais/fundamentos/eds/ed_linear/>ED Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-647945f1e1a23f4847ff7712e174196b><li data-nav-id=/materiais/fundamentos/eds/ed_linear/pilha/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/pilha/>Pilha<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila/>Fila<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_linear/fila_prioridade/ class=dd-item><a href=/materiais/fundamentos/eds/ed_linear/fila_prioridade/>Fila de Prioridade<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/ class=dd-item><input type=checkbox id=section-b42c90bc6b6a5f5588c9a9bab5cef1a6 aria-controls=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6 class=toggle><label class="a11y-only toggle" for=section-b42c90bc6b6a5f5588c9a9bab5cef1a6>Submenu ED Não Linear</label><a href=/materiais/fundamentos/eds/ed_n_linear/>ED Não Linear<i class="fas fa-check read-icon"></i></a><ul id=subsections-b42c90bc6b6a5f5588c9a9bab5cef1a6><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/map/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/map/>Map<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/fundamentos/eds/ed_n_linear/set/ class=dd-item><a href=/materiais/fundamentos/eds/ed_n_linear/set/>Set<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul></li><li data-nav-id=/materiais/ed/ class=dd-item><input type=checkbox id=section-b37842fb4120c27b31481184fc126654 aria-controls=subsections-b37842fb4120c27b31481184fc126654 class=toggle><label class="a11y-only toggle" for=section-b37842fb4120c27b31481184fc126654>Submenu Estruturas de Dados</label><a href=/materiais/ed/>Estruturas de Dados<i class="fas fa-check read-icon"></i></a><ul id=subsections-b37842fb4120c27b31481184fc126654><li data-nav-id=/materiais/ed/delta_encoding/ class=dd-item><a href=/materiais/ed/delta_encoding/>Delta Encoding<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/psum/ class=dd-item><a href=/materiais/ed/psum/>Soma de Prefixos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/segtree/ class=dd-item><a href=/materiais/ed/segtree/>Segment Trees<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/ed/sparse_table/ class=dd-item><a href=/materiais/ed/sparse_table/>Sparse Table<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/algoritmos/ class=dd-item><input type=checkbox id=section-586ba47d0e40b9c87415f456840d3d8a aria-controls=subsections-586ba47d0e40b9c87415f456840d3d8a class=toggle><label class="a11y-only toggle" for=section-586ba47d0e40b9c87415f456840d3d8a>Submenu Algoritmos</label><a href=/materiais/algoritmos/>Algoritmos<i class="fas fa-check read-icon"></i></a><ul id=subsections-586ba47d0e40b9c87415f456840d3d8a><li data-nav-id=/materiais/algoritmos/busca_binaria/ class=dd-item><a href=/materiais/algoritmos/busca_binaria/>Busca Binária<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/grafos/ class=dd-item><input type=checkbox id=section-2b03d3e4a9450bb4c9d2399c7f4c7068 aria-controls=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068 class=toggle><label class="a11y-only toggle" for=section-2b03d3e4a9450bb4c9d2399c7f4c7068>Submenu Grafos</label><a href=/materiais/grafos/>Grafos<i class="fas fa-check read-icon"></i></a><ul id=subsections-2b03d3e4a9450bb4c9d2399c7f4c7068><li data-nav-id=/materiais/grafos/representacao/ class=dd-item><a href=/materiais/grafos/representacao/>Representação de Grafos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_largura/ class=dd-item><a href=/materiais/grafos/busca_largura/>Busca em Largura<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/busca_profundidade/ class=dd-item><a href=/materiais/grafos/busca_profundidade/>Busca em Profundidade<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/grafos/dijkstra/ class=dd-item><a href=/materiais/grafos/dijkstra/>Dijkstra<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/bitwise/ class=dd-item><a href=/materiais/bitwise/>Bitwise<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/ class=dd-item><input type=checkbox id=section-99efeb3b1634e5d2f1c17337d707c814 aria-controls=subsections-99efeb3b1634e5d2f1c17337d707c814 class=toggle><label class="a11y-only toggle" for=section-99efeb3b1634e5d2f1c17337d707c814>Submenu Matematica</label><a href=/materiais/matematica/>Matematica<i class="fas fa-check read-icon"></i></a><ul id=subsections-99efeb3b1634e5d2f1c17337d707c814><li data-nav-id=/materiais/matematica/modulo/ class=dd-item><a href=/materiais/matematica/modulo/>Módulo<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/divisores/ class=dd-item><a href=/materiais/matematica/divisores/>Divisores<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/primos/ class=dd-item><a href=/materiais/matematica/primos/>Números Primos<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/materiais/matematica/fatoracao/ class=dd-item><a href=/materiais/matematica/fatoracao/>Fatoração<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/materiais/avancados/ class=dd-item><input type=checkbox id=section-57c0233d0cea835299bcd9b57157a588 aria-controls=subsections-57c0233d0cea835299bcd9b57157a588 class=toggle><label class="a11y-only toggle" for=section-57c0233d0cea835299bcd9b57157a588>Submenu Tópicos Avançados</label><a href=/materiais/avancados/>Tópicos Avançados<i class="fas fa-check read-icon"></i></a><ul id=subsections-57c0233d0cea835299bcd9b57157a588><li data-nav-id=/materiais/avancados/lca/ class=dd-item><a href=/materiais/avancados/lca/>Lowest Common Ancestor<i class="fas fa-check read-icon"></i></a></li></ul></li></ul></li></ul><div id=shortcuts><div class=nav-title>Mais</div><ul><li><a class=padding href=https://github.com/UnBalloon/unballoon.github.io><i class='fab fa-fw fa-github'></i> Repositório GitHub</a></li><li><a class=padding href=https://codeforces.com/group/nituVTsHQX><i class='fa fa-code'></i> CodeForces</a></li><li><a class=padding href=https://t.me/unballoon><i class='fab fa-fw fa-telegram'></i> Telegram</a></li><li><a class=padding href=https://discord.gg/uc4htcV7fD><i class='fab fa-fw fa-discord'></i> Discord</a></li><li><a class=padding href=/more/credits/><i class='fas fa-fw fa-bullhorn'></i> Créditos</a></li><li><a class=padding href=/tags/><i class='fas fa-fw fa-tags'></i> Tags</a></li></ul></div><div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"></div><hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showVisitedLinks showFooter"><div id=prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch showVisitedLinks"><ul><li id=select-language-container class=footerLangSwitch><div class="padding select-container"><i class="fas fa-language fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-language>Idioma</label>
<select id=select-language onchange="location=baseUri+this.value"></select></div><div class=select-clear></div></div></li><li id=select-variant-container class="footerVariantSwitch showVariantSwitch"><div class="padding select-container"><i class="fas fa-paint-brush fa-fw"></i>
<span>&nbsp;</span><div class=select-style><label class=a11y-only for=select-variant>Tema</label>
<select id=select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=relearn-dark value=relearn-dark selected>Relearn Dark</option><option id=relearn-light value=relearn-light>Relearn Light</option><option id=neon value=neon>Neon</option><option id=learn value=learn>Learn</option><option id=blue value=blue>Blue</option><option id=green value=green>Green</option><option id=red value=red>Red</option></select></div><div class=select-clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><a class=padding onclick=clearHistory()><i class="fas fa-history fa-fw"></i> Limpar Histórico</a></li></ul></div><div id=footer class="footerFooter showFooter"><style>#footer{font-size:13px;height:100px;margin-left:auto;margin-right:auto;padding:2rem 1rem;text-align:center;min-width:230px;max-width:300px}#footer p{margin:0}</style><a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/archive/main.zip data-icon=octicon-cloud-download aria-label="Download UnBalloon/unballoon.github.io on GitHub">Download</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io data-icon=octicon-star data-show-count=true aria-label="Star UnBalloon/unballoon.github.io on GitHub">Star</a>
<a class=github-button href=https://github.com/UnBalloon/unballoon.github.io/fork data-icon=octicon-repo-forked data-show-count=true aria-label="Fork McShelby/hugo-theme-relearn on GitHub">Fork</a><p>2023 - <a href=https://github.com/BrunoVarg>Bruno Vargas</a></p><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p><script asy unballoon procurar início submenu sobre sobre dicas para iniciantes unb na competitiva eventos anteriores competições referências submenu materiais materiais submenu fundamentos do c++ fundamentos do c++ submenu estruturas de dados estruturas de dados submenu algoritmos algoritmos submenu grafos grafos bitwise submenu matematica matematica submenu tópicos avançados tópicos avançados mais repositório github codeforces telegram discord créditos tags tema limpar histórico 2023 - bruno vargas built with by hugo nc src=/js/buttons.js?1682198716></script></div></div></aside><script src=/js/clipboard.min.js?1682198716 defer></script>
<script src=/js/perfect-scrollbar.min.js?1682198716 defer></script>
<script src=/js/featherlight.min.js?1682198716 defer></script>
<script>function useMathJax(e){if(!Object.assign)return;window.MathJax=Object.assign(window.MathJax||{},{loader:{load:["[tex]/mhchem"]},startup:{elements:[".math"]},tex:{inlineMath:[["$","$"],["\\(","\\)"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/js/mathjax/tex-mml-chtml.js?1682198716></script>
<script src=/js/theme.js?1682198716 defer></script></body></html>